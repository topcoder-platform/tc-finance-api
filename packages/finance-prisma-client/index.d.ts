
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model audit
 * 
 */
export type audit = $Result.DefaultSelection<Prisma.$auditPayload>
/**
 * Model origin
 * 
 */
export type origin = $Result.DefaultSelection<Prisma.$originPayload>
/**
 * Model otp
 * 
 */
export type otp = $Result.DefaultSelection<Prisma.$otpPayload>
/**
 * Model payment
 * 
 */
export type payment = $Result.DefaultSelection<Prisma.$paymentPayload>
/**
 * Model payment_method
 * 
 */
export type payment_method = $Result.DefaultSelection<Prisma.$payment_methodPayload>
/**
 * Model payment_release_associations
 * 
 */
export type payment_release_associations = $Result.DefaultSelection<Prisma.$payment_release_associationsPayload>
/**
 * Model payment_releases
 * 
 */
export type payment_releases = $Result.DefaultSelection<Prisma.$payment_releasesPayload>
/**
 * Model user_payment_methods
 * 
 */
export type user_payment_methods = $Result.DefaultSelection<Prisma.$user_payment_methodsPayload>
/**
 * Model user_tax_form_associations
 * 
 */
export type user_tax_form_associations = $Result.DefaultSelection<Prisma.$user_tax_form_associationsPayload>
/**
 * Model winnings
 * 
 */
export type winnings = $Result.DefaultSelection<Prisma.$winningsPayload>
/**
 * Model trolley_recipient
 * 
 */
export type trolley_recipient = $Result.DefaultSelection<Prisma.$trolley_recipientPayload>
/**
 * Model trolley_webhook_log
 * 
 */
export type trolley_webhook_log = $Result.DefaultSelection<Prisma.$trolley_webhook_logPayload>
/**
 * Model user_identity_verification_associations
 * 
 */
export type user_identity_verification_associations = $Result.DefaultSelection<Prisma.$user_identity_verification_associationsPayload>
/**
 * Model trolley_recipient_payment_method
 * 
 */
export type trolley_recipient_payment_method = $Result.DefaultSelection<Prisma.$trolley_recipient_payment_methodPayload>
/**
 * Model challenge_lock
 * 
 */
export type challenge_lock = $Result.DefaultSelection<Prisma.$challenge_lockPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const webhook_status: {
  error: 'error',
  processed: 'processed',
  logged: 'logged'
};

export type webhook_status = (typeof webhook_status)[keyof typeof webhook_status]


export const verification_status: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type verification_status = (typeof verification_status)[keyof typeof verification_status]


export const action_type: {
  INITIATE_WITHDRAWAL: 'INITIATE_WITHDRAWAL',
  ADD_WITHDRAWAL_METHOD: 'ADD_WITHDRAWAL_METHOD',
  REMOVE_WITHDRAWAL_METHOD: 'REMOVE_WITHDRAWAL_METHOD',
  SETUP_TAX_FORMS: 'SETUP_TAX_FORMS',
  REMOVE_TAX_FORMS: 'REMOVE_TAX_FORMS'
};

export type action_type = (typeof action_type)[keyof typeof action_type]


export const payment_method_status: {
  OTP_PENDING: 'OTP_PENDING',
  OTP_VERIFIED: 'OTP_VERIFIED',
  CONNECTED: 'CONNECTED',
  INACTIVE: 'INACTIVE'
};

export type payment_method_status = (typeof payment_method_status)[keyof typeof payment_method_status]


export const payment_status: {
  PAID: 'PAID',
  ON_HOLD: 'ON_HOLD',
  ON_HOLD_ADMIN: 'ON_HOLD_ADMIN',
  OWED: 'OWED',
  PROCESSING: 'PROCESSING',
  CANCELLED: 'CANCELLED',
  FAILED: 'FAILED',
  RETURNED: 'RETURNED',
  CREDITED: 'CREDITED'
};

export type payment_status = (typeof payment_status)[keyof typeof payment_status]


export const reference_type: {
  ADD_PAYMENT_METHOD: 'ADD_PAYMENT_METHOD',
  REMOVE_PAYMENT_METHOD: 'REMOVE_PAYMENT_METHOD',
  GET_PAYMENT_METHOD_REGISTRATION_LINK: 'GET_PAYMENT_METHOD_REGISTRATION_LINK',
  VIEW_TAX_FORM: 'VIEW_TAX_FORM',
  SUBMIT_TAX_FORM: 'SUBMIT_TAX_FORM',
  REMOVE_TAX_FORM: 'REMOVE_TAX_FORM',
  WITHDRAW_PAYMENT: 'WITHDRAW_PAYMENT'
};

export type reference_type = (typeof reference_type)[keyof typeof reference_type]


export const tax_form_status: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type tax_form_status = (typeof tax_form_status)[keyof typeof tax_form_status]


export const transaction_status: {
  INITIATED: 'INITIATED',
  COMPLETED: 'COMPLETED',
  EXPIRED: 'EXPIRED',
  CANCELLED: 'CANCELLED',
  FAILED: 'FAILED'
};

export type transaction_status = (typeof transaction_status)[keyof typeof transaction_status]


export const winnings_category: {
  ALGORITHM_CONTEST_PAYMENT: 'ALGORITHM_CONTEST_PAYMENT',
  CONTRACT_PAYMENT: 'CONTRACT_PAYMENT',
  PROBLEM_PAYMENT: 'PROBLEM_PAYMENT',
  CODER_REFERRAL_PAYMENT: 'CODER_REFERRAL_PAYMENT',
  CHARITY_PAYMENT: 'CHARITY_PAYMENT',
  COMPONENT_PAYMENT: 'COMPONENT_PAYMENT',
  REVIEW_BOARD_PAYMENT: 'REVIEW_BOARD_PAYMENT',
  ONE_OFF_PAYMENT: 'ONE_OFF_PAYMENT',
  BUG_FIXES_PAYMENT: 'BUG_FIXES_PAYMENT',
  MARATHON_MATCH_PAYMENT: 'MARATHON_MATCH_PAYMENT',
  DIGITAL_RUN_PAYMENT: 'DIGITAL_RUN_PAYMENT',
  DIGITAL_RUN_ROOKIE_PAYMENT: 'DIGITAL_RUN_ROOKIE_PAYMENT',
  PROBLEM_TESTING_PAYMENT: 'PROBLEM_TESTING_PAYMENT',
  PROBLEM_WRITING_PAYMENT: 'PROBLEM_WRITING_PAYMENT',
  TOPCODER_STUDIO_CONTEST_PAYMENT: 'TOPCODER_STUDIO_CONTEST_PAYMENT',
  LOGO_CONTEST_PAYMENT: 'LOGO_CONTEST_PAYMENT',
  ARTICLE_PAYMENT: 'ARTICLE_PAYMENT',
  CCIP_PAYMENT: 'CCIP_PAYMENT',
  COMPONENT_TOURNAMENT_BONUS_PAYMENT: 'COMPONENT_TOURNAMENT_BONUS_PAYMENT',
  ROYALTY_PAYMENT: 'ROYALTY_PAYMENT',
  ALGORITHM_TOURNAMENT_PRIZE_PAYMENT: 'ALGORITHM_TOURNAMENT_PRIZE_PAYMENT',
  RELIABILITY_BONUS_PAYMENT: 'RELIABILITY_BONUS_PAYMENT',
  DIGITAL_RUN_TOP_PERFORMERS_PAYMENT: 'DIGITAL_RUN_TOP_PERFORMERS_PAYMENT',
  ARCHITECTURE_REVIEW_PAYMENT: 'ARCHITECTURE_REVIEW_PAYMENT',
  SPECIFICATION_REVIEW_PAYMENT: 'SPECIFICATION_REVIEW_PAYMENT',
  ASSEMBLY_COMPETITION_REVIEW: 'ASSEMBLY_COMPETITION_REVIEW',
  ARCHITECTURE_PAYMENT: 'ARCHITECTURE_PAYMENT',
  PREDICTIVE_CONTEST_PAYMENT: 'PREDICTIVE_CONTEST_PAYMENT',
  INTRODUCTORY_EVENT_COMPONENT_CONTEST_PAYMENT: 'INTRODUCTORY_EVENT_COMPONENT_CONTEST_PAYMENT',
  MARATHON_MATCH_TOURNAMENT_PRIZE_PAYMENT: 'MARATHON_MATCH_TOURNAMENT_PRIZE_PAYMENT',
  ASSEMBLY_PAYMENT: 'ASSEMBLY_PAYMENT',
  TESTING_PAYMENT: 'TESTING_PAYMENT',
  STUDIO_TOURNAMENT_PRIZE_PAYMENT: 'STUDIO_TOURNAMENT_PRIZE_PAYMENT',
  HIGH_SCHOOL_TOURNAMENT_PRIZE_PAYMENT: 'HIGH_SCHOOL_TOURNAMENT_PRIZE_PAYMENT',
  COLLEGE_TOUR_REPRESENTATIVE: 'COLLEGE_TOUR_REPRESENTATIVE',
  STUDIO_REVIEW_BOARD_PAYMENT: 'STUDIO_REVIEW_BOARD_PAYMENT',
  COMPONENT_ENHANCEMENTS_PAYMENT: 'COMPONENT_ENHANCEMENTS_PAYMENT',
  REVIEW_BOARD_BONUS_PAYMENT: 'REVIEW_BOARD_BONUS_PAYMENT',
  COMPONENT_BUILD_PAYMENT: 'COMPONENT_BUILD_PAYMENT',
  DIGITAL_RUN_V2_PAYMENT: 'DIGITAL_RUN_V2_PAYMENT',
  DIGITAL_RUN_V2_TOP_PERFORMERS_PAYMENT: 'DIGITAL_RUN_V2_TOP_PERFORMERS_PAYMENT',
  SPECIFICATION_CONTEST_PAYMENT: 'SPECIFICATION_CONTEST_PAYMENT',
  CONCEPTUALIZATION_CONTEST_PAYMENT: 'CONCEPTUALIZATION_CONTEST_PAYMENT',
  TEST_SUITES_PAYMENT: 'TEST_SUITES_PAYMENT',
  COPILOT_PAYMENT: 'COPILOT_PAYMENT',
  STUDIO_BUG_FIXES_PAYMENT: 'STUDIO_BUG_FIXES_PAYMENT',
  STUDIO_ENHANCEMENTS_PAYMENT: 'STUDIO_ENHANCEMENTS_PAYMENT',
  STUDIO_SPECIFICATION_REVIEW_PAYMENT: 'STUDIO_SPECIFICATION_REVIEW_PAYMENT',
  UI_PROTOTYPE_COMPETITION_PAYMENT: 'UI_PROTOTYPE_COMPETITION_PAYMENT',
  RIA_BUILD_COMPETITION_PAYMENT: 'RIA_BUILD_COMPETITION_PAYMENT',
  RIA_COMPONENT_COMPETITION_PAYMENT: 'RIA_COMPONENT_COMPETITION_PAYMENT',
  SPECIFICATION_WRITING_PAYMENT: 'SPECIFICATION_WRITING_PAYMENT',
  STUDIO_SPECIFICATION_WRITING_PAYMENT: 'STUDIO_SPECIFICATION_WRITING_PAYMENT',
  DEPLOYMENT_TASK_PAYMENT: 'DEPLOYMENT_TASK_PAYMENT',
  TEST_SCENARIOS_PAYMENT: 'TEST_SCENARIOS_PAYMENT',
  STUDIO_SUBMISSION_SCREENING_PAYMENT: 'STUDIO_SUBMISSION_SCREENING_PAYMENT',
  STUDIO_COPILOT_PAYMENT: 'STUDIO_COPILOT_PAYMENT',
  COPILOT_POSTING_PAYMENT: 'COPILOT_POSTING_PAYMENT',
  CONTENT_CREATION_PAYMENT: 'CONTENT_CREATION_PAYMENT',
  DIGITAL_RUN_V2_PAYMENT_TAXABLE: 'DIGITAL_RUN_V2_PAYMENT_TAXABLE',
  DIGITAL_RUN_V2_TOP_PERFORMERS_PAYMENT_TAXABLE: 'DIGITAL_RUN_V2_TOP_PERFORMERS_PAYMENT_TAXABLE',
  ENGAGEMENT_PAYMENT: 'ENGAGEMENT_PAYMENT',
  CONTEST_CHECKPOINT_PAYMENT: 'CONTEST_CHECKPOINT_PAYMENT',
  CONTEST_PAYMENT: 'CONTEST_PAYMENT',
  MARATHON_MATCH_NON_TAXABLE_PAYMENT: 'MARATHON_MATCH_NON_TAXABLE_PAYMENT',
  NEGATIVE_PAYMENT: 'NEGATIVE_PAYMENT',
  PROJECT_BUG_FIXES_PAYMENT: 'PROJECT_BUG_FIXES_PAYMENT',
  PROJECT_COPILOT_PAYMENT: 'PROJECT_COPILOT_PAYMENT',
  PROJECT_DEPLOYMENT_TASK_PAYMENT: 'PROJECT_DEPLOYMENT_TASK_PAYMENT',
  PROJECT_ENHANCEMENTS_PAYMENT: 'PROJECT_ENHANCEMENTS_PAYMENT',
  TASK_PAYMENT: 'TASK_PAYMENT',
  TASK_REVIEW_PAYMENT: 'TASK_REVIEW_PAYMENT',
  TASK_COPILOT_PAYMENT: 'TASK_COPILOT_PAYMENT',
  POINTS_AWARD: 'POINTS_AWARD'
};

export type winnings_category = (typeof winnings_category)[keyof typeof winnings_category]


export const winnings_type: {
  PAYMENT: 'PAYMENT',
  REWARD: 'REWARD',
  ENGAGEMENT: 'ENGAGEMENT',
  POINTS: 'POINTS'
};

export type winnings_type = (typeof winnings_type)[keyof typeof winnings_type]

}

export type webhook_status = $Enums.webhook_status

export const webhook_status: typeof $Enums.webhook_status

export type verification_status = $Enums.verification_status

export const verification_status: typeof $Enums.verification_status

export type action_type = $Enums.action_type

export const action_type: typeof $Enums.action_type

export type payment_method_status = $Enums.payment_method_status

export const payment_method_status: typeof $Enums.payment_method_status

export type payment_status = $Enums.payment_status

export const payment_status: typeof $Enums.payment_status

export type reference_type = $Enums.reference_type

export const reference_type: typeof $Enums.reference_type

export type tax_form_status = $Enums.tax_form_status

export const tax_form_status: typeof $Enums.tax_form_status

export type transaction_status = $Enums.transaction_status

export const transaction_status: typeof $Enums.transaction_status

export type winnings_category = $Enums.winnings_category

export const winnings_category: typeof $Enums.winnings_category

export type winnings_type = $Enums.winnings_type

export const winnings_type: typeof $Enums.winnings_type

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Audits
 * const audits = await prisma.audit.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Audits
   * const audits = await prisma.audit.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.audit`: Exposes CRUD operations for the **audit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Audits
    * const audits = await prisma.audit.findMany()
    * ```
    */
  get audit(): Prisma.auditDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.origin`: Exposes CRUD operations for the **origin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Origins
    * const origins = await prisma.origin.findMany()
    * ```
    */
  get origin(): Prisma.originDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.otp`: Exposes CRUD operations for the **otp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Otps
    * const otps = await prisma.otp.findMany()
    * ```
    */
  get otp(): Prisma.otpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.paymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment_method`: Exposes CRUD operations for the **payment_method** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payment_methods
    * const payment_methods = await prisma.payment_method.findMany()
    * ```
    */
  get payment_method(): Prisma.payment_methodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment_release_associations`: Exposes CRUD operations for the **payment_release_associations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payment_release_associations
    * const payment_release_associations = await prisma.payment_release_associations.findMany()
    * ```
    */
  get payment_release_associations(): Prisma.payment_release_associationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment_releases`: Exposes CRUD operations for the **payment_releases** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payment_releases
    * const payment_releases = await prisma.payment_releases.findMany()
    * ```
    */
  get payment_releases(): Prisma.payment_releasesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_payment_methods`: Exposes CRUD operations for the **user_payment_methods** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_payment_methods
    * const user_payment_methods = await prisma.user_payment_methods.findMany()
    * ```
    */
  get user_payment_methods(): Prisma.user_payment_methodsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_tax_form_associations`: Exposes CRUD operations for the **user_tax_form_associations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_tax_form_associations
    * const user_tax_form_associations = await prisma.user_tax_form_associations.findMany()
    * ```
    */
  get user_tax_form_associations(): Prisma.user_tax_form_associationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.winnings`: Exposes CRUD operations for the **winnings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Winnings
    * const winnings = await prisma.winnings.findMany()
    * ```
    */
  get winnings(): Prisma.winningsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trolley_recipient`: Exposes CRUD operations for the **trolley_recipient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trolley_recipients
    * const trolley_recipients = await prisma.trolley_recipient.findMany()
    * ```
    */
  get trolley_recipient(): Prisma.trolley_recipientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trolley_webhook_log`: Exposes CRUD operations for the **trolley_webhook_log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trolley_webhook_logs
    * const trolley_webhook_logs = await prisma.trolley_webhook_log.findMany()
    * ```
    */
  get trolley_webhook_log(): Prisma.trolley_webhook_logDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_identity_verification_associations`: Exposes CRUD operations for the **user_identity_verification_associations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_identity_verification_associations
    * const user_identity_verification_associations = await prisma.user_identity_verification_associations.findMany()
    * ```
    */
  get user_identity_verification_associations(): Prisma.user_identity_verification_associationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trolley_recipient_payment_method`: Exposes CRUD operations for the **trolley_recipient_payment_method** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trolley_recipient_payment_methods
    * const trolley_recipient_payment_methods = await prisma.trolley_recipient_payment_method.findMany()
    * ```
    */
  get trolley_recipient_payment_method(): Prisma.trolley_recipient_payment_methodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challenge_lock`: Exposes CRUD operations for the **challenge_lock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Challenge_locks
    * const challenge_locks = await prisma.challenge_lock.findMany()
    * ```
    */
  get challenge_lock(): Prisma.challenge_lockDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    audit: 'audit',
    origin: 'origin',
    otp: 'otp',
    payment: 'payment',
    payment_method: 'payment_method',
    payment_release_associations: 'payment_release_associations',
    payment_releases: 'payment_releases',
    user_payment_methods: 'user_payment_methods',
    user_tax_form_associations: 'user_tax_form_associations',
    winnings: 'winnings',
    trolley_recipient: 'trolley_recipient',
    trolley_webhook_log: 'trolley_webhook_log',
    user_identity_verification_associations: 'user_identity_verification_associations',
    trolley_recipient_payment_method: 'trolley_recipient_payment_method',
    challenge_lock: 'challenge_lock'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "audit" | "origin" | "otp" | "payment" | "payment_method" | "payment_release_associations" | "payment_releases" | "user_payment_methods" | "user_tax_form_associations" | "winnings" | "trolley_recipient" | "trolley_webhook_log" | "user_identity_verification_associations" | "trolley_recipient_payment_method" | "challenge_lock"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      audit: {
        payload: Prisma.$auditPayload<ExtArgs>
        fields: Prisma.auditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.auditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.auditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditPayload>
          }
          findFirst: {
            args: Prisma.auditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.auditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditPayload>
          }
          findMany: {
            args: Prisma.auditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditPayload>[]
          }
          create: {
            args: Prisma.auditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditPayload>
          }
          createMany: {
            args: Prisma.auditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.auditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditPayload>[]
          }
          delete: {
            args: Prisma.auditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditPayload>
          }
          update: {
            args: Prisma.auditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditPayload>
          }
          deleteMany: {
            args: Prisma.auditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.auditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.auditUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditPayload>[]
          }
          upsert: {
            args: Prisma.auditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditPayload>
          }
          aggregate: {
            args: Prisma.AuditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudit>
          }
          groupBy: {
            args: Prisma.auditGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditGroupByOutputType>[]
          }
          count: {
            args: Prisma.auditCountArgs<ExtArgs>
            result: $Utils.Optional<AuditCountAggregateOutputType> | number
          }
        }
      }
      origin: {
        payload: Prisma.$originPayload<ExtArgs>
        fields: Prisma.originFieldRefs
        operations: {
          findUnique: {
            args: Prisma.originFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$originPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.originFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$originPayload>
          }
          findFirst: {
            args: Prisma.originFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$originPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.originFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$originPayload>
          }
          findMany: {
            args: Prisma.originFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$originPayload>[]
          }
          create: {
            args: Prisma.originCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$originPayload>
          }
          createMany: {
            args: Prisma.originCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.originCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$originPayload>[]
          }
          delete: {
            args: Prisma.originDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$originPayload>
          }
          update: {
            args: Prisma.originUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$originPayload>
          }
          deleteMany: {
            args: Prisma.originDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.originUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.originUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$originPayload>[]
          }
          upsert: {
            args: Prisma.originUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$originPayload>
          }
          aggregate: {
            args: Prisma.OriginAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrigin>
          }
          groupBy: {
            args: Prisma.originGroupByArgs<ExtArgs>
            result: $Utils.Optional<OriginGroupByOutputType>[]
          }
          count: {
            args: Prisma.originCountArgs<ExtArgs>
            result: $Utils.Optional<OriginCountAggregateOutputType> | number
          }
        }
      }
      otp: {
        payload: Prisma.$otpPayload<ExtArgs>
        fields: Prisma.otpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.otpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.otpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpPayload>
          }
          findFirst: {
            args: Prisma.otpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.otpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpPayload>
          }
          findMany: {
            args: Prisma.otpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpPayload>[]
          }
          create: {
            args: Prisma.otpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpPayload>
          }
          createMany: {
            args: Prisma.otpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.otpCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpPayload>[]
          }
          delete: {
            args: Prisma.otpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpPayload>
          }
          update: {
            args: Prisma.otpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpPayload>
          }
          deleteMany: {
            args: Prisma.otpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.otpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.otpUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpPayload>[]
          }
          upsert: {
            args: Prisma.otpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpPayload>
          }
          aggregate: {
            args: Prisma.OtpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtp>
          }
          groupBy: {
            args: Prisma.otpGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtpGroupByOutputType>[]
          }
          count: {
            args: Prisma.otpCountArgs<ExtArgs>
            result: $Utils.Optional<OtpCountAggregateOutputType> | number
          }
        }
      }
      payment: {
        payload: Prisma.$paymentPayload<ExtArgs>
        fields: Prisma.paymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          findFirst: {
            args: Prisma.paymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          findMany: {
            args: Prisma.paymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>[]
          }
          create: {
            args: Prisma.paymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          createMany: {
            args: Prisma.paymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>[]
          }
          delete: {
            args: Prisma.paymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          update: {
            args: Prisma.paymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          deleteMany: {
            args: Prisma.paymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.paymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>[]
          }
          upsert: {
            args: Prisma.paymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.paymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      payment_method: {
        payload: Prisma.$payment_methodPayload<ExtArgs>
        fields: Prisma.payment_methodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.payment_methodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.payment_methodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>
          }
          findFirst: {
            args: Prisma.payment_methodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.payment_methodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>
          }
          findMany: {
            args: Prisma.payment_methodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>[]
          }
          create: {
            args: Prisma.payment_methodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>
          }
          createMany: {
            args: Prisma.payment_methodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.payment_methodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>[]
          }
          delete: {
            args: Prisma.payment_methodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>
          }
          update: {
            args: Prisma.payment_methodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>
          }
          deleteMany: {
            args: Prisma.payment_methodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.payment_methodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.payment_methodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>[]
          }
          upsert: {
            args: Prisma.payment_methodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>
          }
          aggregate: {
            args: Prisma.Payment_methodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment_method>
          }
          groupBy: {
            args: Prisma.payment_methodGroupByArgs<ExtArgs>
            result: $Utils.Optional<Payment_methodGroupByOutputType>[]
          }
          count: {
            args: Prisma.payment_methodCountArgs<ExtArgs>
            result: $Utils.Optional<Payment_methodCountAggregateOutputType> | number
          }
        }
      }
      payment_release_associations: {
        payload: Prisma.$payment_release_associationsPayload<ExtArgs>
        fields: Prisma.payment_release_associationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.payment_release_associationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_release_associationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.payment_release_associationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_release_associationsPayload>
          }
          findFirst: {
            args: Prisma.payment_release_associationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_release_associationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.payment_release_associationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_release_associationsPayload>
          }
          findMany: {
            args: Prisma.payment_release_associationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_release_associationsPayload>[]
          }
          create: {
            args: Prisma.payment_release_associationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_release_associationsPayload>
          }
          createMany: {
            args: Prisma.payment_release_associationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.payment_release_associationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_release_associationsPayload>[]
          }
          delete: {
            args: Prisma.payment_release_associationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_release_associationsPayload>
          }
          update: {
            args: Prisma.payment_release_associationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_release_associationsPayload>
          }
          deleteMany: {
            args: Prisma.payment_release_associationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.payment_release_associationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.payment_release_associationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_release_associationsPayload>[]
          }
          upsert: {
            args: Prisma.payment_release_associationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_release_associationsPayload>
          }
          aggregate: {
            args: Prisma.Payment_release_associationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment_release_associations>
          }
          groupBy: {
            args: Prisma.payment_release_associationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Payment_release_associationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.payment_release_associationsCountArgs<ExtArgs>
            result: $Utils.Optional<Payment_release_associationsCountAggregateOutputType> | number
          }
        }
      }
      payment_releases: {
        payload: Prisma.$payment_releasesPayload<ExtArgs>
        fields: Prisma.payment_releasesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.payment_releasesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_releasesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.payment_releasesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_releasesPayload>
          }
          findFirst: {
            args: Prisma.payment_releasesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_releasesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.payment_releasesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_releasesPayload>
          }
          findMany: {
            args: Prisma.payment_releasesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_releasesPayload>[]
          }
          create: {
            args: Prisma.payment_releasesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_releasesPayload>
          }
          createMany: {
            args: Prisma.payment_releasesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.payment_releasesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_releasesPayload>[]
          }
          delete: {
            args: Prisma.payment_releasesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_releasesPayload>
          }
          update: {
            args: Prisma.payment_releasesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_releasesPayload>
          }
          deleteMany: {
            args: Prisma.payment_releasesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.payment_releasesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.payment_releasesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_releasesPayload>[]
          }
          upsert: {
            args: Prisma.payment_releasesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_releasesPayload>
          }
          aggregate: {
            args: Prisma.Payment_releasesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment_releases>
          }
          groupBy: {
            args: Prisma.payment_releasesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Payment_releasesGroupByOutputType>[]
          }
          count: {
            args: Prisma.payment_releasesCountArgs<ExtArgs>
            result: $Utils.Optional<Payment_releasesCountAggregateOutputType> | number
          }
        }
      }
      user_payment_methods: {
        payload: Prisma.$user_payment_methodsPayload<ExtArgs>
        fields: Prisma.user_payment_methodsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_payment_methodsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_payment_methodsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>
          }
          findFirst: {
            args: Prisma.user_payment_methodsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_payment_methodsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>
          }
          findMany: {
            args: Prisma.user_payment_methodsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>[]
          }
          create: {
            args: Prisma.user_payment_methodsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>
          }
          createMany: {
            args: Prisma.user_payment_methodsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_payment_methodsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>[]
          }
          delete: {
            args: Prisma.user_payment_methodsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>
          }
          update: {
            args: Prisma.user_payment_methodsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>
          }
          deleteMany: {
            args: Prisma.user_payment_methodsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_payment_methodsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_payment_methodsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>[]
          }
          upsert: {
            args: Prisma.user_payment_methodsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>
          }
          aggregate: {
            args: Prisma.User_payment_methodsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_payment_methods>
          }
          groupBy: {
            args: Prisma.user_payment_methodsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_payment_methodsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_payment_methodsCountArgs<ExtArgs>
            result: $Utils.Optional<User_payment_methodsCountAggregateOutputType> | number
          }
        }
      }
      user_tax_form_associations: {
        payload: Prisma.$user_tax_form_associationsPayload<ExtArgs>
        fields: Prisma.user_tax_form_associationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_tax_form_associationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_tax_form_associationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_tax_form_associationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_tax_form_associationsPayload>
          }
          findFirst: {
            args: Prisma.user_tax_form_associationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_tax_form_associationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_tax_form_associationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_tax_form_associationsPayload>
          }
          findMany: {
            args: Prisma.user_tax_form_associationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_tax_form_associationsPayload>[]
          }
          create: {
            args: Prisma.user_tax_form_associationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_tax_form_associationsPayload>
          }
          createMany: {
            args: Prisma.user_tax_form_associationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_tax_form_associationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_tax_form_associationsPayload>[]
          }
          delete: {
            args: Prisma.user_tax_form_associationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_tax_form_associationsPayload>
          }
          update: {
            args: Prisma.user_tax_form_associationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_tax_form_associationsPayload>
          }
          deleteMany: {
            args: Prisma.user_tax_form_associationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_tax_form_associationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_tax_form_associationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_tax_form_associationsPayload>[]
          }
          upsert: {
            args: Prisma.user_tax_form_associationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_tax_form_associationsPayload>
          }
          aggregate: {
            args: Prisma.User_tax_form_associationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_tax_form_associations>
          }
          groupBy: {
            args: Prisma.user_tax_form_associationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_tax_form_associationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_tax_form_associationsCountArgs<ExtArgs>
            result: $Utils.Optional<User_tax_form_associationsCountAggregateOutputType> | number
          }
        }
      }
      winnings: {
        payload: Prisma.$winningsPayload<ExtArgs>
        fields: Prisma.winningsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.winningsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$winningsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.winningsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$winningsPayload>
          }
          findFirst: {
            args: Prisma.winningsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$winningsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.winningsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$winningsPayload>
          }
          findMany: {
            args: Prisma.winningsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$winningsPayload>[]
          }
          create: {
            args: Prisma.winningsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$winningsPayload>
          }
          createMany: {
            args: Prisma.winningsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.winningsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$winningsPayload>[]
          }
          delete: {
            args: Prisma.winningsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$winningsPayload>
          }
          update: {
            args: Prisma.winningsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$winningsPayload>
          }
          deleteMany: {
            args: Prisma.winningsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.winningsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.winningsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$winningsPayload>[]
          }
          upsert: {
            args: Prisma.winningsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$winningsPayload>
          }
          aggregate: {
            args: Prisma.WinningsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWinnings>
          }
          groupBy: {
            args: Prisma.winningsGroupByArgs<ExtArgs>
            result: $Utils.Optional<WinningsGroupByOutputType>[]
          }
          count: {
            args: Prisma.winningsCountArgs<ExtArgs>
            result: $Utils.Optional<WinningsCountAggregateOutputType> | number
          }
        }
      }
      trolley_recipient: {
        payload: Prisma.$trolley_recipientPayload<ExtArgs>
        fields: Prisma.trolley_recipientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.trolley_recipientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_recipientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.trolley_recipientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_recipientPayload>
          }
          findFirst: {
            args: Prisma.trolley_recipientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_recipientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.trolley_recipientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_recipientPayload>
          }
          findMany: {
            args: Prisma.trolley_recipientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_recipientPayload>[]
          }
          create: {
            args: Prisma.trolley_recipientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_recipientPayload>
          }
          createMany: {
            args: Prisma.trolley_recipientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.trolley_recipientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_recipientPayload>[]
          }
          delete: {
            args: Prisma.trolley_recipientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_recipientPayload>
          }
          update: {
            args: Prisma.trolley_recipientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_recipientPayload>
          }
          deleteMany: {
            args: Prisma.trolley_recipientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.trolley_recipientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.trolley_recipientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_recipientPayload>[]
          }
          upsert: {
            args: Prisma.trolley_recipientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_recipientPayload>
          }
          aggregate: {
            args: Prisma.Trolley_recipientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrolley_recipient>
          }
          groupBy: {
            args: Prisma.trolley_recipientGroupByArgs<ExtArgs>
            result: $Utils.Optional<Trolley_recipientGroupByOutputType>[]
          }
          count: {
            args: Prisma.trolley_recipientCountArgs<ExtArgs>
            result: $Utils.Optional<Trolley_recipientCountAggregateOutputType> | number
          }
        }
      }
      trolley_webhook_log: {
        payload: Prisma.$trolley_webhook_logPayload<ExtArgs>
        fields: Prisma.trolley_webhook_logFieldRefs
        operations: {
          findUnique: {
            args: Prisma.trolley_webhook_logFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_webhook_logPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.trolley_webhook_logFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_webhook_logPayload>
          }
          findFirst: {
            args: Prisma.trolley_webhook_logFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_webhook_logPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.trolley_webhook_logFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_webhook_logPayload>
          }
          findMany: {
            args: Prisma.trolley_webhook_logFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_webhook_logPayload>[]
          }
          create: {
            args: Prisma.trolley_webhook_logCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_webhook_logPayload>
          }
          createMany: {
            args: Prisma.trolley_webhook_logCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.trolley_webhook_logCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_webhook_logPayload>[]
          }
          delete: {
            args: Prisma.trolley_webhook_logDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_webhook_logPayload>
          }
          update: {
            args: Prisma.trolley_webhook_logUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_webhook_logPayload>
          }
          deleteMany: {
            args: Prisma.trolley_webhook_logDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.trolley_webhook_logUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.trolley_webhook_logUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_webhook_logPayload>[]
          }
          upsert: {
            args: Prisma.trolley_webhook_logUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_webhook_logPayload>
          }
          aggregate: {
            args: Prisma.Trolley_webhook_logAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrolley_webhook_log>
          }
          groupBy: {
            args: Prisma.trolley_webhook_logGroupByArgs<ExtArgs>
            result: $Utils.Optional<Trolley_webhook_logGroupByOutputType>[]
          }
          count: {
            args: Prisma.trolley_webhook_logCountArgs<ExtArgs>
            result: $Utils.Optional<Trolley_webhook_logCountAggregateOutputType> | number
          }
        }
      }
      user_identity_verification_associations: {
        payload: Prisma.$user_identity_verification_associationsPayload<ExtArgs>
        fields: Prisma.user_identity_verification_associationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_identity_verification_associationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_identity_verification_associationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_identity_verification_associationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_identity_verification_associationsPayload>
          }
          findFirst: {
            args: Prisma.user_identity_verification_associationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_identity_verification_associationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_identity_verification_associationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_identity_verification_associationsPayload>
          }
          findMany: {
            args: Prisma.user_identity_verification_associationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_identity_verification_associationsPayload>[]
          }
          create: {
            args: Prisma.user_identity_verification_associationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_identity_verification_associationsPayload>
          }
          createMany: {
            args: Prisma.user_identity_verification_associationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_identity_verification_associationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_identity_verification_associationsPayload>[]
          }
          delete: {
            args: Prisma.user_identity_verification_associationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_identity_verification_associationsPayload>
          }
          update: {
            args: Prisma.user_identity_verification_associationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_identity_verification_associationsPayload>
          }
          deleteMany: {
            args: Prisma.user_identity_verification_associationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_identity_verification_associationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_identity_verification_associationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_identity_verification_associationsPayload>[]
          }
          upsert: {
            args: Prisma.user_identity_verification_associationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_identity_verification_associationsPayload>
          }
          aggregate: {
            args: Prisma.User_identity_verification_associationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_identity_verification_associations>
          }
          groupBy: {
            args: Prisma.user_identity_verification_associationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_identity_verification_associationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_identity_verification_associationsCountArgs<ExtArgs>
            result: $Utils.Optional<User_identity_verification_associationsCountAggregateOutputType> | number
          }
        }
      }
      trolley_recipient_payment_method: {
        payload: Prisma.$trolley_recipient_payment_methodPayload<ExtArgs>
        fields: Prisma.trolley_recipient_payment_methodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.trolley_recipient_payment_methodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_recipient_payment_methodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.trolley_recipient_payment_methodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_recipient_payment_methodPayload>
          }
          findFirst: {
            args: Prisma.trolley_recipient_payment_methodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_recipient_payment_methodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.trolley_recipient_payment_methodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_recipient_payment_methodPayload>
          }
          findMany: {
            args: Prisma.trolley_recipient_payment_methodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_recipient_payment_methodPayload>[]
          }
          create: {
            args: Prisma.trolley_recipient_payment_methodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_recipient_payment_methodPayload>
          }
          createMany: {
            args: Prisma.trolley_recipient_payment_methodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.trolley_recipient_payment_methodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_recipient_payment_methodPayload>[]
          }
          delete: {
            args: Prisma.trolley_recipient_payment_methodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_recipient_payment_methodPayload>
          }
          update: {
            args: Prisma.trolley_recipient_payment_methodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_recipient_payment_methodPayload>
          }
          deleteMany: {
            args: Prisma.trolley_recipient_payment_methodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.trolley_recipient_payment_methodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.trolley_recipient_payment_methodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_recipient_payment_methodPayload>[]
          }
          upsert: {
            args: Prisma.trolley_recipient_payment_methodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trolley_recipient_payment_methodPayload>
          }
          aggregate: {
            args: Prisma.Trolley_recipient_payment_methodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrolley_recipient_payment_method>
          }
          groupBy: {
            args: Prisma.trolley_recipient_payment_methodGroupByArgs<ExtArgs>
            result: $Utils.Optional<Trolley_recipient_payment_methodGroupByOutputType>[]
          }
          count: {
            args: Prisma.trolley_recipient_payment_methodCountArgs<ExtArgs>
            result: $Utils.Optional<Trolley_recipient_payment_methodCountAggregateOutputType> | number
          }
        }
      }
      challenge_lock: {
        payload: Prisma.$challenge_lockPayload<ExtArgs>
        fields: Prisma.challenge_lockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.challenge_lockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challenge_lockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.challenge_lockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challenge_lockPayload>
          }
          findFirst: {
            args: Prisma.challenge_lockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challenge_lockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.challenge_lockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challenge_lockPayload>
          }
          findMany: {
            args: Prisma.challenge_lockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challenge_lockPayload>[]
          }
          create: {
            args: Prisma.challenge_lockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challenge_lockPayload>
          }
          createMany: {
            args: Prisma.challenge_lockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.challenge_lockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challenge_lockPayload>[]
          }
          delete: {
            args: Prisma.challenge_lockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challenge_lockPayload>
          }
          update: {
            args: Prisma.challenge_lockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challenge_lockPayload>
          }
          deleteMany: {
            args: Prisma.challenge_lockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.challenge_lockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.challenge_lockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challenge_lockPayload>[]
          }
          upsert: {
            args: Prisma.challenge_lockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challenge_lockPayload>
          }
          aggregate: {
            args: Prisma.Challenge_lockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallenge_lock>
          }
          groupBy: {
            args: Prisma.challenge_lockGroupByArgs<ExtArgs>
            result: $Utils.Optional<Challenge_lockGroupByOutputType>[]
          }
          count: {
            args: Prisma.challenge_lockCountArgs<ExtArgs>
            result: $Utils.Optional<Challenge_lockCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    audit?: auditOmit
    origin?: originOmit
    otp?: otpOmit
    payment?: paymentOmit
    payment_method?: payment_methodOmit
    payment_release_associations?: payment_release_associationsOmit
    payment_releases?: payment_releasesOmit
    user_payment_methods?: user_payment_methodsOmit
    user_tax_form_associations?: user_tax_form_associationsOmit
    winnings?: winningsOmit
    trolley_recipient?: trolley_recipientOmit
    trolley_webhook_log?: trolley_webhook_logOmit
    user_identity_verification_associations?: user_identity_verification_associationsOmit
    trolley_recipient_payment_method?: trolley_recipient_payment_methodOmit
    challenge_lock?: challenge_lockOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type OriginCountOutputType
   */

  export type OriginCountOutputType = {
    winnings: number
  }

  export type OriginCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    winnings?: boolean | OriginCountOutputTypeCountWinningsArgs
  }

  // Custom InputTypes
  /**
   * OriginCountOutputType without action
   */
  export type OriginCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OriginCountOutputType
     */
    select?: OriginCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OriginCountOutputType without action
   */
  export type OriginCountOutputTypeCountWinningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: winningsWhereInput
  }


  /**
   * Count Type PaymentCountOutputType
   */

  export type PaymentCountOutputType = {
    payment_release_associations: number
  }

  export type PaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_release_associations?: boolean | PaymentCountOutputTypeCountPayment_release_associationsArgs
  }

  // Custom InputTypes
  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCountOutputType
     */
    select?: PaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountPayment_release_associationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_release_associationsWhereInput
  }


  /**
   * Count Type Payment_methodCountOutputType
   */

  export type Payment_methodCountOutputType = {
    payment: number
    payment_releases: number
    user_payment_methods: number
  }

  export type Payment_methodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | Payment_methodCountOutputTypeCountPaymentArgs
    payment_releases?: boolean | Payment_methodCountOutputTypeCountPayment_releasesArgs
    user_payment_methods?: boolean | Payment_methodCountOutputTypeCountUser_payment_methodsArgs
  }

  // Custom InputTypes
  /**
   * Payment_methodCountOutputType without action
   */
  export type Payment_methodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment_methodCountOutputType
     */
    select?: Payment_methodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Payment_methodCountOutputType without action
   */
  export type Payment_methodCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentWhereInput
  }

  /**
   * Payment_methodCountOutputType without action
   */
  export type Payment_methodCountOutputTypeCountPayment_releasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_releasesWhereInput
  }

  /**
   * Payment_methodCountOutputType without action
   */
  export type Payment_methodCountOutputTypeCountUser_payment_methodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_payment_methodsWhereInput
  }


  /**
   * Count Type Payment_releasesCountOutputType
   */

  export type Payment_releasesCountOutputType = {
    payment_release_associations: number
  }

  export type Payment_releasesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_release_associations?: boolean | Payment_releasesCountOutputTypeCountPayment_release_associationsArgs
  }

  // Custom InputTypes
  /**
   * Payment_releasesCountOutputType without action
   */
  export type Payment_releasesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment_releasesCountOutputType
     */
    select?: Payment_releasesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Payment_releasesCountOutputType without action
   */
  export type Payment_releasesCountOutputTypeCountPayment_release_associationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_release_associationsWhereInput
  }


  /**
   * Count Type User_payment_methodsCountOutputType
   */

  export type User_payment_methodsCountOutputType = {
    trolley_payment_method: number
  }

  export type User_payment_methodsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trolley_payment_method?: boolean | User_payment_methodsCountOutputTypeCountTrolley_payment_methodArgs
  }

  // Custom InputTypes
  /**
   * User_payment_methodsCountOutputType without action
   */
  export type User_payment_methodsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_payment_methodsCountOutputType
     */
    select?: User_payment_methodsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * User_payment_methodsCountOutputType without action
   */
  export type User_payment_methodsCountOutputTypeCountTrolley_payment_methodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: trolley_recipientWhereInput
  }


  /**
   * Count Type WinningsCountOutputType
   */

  export type WinningsCountOutputType = {
    audit: number
    payment: number
  }

  export type WinningsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | WinningsCountOutputTypeCountAuditArgs
    payment?: boolean | WinningsCountOutputTypeCountPaymentArgs
  }

  // Custom InputTypes
  /**
   * WinningsCountOutputType without action
   */
  export type WinningsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WinningsCountOutputType
     */
    select?: WinningsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WinningsCountOutputType without action
   */
  export type WinningsCountOutputTypeCountAuditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auditWhereInput
  }

  /**
   * WinningsCountOutputType without action
   */
  export type WinningsCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentWhereInput
  }


  /**
   * Count Type Trolley_recipientCountOutputType
   */

  export type Trolley_recipientCountOutputType = {
    trolley_recipient_payment_methods: number
  }

  export type Trolley_recipientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trolley_recipient_payment_methods?: boolean | Trolley_recipientCountOutputTypeCountTrolley_recipient_payment_methodsArgs
  }

  // Custom InputTypes
  /**
   * Trolley_recipientCountOutputType without action
   */
  export type Trolley_recipientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trolley_recipientCountOutputType
     */
    select?: Trolley_recipientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Trolley_recipientCountOutputType without action
   */
  export type Trolley_recipientCountOutputTypeCountTrolley_recipient_payment_methodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: trolley_recipient_payment_methodWhereInput
  }


  /**
   * Models
   */

  /**
   * Model audit
   */

  export type AggregateAudit = {
    _count: AuditCountAggregateOutputType | null
    _min: AuditMinAggregateOutputType | null
    _max: AuditMaxAggregateOutputType | null
  }

  export type AuditMinAggregateOutputType = {
    id: string | null
    winnings_id: string | null
    user_id: string | null
    action: string | null
    note: string | null
    created_at: Date | null
  }

  export type AuditMaxAggregateOutputType = {
    id: string | null
    winnings_id: string | null
    user_id: string | null
    action: string | null
    note: string | null
    created_at: Date | null
  }

  export type AuditCountAggregateOutputType = {
    id: number
    winnings_id: number
    user_id: number
    action: number
    note: number
    created_at: number
    _all: number
  }


  export type AuditMinAggregateInputType = {
    id?: true
    winnings_id?: true
    user_id?: true
    action?: true
    note?: true
    created_at?: true
  }

  export type AuditMaxAggregateInputType = {
    id?: true
    winnings_id?: true
    user_id?: true
    action?: true
    note?: true
    created_at?: true
  }

  export type AuditCountAggregateInputType = {
    id?: true
    winnings_id?: true
    user_id?: true
    action?: true
    note?: true
    created_at?: true
    _all?: true
  }

  export type AuditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which audit to aggregate.
     */
    where?: auditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audits to fetch.
     */
    orderBy?: auditOrderByWithRelationInput | auditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned audits
    **/
    _count?: true | AuditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditMaxAggregateInputType
  }

  export type GetAuditAggregateType<T extends AuditAggregateArgs> = {
        [P in keyof T & keyof AggregateAudit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudit[P]>
      : GetScalarType<T[P], AggregateAudit[P]>
  }




  export type auditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auditWhereInput
    orderBy?: auditOrderByWithAggregationInput | auditOrderByWithAggregationInput[]
    by: AuditScalarFieldEnum[] | AuditScalarFieldEnum
    having?: auditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditCountAggregateInputType | true
    _min?: AuditMinAggregateInputType
    _max?: AuditMaxAggregateInputType
  }

  export type AuditGroupByOutputType = {
    id: string
    winnings_id: string
    user_id: string
    action: string
    note: string | null
    created_at: Date
    _count: AuditCountAggregateOutputType | null
    _min: AuditMinAggregateOutputType | null
    _max: AuditMaxAggregateOutputType | null
  }

  type GetAuditGroupByPayload<T extends auditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditGroupByOutputType[P]>
            : GetScalarType<T[P], AuditGroupByOutputType[P]>
        }
      >
    >


  export type auditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    winnings_id?: boolean
    user_id?: boolean
    action?: boolean
    note?: boolean
    created_at?: boolean
    winnings?: boolean | winningsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audit"]>

  export type auditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    winnings_id?: boolean
    user_id?: boolean
    action?: boolean
    note?: boolean
    created_at?: boolean
    winnings?: boolean | winningsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audit"]>

  export type auditSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    winnings_id?: boolean
    user_id?: boolean
    action?: boolean
    note?: boolean
    created_at?: boolean
    winnings?: boolean | winningsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audit"]>

  export type auditSelectScalar = {
    id?: boolean
    winnings_id?: boolean
    user_id?: boolean
    action?: boolean
    note?: boolean
    created_at?: boolean
  }

  export type auditOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "winnings_id" | "user_id" | "action" | "note" | "created_at", ExtArgs["result"]["audit"]>
  export type auditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    winnings?: boolean | winningsDefaultArgs<ExtArgs>
  }
  export type auditIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    winnings?: boolean | winningsDefaultArgs<ExtArgs>
  }
  export type auditIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    winnings?: boolean | winningsDefaultArgs<ExtArgs>
  }

  export type $auditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "audit"
    objects: {
      winnings: Prisma.$winningsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      winnings_id: string
      user_id: string
      action: string
      note: string | null
      created_at: Date
    }, ExtArgs["result"]["audit"]>
    composites: {}
  }

  type auditGetPayload<S extends boolean | null | undefined | auditDefaultArgs> = $Result.GetResult<Prisma.$auditPayload, S>

  type auditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<auditFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditCountAggregateInputType | true
    }

  export interface auditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['audit'], meta: { name: 'audit' } }
    /**
     * Find zero or one Audit that matches the filter.
     * @param {auditFindUniqueArgs} args - Arguments to find a Audit
     * @example
     * // Get one Audit
     * const audit = await prisma.audit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends auditFindUniqueArgs>(args: SelectSubset<T, auditFindUniqueArgs<ExtArgs>>): Prisma__auditClient<$Result.GetResult<Prisma.$auditPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Audit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {auditFindUniqueOrThrowArgs} args - Arguments to find a Audit
     * @example
     * // Get one Audit
     * const audit = await prisma.audit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends auditFindUniqueOrThrowArgs>(args: SelectSubset<T, auditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__auditClient<$Result.GetResult<Prisma.$auditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditFindFirstArgs} args - Arguments to find a Audit
     * @example
     * // Get one Audit
     * const audit = await prisma.audit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends auditFindFirstArgs>(args?: SelectSubset<T, auditFindFirstArgs<ExtArgs>>): Prisma__auditClient<$Result.GetResult<Prisma.$auditPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditFindFirstOrThrowArgs} args - Arguments to find a Audit
     * @example
     * // Get one Audit
     * const audit = await prisma.audit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends auditFindFirstOrThrowArgs>(args?: SelectSubset<T, auditFindFirstOrThrowArgs<ExtArgs>>): Prisma__auditClient<$Result.GetResult<Prisma.$auditPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Audits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Audits
     * const audits = await prisma.audit.findMany()
     * 
     * // Get first 10 Audits
     * const audits = await prisma.audit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditWithIdOnly = await prisma.audit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends auditFindManyArgs>(args?: SelectSubset<T, auditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Audit.
     * @param {auditCreateArgs} args - Arguments to create a Audit.
     * @example
     * // Create one Audit
     * const Audit = await prisma.audit.create({
     *   data: {
     *     // ... data to create a Audit
     *   }
     * })
     * 
     */
    create<T extends auditCreateArgs>(args: SelectSubset<T, auditCreateArgs<ExtArgs>>): Prisma__auditClient<$Result.GetResult<Prisma.$auditPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Audits.
     * @param {auditCreateManyArgs} args - Arguments to create many Audits.
     * @example
     * // Create many Audits
     * const audit = await prisma.audit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends auditCreateManyArgs>(args?: SelectSubset<T, auditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Audits and returns the data saved in the database.
     * @param {auditCreateManyAndReturnArgs} args - Arguments to create many Audits.
     * @example
     * // Create many Audits
     * const audit = await prisma.audit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Audits and only return the `id`
     * const auditWithIdOnly = await prisma.audit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends auditCreateManyAndReturnArgs>(args?: SelectSubset<T, auditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Audit.
     * @param {auditDeleteArgs} args - Arguments to delete one Audit.
     * @example
     * // Delete one Audit
     * const Audit = await prisma.audit.delete({
     *   where: {
     *     // ... filter to delete one Audit
     *   }
     * })
     * 
     */
    delete<T extends auditDeleteArgs>(args: SelectSubset<T, auditDeleteArgs<ExtArgs>>): Prisma__auditClient<$Result.GetResult<Prisma.$auditPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Audit.
     * @param {auditUpdateArgs} args - Arguments to update one Audit.
     * @example
     * // Update one Audit
     * const audit = await prisma.audit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends auditUpdateArgs>(args: SelectSubset<T, auditUpdateArgs<ExtArgs>>): Prisma__auditClient<$Result.GetResult<Prisma.$auditPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Audits.
     * @param {auditDeleteManyArgs} args - Arguments to filter Audits to delete.
     * @example
     * // Delete a few Audits
     * const { count } = await prisma.audit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends auditDeleteManyArgs>(args?: SelectSubset<T, auditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Audits
     * const audit = await prisma.audit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends auditUpdateManyArgs>(args: SelectSubset<T, auditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audits and returns the data updated in the database.
     * @param {auditUpdateManyAndReturnArgs} args - Arguments to update many Audits.
     * @example
     * // Update many Audits
     * const audit = await prisma.audit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Audits and only return the `id`
     * const auditWithIdOnly = await prisma.audit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends auditUpdateManyAndReturnArgs>(args: SelectSubset<T, auditUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Audit.
     * @param {auditUpsertArgs} args - Arguments to update or create a Audit.
     * @example
     * // Update or create a Audit
     * const audit = await prisma.audit.upsert({
     *   create: {
     *     // ... data to create a Audit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Audit we want to update
     *   }
     * })
     */
    upsert<T extends auditUpsertArgs>(args: SelectSubset<T, auditUpsertArgs<ExtArgs>>): Prisma__auditClient<$Result.GetResult<Prisma.$auditPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Audits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditCountArgs} args - Arguments to filter Audits to count.
     * @example
     * // Count the number of Audits
     * const count = await prisma.audit.count({
     *   where: {
     *     // ... the filter for the Audits we want to count
     *   }
     * })
    **/
    count<T extends auditCountArgs>(
      args?: Subset<T, auditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Audit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditAggregateArgs>(args: Subset<T, AuditAggregateArgs>): Prisma.PrismaPromise<GetAuditAggregateType<T>>

    /**
     * Group by Audit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends auditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: auditGroupByArgs['orderBy'] }
        : { orderBy?: auditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, auditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the audit model
   */
  readonly fields: auditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for audit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__auditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    winnings<T extends winningsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, winningsDefaultArgs<ExtArgs>>): Prisma__winningsClient<$Result.GetResult<Prisma.$winningsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the audit model
   */
  interface auditFieldRefs {
    readonly id: FieldRef<"audit", 'String'>
    readonly winnings_id: FieldRef<"audit", 'String'>
    readonly user_id: FieldRef<"audit", 'String'>
    readonly action: FieldRef<"audit", 'String'>
    readonly note: FieldRef<"audit", 'String'>
    readonly created_at: FieldRef<"audit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * audit findUnique
   */
  export type auditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit
     */
    select?: auditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit
     */
    omit?: auditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditInclude<ExtArgs> | null
    /**
     * Filter, which audit to fetch.
     */
    where: auditWhereUniqueInput
  }

  /**
   * audit findUniqueOrThrow
   */
  export type auditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit
     */
    select?: auditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit
     */
    omit?: auditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditInclude<ExtArgs> | null
    /**
     * Filter, which audit to fetch.
     */
    where: auditWhereUniqueInput
  }

  /**
   * audit findFirst
   */
  export type auditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit
     */
    select?: auditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit
     */
    omit?: auditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditInclude<ExtArgs> | null
    /**
     * Filter, which audit to fetch.
     */
    where?: auditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audits to fetch.
     */
    orderBy?: auditOrderByWithRelationInput | auditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audits.
     */
    cursor?: auditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audits.
     */
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * audit findFirstOrThrow
   */
  export type auditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit
     */
    select?: auditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit
     */
    omit?: auditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditInclude<ExtArgs> | null
    /**
     * Filter, which audit to fetch.
     */
    where?: auditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audits to fetch.
     */
    orderBy?: auditOrderByWithRelationInput | auditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audits.
     */
    cursor?: auditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audits.
     */
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * audit findMany
   */
  export type auditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit
     */
    select?: auditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit
     */
    omit?: auditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditInclude<ExtArgs> | null
    /**
     * Filter, which audits to fetch.
     */
    where?: auditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audits to fetch.
     */
    orderBy?: auditOrderByWithRelationInput | auditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing audits.
     */
    cursor?: auditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audits.
     */
    skip?: number
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * audit create
   */
  export type auditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit
     */
    select?: auditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit
     */
    omit?: auditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditInclude<ExtArgs> | null
    /**
     * The data needed to create a audit.
     */
    data: XOR<auditCreateInput, auditUncheckedCreateInput>
  }

  /**
   * audit createMany
   */
  export type auditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many audits.
     */
    data: auditCreateManyInput | auditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * audit createManyAndReturn
   */
  export type auditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit
     */
    select?: auditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the audit
     */
    omit?: auditOmit<ExtArgs> | null
    /**
     * The data used to create many audits.
     */
    data: auditCreateManyInput | auditCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * audit update
   */
  export type auditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit
     */
    select?: auditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit
     */
    omit?: auditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditInclude<ExtArgs> | null
    /**
     * The data needed to update a audit.
     */
    data: XOR<auditUpdateInput, auditUncheckedUpdateInput>
    /**
     * Choose, which audit to update.
     */
    where: auditWhereUniqueInput
  }

  /**
   * audit updateMany
   */
  export type auditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update audits.
     */
    data: XOR<auditUpdateManyMutationInput, auditUncheckedUpdateManyInput>
    /**
     * Filter which audits to update
     */
    where?: auditWhereInput
    /**
     * Limit how many audits to update.
     */
    limit?: number
  }

  /**
   * audit updateManyAndReturn
   */
  export type auditUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit
     */
    select?: auditSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the audit
     */
    omit?: auditOmit<ExtArgs> | null
    /**
     * The data used to update audits.
     */
    data: XOR<auditUpdateManyMutationInput, auditUncheckedUpdateManyInput>
    /**
     * Filter which audits to update
     */
    where?: auditWhereInput
    /**
     * Limit how many audits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * audit upsert
   */
  export type auditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit
     */
    select?: auditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit
     */
    omit?: auditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditInclude<ExtArgs> | null
    /**
     * The filter to search for the audit to update in case it exists.
     */
    where: auditWhereUniqueInput
    /**
     * In case the audit found by the `where` argument doesn't exist, create a new audit with this data.
     */
    create: XOR<auditCreateInput, auditUncheckedCreateInput>
    /**
     * In case the audit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auditUpdateInput, auditUncheckedUpdateInput>
  }

  /**
   * audit delete
   */
  export type auditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit
     */
    select?: auditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit
     */
    omit?: auditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditInclude<ExtArgs> | null
    /**
     * Filter which audit to delete.
     */
    where: auditWhereUniqueInput
  }

  /**
   * audit deleteMany
   */
  export type auditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which audits to delete
     */
    where?: auditWhereInput
    /**
     * Limit how many audits to delete.
     */
    limit?: number
  }

  /**
   * audit without action
   */
  export type auditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit
     */
    select?: auditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit
     */
    omit?: auditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditInclude<ExtArgs> | null
  }


  /**
   * Model origin
   */

  export type AggregateOrigin = {
    _count: OriginCountAggregateOutputType | null
    _avg: OriginAvgAggregateOutputType | null
    _sum: OriginSumAggregateOutputType | null
    _min: OriginMinAggregateOutputType | null
    _max: OriginMaxAggregateOutputType | null
  }

  export type OriginAvgAggregateOutputType = {
    origin_id: number | null
  }

  export type OriginSumAggregateOutputType = {
    origin_id: number | null
  }

  export type OriginMinAggregateOutputType = {
    origin_id: number | null
    origin_name: string | null
  }

  export type OriginMaxAggregateOutputType = {
    origin_id: number | null
    origin_name: string | null
  }

  export type OriginCountAggregateOutputType = {
    origin_id: number
    origin_name: number
    _all: number
  }


  export type OriginAvgAggregateInputType = {
    origin_id?: true
  }

  export type OriginSumAggregateInputType = {
    origin_id?: true
  }

  export type OriginMinAggregateInputType = {
    origin_id?: true
    origin_name?: true
  }

  export type OriginMaxAggregateInputType = {
    origin_id?: true
    origin_name?: true
  }

  export type OriginCountAggregateInputType = {
    origin_id?: true
    origin_name?: true
    _all?: true
  }

  export type OriginAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which origin to aggregate.
     */
    where?: originWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of origins to fetch.
     */
    orderBy?: originOrderByWithRelationInput | originOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: originWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` origins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` origins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned origins
    **/
    _count?: true | OriginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OriginAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OriginSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OriginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OriginMaxAggregateInputType
  }

  export type GetOriginAggregateType<T extends OriginAggregateArgs> = {
        [P in keyof T & keyof AggregateOrigin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrigin[P]>
      : GetScalarType<T[P], AggregateOrigin[P]>
  }




  export type originGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: originWhereInput
    orderBy?: originOrderByWithAggregationInput | originOrderByWithAggregationInput[]
    by: OriginScalarFieldEnum[] | OriginScalarFieldEnum
    having?: originScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OriginCountAggregateInputType | true
    _avg?: OriginAvgAggregateInputType
    _sum?: OriginSumAggregateInputType
    _min?: OriginMinAggregateInputType
    _max?: OriginMaxAggregateInputType
  }

  export type OriginGroupByOutputType = {
    origin_id: number
    origin_name: string
    _count: OriginCountAggregateOutputType | null
    _avg: OriginAvgAggregateOutputType | null
    _sum: OriginSumAggregateOutputType | null
    _min: OriginMinAggregateOutputType | null
    _max: OriginMaxAggregateOutputType | null
  }

  type GetOriginGroupByPayload<T extends originGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OriginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OriginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OriginGroupByOutputType[P]>
            : GetScalarType<T[P], OriginGroupByOutputType[P]>
        }
      >
    >


  export type originSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    origin_id?: boolean
    origin_name?: boolean
    winnings?: boolean | origin$winningsArgs<ExtArgs>
    _count?: boolean | OriginCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["origin"]>

  export type originSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    origin_id?: boolean
    origin_name?: boolean
  }, ExtArgs["result"]["origin"]>

  export type originSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    origin_id?: boolean
    origin_name?: boolean
  }, ExtArgs["result"]["origin"]>

  export type originSelectScalar = {
    origin_id?: boolean
    origin_name?: boolean
  }

  export type originOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"origin_id" | "origin_name", ExtArgs["result"]["origin"]>
  export type originInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    winnings?: boolean | origin$winningsArgs<ExtArgs>
    _count?: boolean | OriginCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type originIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type originIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $originPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "origin"
    objects: {
      winnings: Prisma.$winningsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      origin_id: number
      origin_name: string
    }, ExtArgs["result"]["origin"]>
    composites: {}
  }

  type originGetPayload<S extends boolean | null | undefined | originDefaultArgs> = $Result.GetResult<Prisma.$originPayload, S>

  type originCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<originFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OriginCountAggregateInputType | true
    }

  export interface originDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['origin'], meta: { name: 'origin' } }
    /**
     * Find zero or one Origin that matches the filter.
     * @param {originFindUniqueArgs} args - Arguments to find a Origin
     * @example
     * // Get one Origin
     * const origin = await prisma.origin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends originFindUniqueArgs>(args: SelectSubset<T, originFindUniqueArgs<ExtArgs>>): Prisma__originClient<$Result.GetResult<Prisma.$originPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Origin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {originFindUniqueOrThrowArgs} args - Arguments to find a Origin
     * @example
     * // Get one Origin
     * const origin = await prisma.origin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends originFindUniqueOrThrowArgs>(args: SelectSubset<T, originFindUniqueOrThrowArgs<ExtArgs>>): Prisma__originClient<$Result.GetResult<Prisma.$originPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Origin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {originFindFirstArgs} args - Arguments to find a Origin
     * @example
     * // Get one Origin
     * const origin = await prisma.origin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends originFindFirstArgs>(args?: SelectSubset<T, originFindFirstArgs<ExtArgs>>): Prisma__originClient<$Result.GetResult<Prisma.$originPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Origin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {originFindFirstOrThrowArgs} args - Arguments to find a Origin
     * @example
     * // Get one Origin
     * const origin = await prisma.origin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends originFindFirstOrThrowArgs>(args?: SelectSubset<T, originFindFirstOrThrowArgs<ExtArgs>>): Prisma__originClient<$Result.GetResult<Prisma.$originPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Origins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {originFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Origins
     * const origins = await prisma.origin.findMany()
     * 
     * // Get first 10 Origins
     * const origins = await prisma.origin.findMany({ take: 10 })
     * 
     * // Only select the `origin_id`
     * const originWithOrigin_idOnly = await prisma.origin.findMany({ select: { origin_id: true } })
     * 
     */
    findMany<T extends originFindManyArgs>(args?: SelectSubset<T, originFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$originPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Origin.
     * @param {originCreateArgs} args - Arguments to create a Origin.
     * @example
     * // Create one Origin
     * const Origin = await prisma.origin.create({
     *   data: {
     *     // ... data to create a Origin
     *   }
     * })
     * 
     */
    create<T extends originCreateArgs>(args: SelectSubset<T, originCreateArgs<ExtArgs>>): Prisma__originClient<$Result.GetResult<Prisma.$originPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Origins.
     * @param {originCreateManyArgs} args - Arguments to create many Origins.
     * @example
     * // Create many Origins
     * const origin = await prisma.origin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends originCreateManyArgs>(args?: SelectSubset<T, originCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Origins and returns the data saved in the database.
     * @param {originCreateManyAndReturnArgs} args - Arguments to create many Origins.
     * @example
     * // Create many Origins
     * const origin = await prisma.origin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Origins and only return the `origin_id`
     * const originWithOrigin_idOnly = await prisma.origin.createManyAndReturn({
     *   select: { origin_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends originCreateManyAndReturnArgs>(args?: SelectSubset<T, originCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$originPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Origin.
     * @param {originDeleteArgs} args - Arguments to delete one Origin.
     * @example
     * // Delete one Origin
     * const Origin = await prisma.origin.delete({
     *   where: {
     *     // ... filter to delete one Origin
     *   }
     * })
     * 
     */
    delete<T extends originDeleteArgs>(args: SelectSubset<T, originDeleteArgs<ExtArgs>>): Prisma__originClient<$Result.GetResult<Prisma.$originPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Origin.
     * @param {originUpdateArgs} args - Arguments to update one Origin.
     * @example
     * // Update one Origin
     * const origin = await prisma.origin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends originUpdateArgs>(args: SelectSubset<T, originUpdateArgs<ExtArgs>>): Prisma__originClient<$Result.GetResult<Prisma.$originPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Origins.
     * @param {originDeleteManyArgs} args - Arguments to filter Origins to delete.
     * @example
     * // Delete a few Origins
     * const { count } = await prisma.origin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends originDeleteManyArgs>(args?: SelectSubset<T, originDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Origins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {originUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Origins
     * const origin = await prisma.origin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends originUpdateManyArgs>(args: SelectSubset<T, originUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Origins and returns the data updated in the database.
     * @param {originUpdateManyAndReturnArgs} args - Arguments to update many Origins.
     * @example
     * // Update many Origins
     * const origin = await prisma.origin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Origins and only return the `origin_id`
     * const originWithOrigin_idOnly = await prisma.origin.updateManyAndReturn({
     *   select: { origin_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends originUpdateManyAndReturnArgs>(args: SelectSubset<T, originUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$originPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Origin.
     * @param {originUpsertArgs} args - Arguments to update or create a Origin.
     * @example
     * // Update or create a Origin
     * const origin = await prisma.origin.upsert({
     *   create: {
     *     // ... data to create a Origin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Origin we want to update
     *   }
     * })
     */
    upsert<T extends originUpsertArgs>(args: SelectSubset<T, originUpsertArgs<ExtArgs>>): Prisma__originClient<$Result.GetResult<Prisma.$originPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Origins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {originCountArgs} args - Arguments to filter Origins to count.
     * @example
     * // Count the number of Origins
     * const count = await prisma.origin.count({
     *   where: {
     *     // ... the filter for the Origins we want to count
     *   }
     * })
    **/
    count<T extends originCountArgs>(
      args?: Subset<T, originCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OriginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Origin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OriginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OriginAggregateArgs>(args: Subset<T, OriginAggregateArgs>): Prisma.PrismaPromise<GetOriginAggregateType<T>>

    /**
     * Group by Origin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {originGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends originGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: originGroupByArgs['orderBy'] }
        : { orderBy?: originGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, originGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOriginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the origin model
   */
  readonly fields: originFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for origin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__originClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    winnings<T extends origin$winningsArgs<ExtArgs> = {}>(args?: Subset<T, origin$winningsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$winningsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the origin model
   */
  interface originFieldRefs {
    readonly origin_id: FieldRef<"origin", 'Int'>
    readonly origin_name: FieldRef<"origin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * origin findUnique
   */
  export type originFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the origin
     */
    select?: originSelect<ExtArgs> | null
    /**
     * Omit specific fields from the origin
     */
    omit?: originOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: originInclude<ExtArgs> | null
    /**
     * Filter, which origin to fetch.
     */
    where: originWhereUniqueInput
  }

  /**
   * origin findUniqueOrThrow
   */
  export type originFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the origin
     */
    select?: originSelect<ExtArgs> | null
    /**
     * Omit specific fields from the origin
     */
    omit?: originOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: originInclude<ExtArgs> | null
    /**
     * Filter, which origin to fetch.
     */
    where: originWhereUniqueInput
  }

  /**
   * origin findFirst
   */
  export type originFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the origin
     */
    select?: originSelect<ExtArgs> | null
    /**
     * Omit specific fields from the origin
     */
    omit?: originOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: originInclude<ExtArgs> | null
    /**
     * Filter, which origin to fetch.
     */
    where?: originWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of origins to fetch.
     */
    orderBy?: originOrderByWithRelationInput | originOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for origins.
     */
    cursor?: originWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` origins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` origins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of origins.
     */
    distinct?: OriginScalarFieldEnum | OriginScalarFieldEnum[]
  }

  /**
   * origin findFirstOrThrow
   */
  export type originFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the origin
     */
    select?: originSelect<ExtArgs> | null
    /**
     * Omit specific fields from the origin
     */
    omit?: originOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: originInclude<ExtArgs> | null
    /**
     * Filter, which origin to fetch.
     */
    where?: originWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of origins to fetch.
     */
    orderBy?: originOrderByWithRelationInput | originOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for origins.
     */
    cursor?: originWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` origins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` origins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of origins.
     */
    distinct?: OriginScalarFieldEnum | OriginScalarFieldEnum[]
  }

  /**
   * origin findMany
   */
  export type originFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the origin
     */
    select?: originSelect<ExtArgs> | null
    /**
     * Omit specific fields from the origin
     */
    omit?: originOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: originInclude<ExtArgs> | null
    /**
     * Filter, which origins to fetch.
     */
    where?: originWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of origins to fetch.
     */
    orderBy?: originOrderByWithRelationInput | originOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing origins.
     */
    cursor?: originWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` origins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` origins.
     */
    skip?: number
    distinct?: OriginScalarFieldEnum | OriginScalarFieldEnum[]
  }

  /**
   * origin create
   */
  export type originCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the origin
     */
    select?: originSelect<ExtArgs> | null
    /**
     * Omit specific fields from the origin
     */
    omit?: originOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: originInclude<ExtArgs> | null
    /**
     * The data needed to create a origin.
     */
    data: XOR<originCreateInput, originUncheckedCreateInput>
  }

  /**
   * origin createMany
   */
  export type originCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many origins.
     */
    data: originCreateManyInput | originCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * origin createManyAndReturn
   */
  export type originCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the origin
     */
    select?: originSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the origin
     */
    omit?: originOmit<ExtArgs> | null
    /**
     * The data used to create many origins.
     */
    data: originCreateManyInput | originCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * origin update
   */
  export type originUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the origin
     */
    select?: originSelect<ExtArgs> | null
    /**
     * Omit specific fields from the origin
     */
    omit?: originOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: originInclude<ExtArgs> | null
    /**
     * The data needed to update a origin.
     */
    data: XOR<originUpdateInput, originUncheckedUpdateInput>
    /**
     * Choose, which origin to update.
     */
    where: originWhereUniqueInput
  }

  /**
   * origin updateMany
   */
  export type originUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update origins.
     */
    data: XOR<originUpdateManyMutationInput, originUncheckedUpdateManyInput>
    /**
     * Filter which origins to update
     */
    where?: originWhereInput
    /**
     * Limit how many origins to update.
     */
    limit?: number
  }

  /**
   * origin updateManyAndReturn
   */
  export type originUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the origin
     */
    select?: originSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the origin
     */
    omit?: originOmit<ExtArgs> | null
    /**
     * The data used to update origins.
     */
    data: XOR<originUpdateManyMutationInput, originUncheckedUpdateManyInput>
    /**
     * Filter which origins to update
     */
    where?: originWhereInput
    /**
     * Limit how many origins to update.
     */
    limit?: number
  }

  /**
   * origin upsert
   */
  export type originUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the origin
     */
    select?: originSelect<ExtArgs> | null
    /**
     * Omit specific fields from the origin
     */
    omit?: originOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: originInclude<ExtArgs> | null
    /**
     * The filter to search for the origin to update in case it exists.
     */
    where: originWhereUniqueInput
    /**
     * In case the origin found by the `where` argument doesn't exist, create a new origin with this data.
     */
    create: XOR<originCreateInput, originUncheckedCreateInput>
    /**
     * In case the origin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<originUpdateInput, originUncheckedUpdateInput>
  }

  /**
   * origin delete
   */
  export type originDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the origin
     */
    select?: originSelect<ExtArgs> | null
    /**
     * Omit specific fields from the origin
     */
    omit?: originOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: originInclude<ExtArgs> | null
    /**
     * Filter which origin to delete.
     */
    where: originWhereUniqueInput
  }

  /**
   * origin deleteMany
   */
  export type originDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which origins to delete
     */
    where?: originWhereInput
    /**
     * Limit how many origins to delete.
     */
    limit?: number
  }

  /**
   * origin.winnings
   */
  export type origin$winningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the winnings
     */
    select?: winningsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the winnings
     */
    omit?: winningsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: winningsInclude<ExtArgs> | null
    where?: winningsWhereInput
    orderBy?: winningsOrderByWithRelationInput | winningsOrderByWithRelationInput[]
    cursor?: winningsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WinningsScalarFieldEnum | WinningsScalarFieldEnum[]
  }

  /**
   * origin without action
   */
  export type originDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the origin
     */
    select?: originSelect<ExtArgs> | null
    /**
     * Omit specific fields from the origin
     */
    omit?: originOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: originInclude<ExtArgs> | null
  }


  /**
   * Model otp
   */

  export type AggregateOtp = {
    _count: OtpCountAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  export type OtpMinAggregateOutputType = {
    id: string | null
    email: string | null
    otp_hash: string | null
    expiration_time: Date | null
    action_type: $Enums.reference_type | null
    created_at: Date | null
    updated_at: Date | null
    verified_at: Date | null
  }

  export type OtpMaxAggregateOutputType = {
    id: string | null
    email: string | null
    otp_hash: string | null
    expiration_time: Date | null
    action_type: $Enums.reference_type | null
    created_at: Date | null
    updated_at: Date | null
    verified_at: Date | null
  }

  export type OtpCountAggregateOutputType = {
    id: number
    email: number
    otp_hash: number
    expiration_time: number
    action_type: number
    created_at: number
    updated_at: number
    verified_at: number
    _all: number
  }


  export type OtpMinAggregateInputType = {
    id?: true
    email?: true
    otp_hash?: true
    expiration_time?: true
    action_type?: true
    created_at?: true
    updated_at?: true
    verified_at?: true
  }

  export type OtpMaxAggregateInputType = {
    id?: true
    email?: true
    otp_hash?: true
    expiration_time?: true
    action_type?: true
    created_at?: true
    updated_at?: true
    verified_at?: true
  }

  export type OtpCountAggregateInputType = {
    id?: true
    email?: true
    otp_hash?: true
    expiration_time?: true
    action_type?: true
    created_at?: true
    updated_at?: true
    verified_at?: true
    _all?: true
  }

  export type OtpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which otp to aggregate.
     */
    where?: otpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otps to fetch.
     */
    orderBy?: otpOrderByWithRelationInput | otpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: otpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned otps
    **/
    _count?: true | OtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpMaxAggregateInputType
  }

  export type GetOtpAggregateType<T extends OtpAggregateArgs> = {
        [P in keyof T & keyof AggregateOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtp[P]>
      : GetScalarType<T[P], AggregateOtp[P]>
  }




  export type otpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: otpWhereInput
    orderBy?: otpOrderByWithAggregationInput | otpOrderByWithAggregationInput[]
    by: OtpScalarFieldEnum[] | OtpScalarFieldEnum
    having?: otpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpCountAggregateInputType | true
    _min?: OtpMinAggregateInputType
    _max?: OtpMaxAggregateInputType
  }

  export type OtpGroupByOutputType = {
    id: string
    email: string
    otp_hash: string
    expiration_time: Date
    action_type: $Enums.reference_type
    created_at: Date | null
    updated_at: Date | null
    verified_at: Date | null
    _count: OtpCountAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  type GetOtpGroupByPayload<T extends otpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpGroupByOutputType[P]>
            : GetScalarType<T[P], OtpGroupByOutputType[P]>
        }
      >
    >


  export type otpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp_hash?: boolean
    expiration_time?: boolean
    action_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    verified_at?: boolean
  }, ExtArgs["result"]["otp"]>

  export type otpSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp_hash?: boolean
    expiration_time?: boolean
    action_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    verified_at?: boolean
  }, ExtArgs["result"]["otp"]>

  export type otpSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp_hash?: boolean
    expiration_time?: boolean
    action_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    verified_at?: boolean
  }, ExtArgs["result"]["otp"]>

  export type otpSelectScalar = {
    id?: boolean
    email?: boolean
    otp_hash?: boolean
    expiration_time?: boolean
    action_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    verified_at?: boolean
  }

  export type otpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "otp_hash" | "expiration_time" | "action_type" | "created_at" | "updated_at" | "verified_at", ExtArgs["result"]["otp"]>

  export type $otpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "otp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      otp_hash: string
      expiration_time: Date
      action_type: $Enums.reference_type
      created_at: Date | null
      updated_at: Date | null
      verified_at: Date | null
    }, ExtArgs["result"]["otp"]>
    composites: {}
  }

  type otpGetPayload<S extends boolean | null | undefined | otpDefaultArgs> = $Result.GetResult<Prisma.$otpPayload, S>

  type otpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<otpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OtpCountAggregateInputType | true
    }

  export interface otpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['otp'], meta: { name: 'otp' } }
    /**
     * Find zero or one Otp that matches the filter.
     * @param {otpFindUniqueArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends otpFindUniqueArgs>(args: SelectSubset<T, otpFindUniqueArgs<ExtArgs>>): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Otp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {otpFindUniqueOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends otpFindUniqueOrThrowArgs>(args: SelectSubset<T, otpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpFindFirstArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends otpFindFirstArgs>(args?: SelectSubset<T, otpFindFirstArgs<ExtArgs>>): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpFindFirstOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends otpFindFirstOrThrowArgs>(args?: SelectSubset<T, otpFindFirstOrThrowArgs<ExtArgs>>): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Otps
     * const otps = await prisma.otp.findMany()
     * 
     * // Get first 10 Otps
     * const otps = await prisma.otp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otpWithIdOnly = await prisma.otp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends otpFindManyArgs>(args?: SelectSubset<T, otpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Otp.
     * @param {otpCreateArgs} args - Arguments to create a Otp.
     * @example
     * // Create one Otp
     * const Otp = await prisma.otp.create({
     *   data: {
     *     // ... data to create a Otp
     *   }
     * })
     * 
     */
    create<T extends otpCreateArgs>(args: SelectSubset<T, otpCreateArgs<ExtArgs>>): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Otps.
     * @param {otpCreateManyArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otp = await prisma.otp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends otpCreateManyArgs>(args?: SelectSubset<T, otpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Otps and returns the data saved in the database.
     * @param {otpCreateManyAndReturnArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otp = await prisma.otp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Otps and only return the `id`
     * const otpWithIdOnly = await prisma.otp.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends otpCreateManyAndReturnArgs>(args?: SelectSubset<T, otpCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Otp.
     * @param {otpDeleteArgs} args - Arguments to delete one Otp.
     * @example
     * // Delete one Otp
     * const Otp = await prisma.otp.delete({
     *   where: {
     *     // ... filter to delete one Otp
     *   }
     * })
     * 
     */
    delete<T extends otpDeleteArgs>(args: SelectSubset<T, otpDeleteArgs<ExtArgs>>): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Otp.
     * @param {otpUpdateArgs} args - Arguments to update one Otp.
     * @example
     * // Update one Otp
     * const otp = await prisma.otp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends otpUpdateArgs>(args: SelectSubset<T, otpUpdateArgs<ExtArgs>>): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Otps.
     * @param {otpDeleteManyArgs} args - Arguments to filter Otps to delete.
     * @example
     * // Delete a few Otps
     * const { count } = await prisma.otp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends otpDeleteManyArgs>(args?: SelectSubset<T, otpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends otpUpdateManyArgs>(args: SelectSubset<T, otpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps and returns the data updated in the database.
     * @param {otpUpdateManyAndReturnArgs} args - Arguments to update many Otps.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Otps and only return the `id`
     * const otpWithIdOnly = await prisma.otp.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends otpUpdateManyAndReturnArgs>(args: SelectSubset<T, otpUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Otp.
     * @param {otpUpsertArgs} args - Arguments to update or create a Otp.
     * @example
     * // Update or create a Otp
     * const otp = await prisma.otp.upsert({
     *   create: {
     *     // ... data to create a Otp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Otp we want to update
     *   }
     * })
     */
    upsert<T extends otpUpsertArgs>(args: SelectSubset<T, otpUpsertArgs<ExtArgs>>): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpCountArgs} args - Arguments to filter Otps to count.
     * @example
     * // Count the number of Otps
     * const count = await prisma.otp.count({
     *   where: {
     *     // ... the filter for the Otps we want to count
     *   }
     * })
    **/
    count<T extends otpCountArgs>(
      args?: Subset<T, otpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpAggregateArgs>(args: Subset<T, OtpAggregateArgs>): Prisma.PrismaPromise<GetOtpAggregateType<T>>

    /**
     * Group by Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends otpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: otpGroupByArgs['orderBy'] }
        : { orderBy?: otpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, otpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the otp model
   */
  readonly fields: otpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for otp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__otpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the otp model
   */
  interface otpFieldRefs {
    readonly id: FieldRef<"otp", 'String'>
    readonly email: FieldRef<"otp", 'String'>
    readonly otp_hash: FieldRef<"otp", 'String'>
    readonly expiration_time: FieldRef<"otp", 'DateTime'>
    readonly action_type: FieldRef<"otp", 'reference_type'>
    readonly created_at: FieldRef<"otp", 'DateTime'>
    readonly updated_at: FieldRef<"otp", 'DateTime'>
    readonly verified_at: FieldRef<"otp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * otp findUnique
   */
  export type otpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otp
     */
    omit?: otpOmit<ExtArgs> | null
    /**
     * Filter, which otp to fetch.
     */
    where: otpWhereUniqueInput
  }

  /**
   * otp findUniqueOrThrow
   */
  export type otpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otp
     */
    omit?: otpOmit<ExtArgs> | null
    /**
     * Filter, which otp to fetch.
     */
    where: otpWhereUniqueInput
  }

  /**
   * otp findFirst
   */
  export type otpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otp
     */
    omit?: otpOmit<ExtArgs> | null
    /**
     * Filter, which otp to fetch.
     */
    where?: otpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otps to fetch.
     */
    orderBy?: otpOrderByWithRelationInput | otpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for otps.
     */
    cursor?: otpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * otp findFirstOrThrow
   */
  export type otpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otp
     */
    omit?: otpOmit<ExtArgs> | null
    /**
     * Filter, which otp to fetch.
     */
    where?: otpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otps to fetch.
     */
    orderBy?: otpOrderByWithRelationInput | otpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for otps.
     */
    cursor?: otpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * otp findMany
   */
  export type otpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otp
     */
    omit?: otpOmit<ExtArgs> | null
    /**
     * Filter, which otps to fetch.
     */
    where?: otpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otps to fetch.
     */
    orderBy?: otpOrderByWithRelationInput | otpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing otps.
     */
    cursor?: otpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otps.
     */
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * otp create
   */
  export type otpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otp
     */
    omit?: otpOmit<ExtArgs> | null
    /**
     * The data needed to create a otp.
     */
    data: XOR<otpCreateInput, otpUncheckedCreateInput>
  }

  /**
   * otp createMany
   */
  export type otpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many otps.
     */
    data: otpCreateManyInput | otpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * otp createManyAndReturn
   */
  export type otpCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the otp
     */
    omit?: otpOmit<ExtArgs> | null
    /**
     * The data used to create many otps.
     */
    data: otpCreateManyInput | otpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * otp update
   */
  export type otpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otp
     */
    omit?: otpOmit<ExtArgs> | null
    /**
     * The data needed to update a otp.
     */
    data: XOR<otpUpdateInput, otpUncheckedUpdateInput>
    /**
     * Choose, which otp to update.
     */
    where: otpWhereUniqueInput
  }

  /**
   * otp updateMany
   */
  export type otpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update otps.
     */
    data: XOR<otpUpdateManyMutationInput, otpUncheckedUpdateManyInput>
    /**
     * Filter which otps to update
     */
    where?: otpWhereInput
    /**
     * Limit how many otps to update.
     */
    limit?: number
  }

  /**
   * otp updateManyAndReturn
   */
  export type otpUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the otp
     */
    omit?: otpOmit<ExtArgs> | null
    /**
     * The data used to update otps.
     */
    data: XOR<otpUpdateManyMutationInput, otpUncheckedUpdateManyInput>
    /**
     * Filter which otps to update
     */
    where?: otpWhereInput
    /**
     * Limit how many otps to update.
     */
    limit?: number
  }

  /**
   * otp upsert
   */
  export type otpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otp
     */
    omit?: otpOmit<ExtArgs> | null
    /**
     * The filter to search for the otp to update in case it exists.
     */
    where: otpWhereUniqueInput
    /**
     * In case the otp found by the `where` argument doesn't exist, create a new otp with this data.
     */
    create: XOR<otpCreateInput, otpUncheckedCreateInput>
    /**
     * In case the otp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<otpUpdateInput, otpUncheckedUpdateInput>
  }

  /**
   * otp delete
   */
  export type otpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otp
     */
    omit?: otpOmit<ExtArgs> | null
    /**
     * Filter which otp to delete.
     */
    where: otpWhereUniqueInput
  }

  /**
   * otp deleteMany
   */
  export type otpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which otps to delete
     */
    where?: otpWhereInput
    /**
     * Limit how many otps to delete.
     */
    limit?: number
  }

  /**
   * otp without action
   */
  export type otpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otp
     */
    omit?: otpOmit<ExtArgs> | null
  }


  /**
   * Model payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    net_amount: Decimal | null
    gross_amount: Decimal | null
    total_amount: Decimal | null
    installment_number: number | null
    payment_method_id: number | null
    version: number | null
    challenge_markup: Decimal | null
    challenge_fee: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    net_amount: Decimal | null
    gross_amount: Decimal | null
    total_amount: Decimal | null
    installment_number: number | null
    payment_method_id: number | null
    version: number | null
    challenge_markup: Decimal | null
    challenge_fee: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    payment_id: string | null
    winnings_id: string | null
    net_amount: Decimal | null
    gross_amount: Decimal | null
    total_amount: Decimal | null
    installment_number: number | null
    date_paid: Date | null
    payment_method_id: number | null
    currency: string | null
    created_by: string | null
    updated_by: string | null
    created_at: Date | null
    updated_at: Date | null
    version: number | null
    release_date: Date | null
    payment_status: $Enums.payment_status | null
    billing_account: string | null
    challenge_markup: Decimal | null
    challenge_fee: Decimal | null
  }

  export type PaymentMaxAggregateOutputType = {
    payment_id: string | null
    winnings_id: string | null
    net_amount: Decimal | null
    gross_amount: Decimal | null
    total_amount: Decimal | null
    installment_number: number | null
    date_paid: Date | null
    payment_method_id: number | null
    currency: string | null
    created_by: string | null
    updated_by: string | null
    created_at: Date | null
    updated_at: Date | null
    version: number | null
    release_date: Date | null
    payment_status: $Enums.payment_status | null
    billing_account: string | null
    challenge_markup: Decimal | null
    challenge_fee: Decimal | null
  }

  export type PaymentCountAggregateOutputType = {
    payment_id: number
    winnings_id: number
    net_amount: number
    gross_amount: number
    total_amount: number
    installment_number: number
    date_paid: number
    payment_method_id: number
    currency: number
    created_by: number
    updated_by: number
    created_at: number
    updated_at: number
    version: number
    release_date: number
    payment_status: number
    billing_account: number
    challenge_markup: number
    challenge_fee: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    net_amount?: true
    gross_amount?: true
    total_amount?: true
    installment_number?: true
    payment_method_id?: true
    version?: true
    challenge_markup?: true
    challenge_fee?: true
  }

  export type PaymentSumAggregateInputType = {
    net_amount?: true
    gross_amount?: true
    total_amount?: true
    installment_number?: true
    payment_method_id?: true
    version?: true
    challenge_markup?: true
    challenge_fee?: true
  }

  export type PaymentMinAggregateInputType = {
    payment_id?: true
    winnings_id?: true
    net_amount?: true
    gross_amount?: true
    total_amount?: true
    installment_number?: true
    date_paid?: true
    payment_method_id?: true
    currency?: true
    created_by?: true
    updated_by?: true
    created_at?: true
    updated_at?: true
    version?: true
    release_date?: true
    payment_status?: true
    billing_account?: true
    challenge_markup?: true
    challenge_fee?: true
  }

  export type PaymentMaxAggregateInputType = {
    payment_id?: true
    winnings_id?: true
    net_amount?: true
    gross_amount?: true
    total_amount?: true
    installment_number?: true
    date_paid?: true
    payment_method_id?: true
    currency?: true
    created_by?: true
    updated_by?: true
    created_at?: true
    updated_at?: true
    version?: true
    release_date?: true
    payment_status?: true
    billing_account?: true
    challenge_markup?: true
    challenge_fee?: true
  }

  export type PaymentCountAggregateInputType = {
    payment_id?: true
    winnings_id?: true
    net_amount?: true
    gross_amount?: true
    total_amount?: true
    installment_number?: true
    date_paid?: true
    payment_method_id?: true
    currency?: true
    created_by?: true
    updated_by?: true
    created_at?: true
    updated_at?: true
    version?: true
    release_date?: true
    payment_status?: true
    billing_account?: true
    challenge_markup?: true
    challenge_fee?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment to aggregate.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type paymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentWhereInput
    orderBy?: paymentOrderByWithAggregationInput | paymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: paymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    payment_id: string
    winnings_id: string
    net_amount: Decimal | null
    gross_amount: Decimal | null
    total_amount: Decimal | null
    installment_number: number | null
    date_paid: Date | null
    payment_method_id: number | null
    currency: string | null
    created_by: string
    updated_by: string | null
    created_at: Date | null
    updated_at: Date | null
    version: number | null
    release_date: Date | null
    payment_status: $Enums.payment_status | null
    billing_account: string
    challenge_markup: Decimal | null
    challenge_fee: Decimal | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends paymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type paymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_id?: boolean
    winnings_id?: boolean
    net_amount?: boolean
    gross_amount?: boolean
    total_amount?: boolean
    installment_number?: boolean
    date_paid?: boolean
    payment_method_id?: boolean
    currency?: boolean
    created_by?: boolean
    updated_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    version?: boolean
    release_date?: boolean
    payment_status?: boolean
    billing_account?: boolean
    challenge_markup?: boolean
    challenge_fee?: boolean
    payment_method?: boolean | payment$payment_methodArgs<ExtArgs>
    winnings?: boolean | winningsDefaultArgs<ExtArgs>
    payment_release_associations?: boolean | payment$payment_release_associationsArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type paymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_id?: boolean
    winnings_id?: boolean
    net_amount?: boolean
    gross_amount?: boolean
    total_amount?: boolean
    installment_number?: boolean
    date_paid?: boolean
    payment_method_id?: boolean
    currency?: boolean
    created_by?: boolean
    updated_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    version?: boolean
    release_date?: boolean
    payment_status?: boolean
    billing_account?: boolean
    challenge_markup?: boolean
    challenge_fee?: boolean
    payment_method?: boolean | payment$payment_methodArgs<ExtArgs>
    winnings?: boolean | winningsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type paymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_id?: boolean
    winnings_id?: boolean
    net_amount?: boolean
    gross_amount?: boolean
    total_amount?: boolean
    installment_number?: boolean
    date_paid?: boolean
    payment_method_id?: boolean
    currency?: boolean
    created_by?: boolean
    updated_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    version?: boolean
    release_date?: boolean
    payment_status?: boolean
    billing_account?: boolean
    challenge_markup?: boolean
    challenge_fee?: boolean
    payment_method?: boolean | payment$payment_methodArgs<ExtArgs>
    winnings?: boolean | winningsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type paymentSelectScalar = {
    payment_id?: boolean
    winnings_id?: boolean
    net_amount?: boolean
    gross_amount?: boolean
    total_amount?: boolean
    installment_number?: boolean
    date_paid?: boolean
    payment_method_id?: boolean
    currency?: boolean
    created_by?: boolean
    updated_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    version?: boolean
    release_date?: boolean
    payment_status?: boolean
    billing_account?: boolean
    challenge_markup?: boolean
    challenge_fee?: boolean
  }

  export type paymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"payment_id" | "winnings_id" | "net_amount" | "gross_amount" | "total_amount" | "installment_number" | "date_paid" | "payment_method_id" | "currency" | "created_by" | "updated_by" | "created_at" | "updated_at" | "version" | "release_date" | "payment_status" | "billing_account" | "challenge_markup" | "challenge_fee", ExtArgs["result"]["payment"]>
  export type paymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_method?: boolean | payment$payment_methodArgs<ExtArgs>
    winnings?: boolean | winningsDefaultArgs<ExtArgs>
    payment_release_associations?: boolean | payment$payment_release_associationsArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type paymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_method?: boolean | payment$payment_methodArgs<ExtArgs>
    winnings?: boolean | winningsDefaultArgs<ExtArgs>
  }
  export type paymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_method?: boolean | payment$payment_methodArgs<ExtArgs>
    winnings?: boolean | winningsDefaultArgs<ExtArgs>
  }

  export type $paymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment"
    objects: {
      payment_method: Prisma.$payment_methodPayload<ExtArgs> | null
      winnings: Prisma.$winningsPayload<ExtArgs>
      payment_release_associations: Prisma.$payment_release_associationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      payment_id: string
      winnings_id: string
      net_amount: Prisma.Decimal | null
      gross_amount: Prisma.Decimal | null
      total_amount: Prisma.Decimal | null
      installment_number: number | null
      date_paid: Date | null
      payment_method_id: number | null
      currency: string | null
      created_by: string
      updated_by: string | null
      created_at: Date | null
      updated_at: Date | null
      version: number | null
      release_date: Date | null
      payment_status: $Enums.payment_status | null
      billing_account: string
      challenge_markup: Prisma.Decimal | null
      challenge_fee: Prisma.Decimal | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type paymentGetPayload<S extends boolean | null | undefined | paymentDefaultArgs> = $Result.GetResult<Prisma.$paymentPayload, S>

  type paymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface paymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment'], meta: { name: 'payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {paymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentFindUniqueArgs>(args: SelectSubset<T, paymentFindUniqueArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentFindFirstArgs>(args?: SelectSubset<T, paymentFindFirstArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `payment_id`
     * const paymentWithPayment_idOnly = await prisma.payment.findMany({ select: { payment_id: true } })
     * 
     */
    findMany<T extends paymentFindManyArgs>(args?: SelectSubset<T, paymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {paymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends paymentCreateArgs>(args: SelectSubset<T, paymentCreateArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {paymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentCreateManyArgs>(args?: SelectSubset<T, paymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {paymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `payment_id`
     * const paymentWithPayment_idOnly = await prisma.payment.createManyAndReturn({
     *   select: { payment_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paymentCreateManyAndReturnArgs>(args?: SelectSubset<T, paymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {paymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends paymentDeleteArgs>(args: SelectSubset<T, paymentDeleteArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {paymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentUpdateArgs>(args: SelectSubset<T, paymentUpdateArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {paymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentDeleteManyArgs>(args?: SelectSubset<T, paymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentUpdateManyArgs>(args: SelectSubset<T, paymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {paymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `payment_id`
     * const paymentWithPayment_idOnly = await prisma.payment.updateManyAndReturn({
     *   select: { payment_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends paymentUpdateManyAndReturnArgs>(args: SelectSubset<T, paymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {paymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends paymentUpsertArgs>(args: SelectSubset<T, paymentUpsertArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentCountArgs>(
      args?: Subset<T, paymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentGroupByArgs['orderBy'] }
        : { orderBy?: paymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment model
   */
  readonly fields: paymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment_method<T extends payment$payment_methodArgs<ExtArgs> = {}>(args?: Subset<T, payment$payment_methodArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    winnings<T extends winningsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, winningsDefaultArgs<ExtArgs>>): Prisma__winningsClient<$Result.GetResult<Prisma.$winningsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payment_release_associations<T extends payment$payment_release_associationsArgs<ExtArgs> = {}>(args?: Subset<T, payment$payment_release_associationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_release_associationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment model
   */
  interface paymentFieldRefs {
    readonly payment_id: FieldRef<"payment", 'String'>
    readonly winnings_id: FieldRef<"payment", 'String'>
    readonly net_amount: FieldRef<"payment", 'Decimal'>
    readonly gross_amount: FieldRef<"payment", 'Decimal'>
    readonly total_amount: FieldRef<"payment", 'Decimal'>
    readonly installment_number: FieldRef<"payment", 'Int'>
    readonly date_paid: FieldRef<"payment", 'DateTime'>
    readonly payment_method_id: FieldRef<"payment", 'Int'>
    readonly currency: FieldRef<"payment", 'String'>
    readonly created_by: FieldRef<"payment", 'String'>
    readonly updated_by: FieldRef<"payment", 'String'>
    readonly created_at: FieldRef<"payment", 'DateTime'>
    readonly updated_at: FieldRef<"payment", 'DateTime'>
    readonly version: FieldRef<"payment", 'Int'>
    readonly release_date: FieldRef<"payment", 'DateTime'>
    readonly payment_status: FieldRef<"payment", 'payment_status'>
    readonly billing_account: FieldRef<"payment", 'String'>
    readonly challenge_markup: FieldRef<"payment", 'Decimal'>
    readonly challenge_fee: FieldRef<"payment", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * payment findUnique
   */
  export type paymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment findUniqueOrThrow
   */
  export type paymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment findFirst
   */
  export type paymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment findFirstOrThrow
   */
  export type paymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment findMany
   */
  export type paymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment create
   */
  export type paymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * The data needed to create a payment.
     */
    data: XOR<paymentCreateInput, paymentUncheckedCreateInput>
  }

  /**
   * payment createMany
   */
  export type paymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentCreateManyInput | paymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment createManyAndReturn
   */
  export type paymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * The data used to create many payments.
     */
    data: paymentCreateManyInput | paymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment update
   */
  export type paymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * The data needed to update a payment.
     */
    data: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
    /**
     * Choose, which payment to update.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment updateMany
   */
  export type paymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payment updateManyAndReturn
   */
  export type paymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * The data used to update payments.
     */
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment upsert
   */
  export type paymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * The filter to search for the payment to update in case it exists.
     */
    where: paymentWhereUniqueInput
    /**
     * In case the payment found by the `where` argument doesn't exist, create a new payment with this data.
     */
    create: XOR<paymentCreateInput, paymentUncheckedCreateInput>
    /**
     * In case the payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
  }

  /**
   * payment delete
   */
  export type paymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter which payment to delete.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment deleteMany
   */
  export type paymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentWhereInput
    /**
     * Limit how many payments to delete.
     */
    limit?: number
  }

  /**
   * payment.payment_method
   */
  export type payment$payment_methodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    where?: payment_methodWhereInput
  }

  /**
   * payment.payment_release_associations
   */
  export type payment$payment_release_associationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_release_associations
     */
    select?: payment_release_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_release_associations
     */
    omit?: payment_release_associationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_release_associationsInclude<ExtArgs> | null
    where?: payment_release_associationsWhereInput
    orderBy?: payment_release_associationsOrderByWithRelationInput | payment_release_associationsOrderByWithRelationInput[]
    cursor?: payment_release_associationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Payment_release_associationsScalarFieldEnum | Payment_release_associationsScalarFieldEnum[]
  }

  /**
   * payment without action
   */
  export type paymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
  }


  /**
   * Model payment_method
   */

  export type AggregatePayment_method = {
    _count: Payment_methodCountAggregateOutputType | null
    _avg: Payment_methodAvgAggregateOutputType | null
    _sum: Payment_methodSumAggregateOutputType | null
    _min: Payment_methodMinAggregateOutputType | null
    _max: Payment_methodMaxAggregateOutputType | null
  }

  export type Payment_methodAvgAggregateOutputType = {
    payment_method_id: number | null
  }

  export type Payment_methodSumAggregateOutputType = {
    payment_method_id: number | null
  }

  export type Payment_methodMinAggregateOutputType = {
    payment_method_id: number | null
    payment_method_type: string | null
    name: string | null
    description: string | null
  }

  export type Payment_methodMaxAggregateOutputType = {
    payment_method_id: number | null
    payment_method_type: string | null
    name: string | null
    description: string | null
  }

  export type Payment_methodCountAggregateOutputType = {
    payment_method_id: number
    payment_method_type: number
    name: number
    description: number
    _all: number
  }


  export type Payment_methodAvgAggregateInputType = {
    payment_method_id?: true
  }

  export type Payment_methodSumAggregateInputType = {
    payment_method_id?: true
  }

  export type Payment_methodMinAggregateInputType = {
    payment_method_id?: true
    payment_method_type?: true
    name?: true
    description?: true
  }

  export type Payment_methodMaxAggregateInputType = {
    payment_method_id?: true
    payment_method_type?: true
    name?: true
    description?: true
  }

  export type Payment_methodCountAggregateInputType = {
    payment_method_id?: true
    payment_method_type?: true
    name?: true
    description?: true
    _all?: true
  }

  export type Payment_methodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_method to aggregate.
     */
    where?: payment_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_methods to fetch.
     */
    orderBy?: payment_methodOrderByWithRelationInput | payment_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: payment_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payment_methods
    **/
    _count?: true | Payment_methodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Payment_methodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Payment_methodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Payment_methodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Payment_methodMaxAggregateInputType
  }

  export type GetPayment_methodAggregateType<T extends Payment_methodAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment_method]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment_method[P]>
      : GetScalarType<T[P], AggregatePayment_method[P]>
  }




  export type payment_methodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_methodWhereInput
    orderBy?: payment_methodOrderByWithAggregationInput | payment_methodOrderByWithAggregationInput[]
    by: Payment_methodScalarFieldEnum[] | Payment_methodScalarFieldEnum
    having?: payment_methodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Payment_methodCountAggregateInputType | true
    _avg?: Payment_methodAvgAggregateInputType
    _sum?: Payment_methodSumAggregateInputType
    _min?: Payment_methodMinAggregateInputType
    _max?: Payment_methodMaxAggregateInputType
  }

  export type Payment_methodGroupByOutputType = {
    payment_method_id: number
    payment_method_type: string
    name: string
    description: string | null
    _count: Payment_methodCountAggregateOutputType | null
    _avg: Payment_methodAvgAggregateOutputType | null
    _sum: Payment_methodSumAggregateOutputType | null
    _min: Payment_methodMinAggregateOutputType | null
    _max: Payment_methodMaxAggregateOutputType | null
  }

  type GetPayment_methodGroupByPayload<T extends payment_methodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Payment_methodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Payment_methodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Payment_methodGroupByOutputType[P]>
            : GetScalarType<T[P], Payment_methodGroupByOutputType[P]>
        }
      >
    >


  export type payment_methodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_method_id?: boolean
    payment_method_type?: boolean
    name?: boolean
    description?: boolean
    payment?: boolean | payment_method$paymentArgs<ExtArgs>
    payment_releases?: boolean | payment_method$payment_releasesArgs<ExtArgs>
    user_payment_methods?: boolean | payment_method$user_payment_methodsArgs<ExtArgs>
    _count?: boolean | Payment_methodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment_method"]>

  export type payment_methodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_method_id?: boolean
    payment_method_type?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["payment_method"]>

  export type payment_methodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_method_id?: boolean
    payment_method_type?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["payment_method"]>

  export type payment_methodSelectScalar = {
    payment_method_id?: boolean
    payment_method_type?: boolean
    name?: boolean
    description?: boolean
  }

  export type payment_methodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"payment_method_id" | "payment_method_type" | "name" | "description", ExtArgs["result"]["payment_method"]>
  export type payment_methodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | payment_method$paymentArgs<ExtArgs>
    payment_releases?: boolean | payment_method$payment_releasesArgs<ExtArgs>
    user_payment_methods?: boolean | payment_method$user_payment_methodsArgs<ExtArgs>
    _count?: boolean | Payment_methodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type payment_methodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type payment_methodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $payment_methodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment_method"
    objects: {
      payment: Prisma.$paymentPayload<ExtArgs>[]
      payment_releases: Prisma.$payment_releasesPayload<ExtArgs>[]
      user_payment_methods: Prisma.$user_payment_methodsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      payment_method_id: number
      payment_method_type: string
      name: string
      description: string | null
    }, ExtArgs["result"]["payment_method"]>
    composites: {}
  }

  type payment_methodGetPayload<S extends boolean | null | undefined | payment_methodDefaultArgs> = $Result.GetResult<Prisma.$payment_methodPayload, S>

  type payment_methodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<payment_methodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Payment_methodCountAggregateInputType | true
    }

  export interface payment_methodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment_method'], meta: { name: 'payment_method' } }
    /**
     * Find zero or one Payment_method that matches the filter.
     * @param {payment_methodFindUniqueArgs} args - Arguments to find a Payment_method
     * @example
     * // Get one Payment_method
     * const payment_method = await prisma.payment_method.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends payment_methodFindUniqueArgs>(args: SelectSubset<T, payment_methodFindUniqueArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment_method that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {payment_methodFindUniqueOrThrowArgs} args - Arguments to find a Payment_method
     * @example
     * // Get one Payment_method
     * const payment_method = await prisma.payment_method.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends payment_methodFindUniqueOrThrowArgs>(args: SelectSubset<T, payment_methodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_method that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodFindFirstArgs} args - Arguments to find a Payment_method
     * @example
     * // Get one Payment_method
     * const payment_method = await prisma.payment_method.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends payment_methodFindFirstArgs>(args?: SelectSubset<T, payment_methodFindFirstArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_method that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodFindFirstOrThrowArgs} args - Arguments to find a Payment_method
     * @example
     * // Get one Payment_method
     * const payment_method = await prisma.payment_method.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends payment_methodFindFirstOrThrowArgs>(args?: SelectSubset<T, payment_methodFindFirstOrThrowArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payment_methods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payment_methods
     * const payment_methods = await prisma.payment_method.findMany()
     * 
     * // Get first 10 Payment_methods
     * const payment_methods = await prisma.payment_method.findMany({ take: 10 })
     * 
     * // Only select the `payment_method_id`
     * const payment_methodWithPayment_method_idOnly = await prisma.payment_method.findMany({ select: { payment_method_id: true } })
     * 
     */
    findMany<T extends payment_methodFindManyArgs>(args?: SelectSubset<T, payment_methodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment_method.
     * @param {payment_methodCreateArgs} args - Arguments to create a Payment_method.
     * @example
     * // Create one Payment_method
     * const Payment_method = await prisma.payment_method.create({
     *   data: {
     *     // ... data to create a Payment_method
     *   }
     * })
     * 
     */
    create<T extends payment_methodCreateArgs>(args: SelectSubset<T, payment_methodCreateArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payment_methods.
     * @param {payment_methodCreateManyArgs} args - Arguments to create many Payment_methods.
     * @example
     * // Create many Payment_methods
     * const payment_method = await prisma.payment_method.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends payment_methodCreateManyArgs>(args?: SelectSubset<T, payment_methodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payment_methods and returns the data saved in the database.
     * @param {payment_methodCreateManyAndReturnArgs} args - Arguments to create many Payment_methods.
     * @example
     * // Create many Payment_methods
     * const payment_method = await prisma.payment_method.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payment_methods and only return the `payment_method_id`
     * const payment_methodWithPayment_method_idOnly = await prisma.payment_method.createManyAndReturn({
     *   select: { payment_method_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends payment_methodCreateManyAndReturnArgs>(args?: SelectSubset<T, payment_methodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment_method.
     * @param {payment_methodDeleteArgs} args - Arguments to delete one Payment_method.
     * @example
     * // Delete one Payment_method
     * const Payment_method = await prisma.payment_method.delete({
     *   where: {
     *     // ... filter to delete one Payment_method
     *   }
     * })
     * 
     */
    delete<T extends payment_methodDeleteArgs>(args: SelectSubset<T, payment_methodDeleteArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment_method.
     * @param {payment_methodUpdateArgs} args - Arguments to update one Payment_method.
     * @example
     * // Update one Payment_method
     * const payment_method = await prisma.payment_method.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends payment_methodUpdateArgs>(args: SelectSubset<T, payment_methodUpdateArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payment_methods.
     * @param {payment_methodDeleteManyArgs} args - Arguments to filter Payment_methods to delete.
     * @example
     * // Delete a few Payment_methods
     * const { count } = await prisma.payment_method.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends payment_methodDeleteManyArgs>(args?: SelectSubset<T, payment_methodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payment_methods
     * const payment_method = await prisma.payment_method.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends payment_methodUpdateManyArgs>(args: SelectSubset<T, payment_methodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_methods and returns the data updated in the database.
     * @param {payment_methodUpdateManyAndReturnArgs} args - Arguments to update many Payment_methods.
     * @example
     * // Update many Payment_methods
     * const payment_method = await prisma.payment_method.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payment_methods and only return the `payment_method_id`
     * const payment_methodWithPayment_method_idOnly = await prisma.payment_method.updateManyAndReturn({
     *   select: { payment_method_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends payment_methodUpdateManyAndReturnArgs>(args: SelectSubset<T, payment_methodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment_method.
     * @param {payment_methodUpsertArgs} args - Arguments to update or create a Payment_method.
     * @example
     * // Update or create a Payment_method
     * const payment_method = await prisma.payment_method.upsert({
     *   create: {
     *     // ... data to create a Payment_method
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment_method we want to update
     *   }
     * })
     */
    upsert<T extends payment_methodUpsertArgs>(args: SelectSubset<T, payment_methodUpsertArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodCountArgs} args - Arguments to filter Payment_methods to count.
     * @example
     * // Count the number of Payment_methods
     * const count = await prisma.payment_method.count({
     *   where: {
     *     // ... the filter for the Payment_methods we want to count
     *   }
     * })
    **/
    count<T extends payment_methodCountArgs>(
      args?: Subset<T, payment_methodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Payment_methodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment_method.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_methodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Payment_methodAggregateArgs>(args: Subset<T, Payment_methodAggregateArgs>): Prisma.PrismaPromise<GetPayment_methodAggregateType<T>>

    /**
     * Group by Payment_method.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends payment_methodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payment_methodGroupByArgs['orderBy'] }
        : { orderBy?: payment_methodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, payment_methodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayment_methodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment_method model
   */
  readonly fields: payment_methodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment_method.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payment_methodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends payment_method$paymentArgs<ExtArgs> = {}>(args?: Subset<T, payment_method$paymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payment_releases<T extends payment_method$payment_releasesArgs<ExtArgs> = {}>(args?: Subset<T, payment_method$payment_releasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_releasesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_payment_methods<T extends payment_method$user_payment_methodsArgs<ExtArgs> = {}>(args?: Subset<T, payment_method$user_payment_methodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment_method model
   */
  interface payment_methodFieldRefs {
    readonly payment_method_id: FieldRef<"payment_method", 'Int'>
    readonly payment_method_type: FieldRef<"payment_method", 'String'>
    readonly name: FieldRef<"payment_method", 'String'>
    readonly description: FieldRef<"payment_method", 'String'>
  }
    

  // Custom InputTypes
  /**
   * payment_method findUnique
   */
  export type payment_methodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * Filter, which payment_method to fetch.
     */
    where: payment_methodWhereUniqueInput
  }

  /**
   * payment_method findUniqueOrThrow
   */
  export type payment_methodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * Filter, which payment_method to fetch.
     */
    where: payment_methodWhereUniqueInput
  }

  /**
   * payment_method findFirst
   */
  export type payment_methodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * Filter, which payment_method to fetch.
     */
    where?: payment_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_methods to fetch.
     */
    orderBy?: payment_methodOrderByWithRelationInput | payment_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_methods.
     */
    cursor?: payment_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_methods.
     */
    distinct?: Payment_methodScalarFieldEnum | Payment_methodScalarFieldEnum[]
  }

  /**
   * payment_method findFirstOrThrow
   */
  export type payment_methodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * Filter, which payment_method to fetch.
     */
    where?: payment_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_methods to fetch.
     */
    orderBy?: payment_methodOrderByWithRelationInput | payment_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_methods.
     */
    cursor?: payment_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_methods.
     */
    distinct?: Payment_methodScalarFieldEnum | Payment_methodScalarFieldEnum[]
  }

  /**
   * payment_method findMany
   */
  export type payment_methodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * Filter, which payment_methods to fetch.
     */
    where?: payment_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_methods to fetch.
     */
    orderBy?: payment_methodOrderByWithRelationInput | payment_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payment_methods.
     */
    cursor?: payment_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_methods.
     */
    skip?: number
    distinct?: Payment_methodScalarFieldEnum | Payment_methodScalarFieldEnum[]
  }

  /**
   * payment_method create
   */
  export type payment_methodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * The data needed to create a payment_method.
     */
    data: XOR<payment_methodCreateInput, payment_methodUncheckedCreateInput>
  }

  /**
   * payment_method createMany
   */
  export type payment_methodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payment_methods.
     */
    data: payment_methodCreateManyInput | payment_methodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment_method createManyAndReturn
   */
  export type payment_methodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * The data used to create many payment_methods.
     */
    data: payment_methodCreateManyInput | payment_methodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment_method update
   */
  export type payment_methodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * The data needed to update a payment_method.
     */
    data: XOR<payment_methodUpdateInput, payment_methodUncheckedUpdateInput>
    /**
     * Choose, which payment_method to update.
     */
    where: payment_methodWhereUniqueInput
  }

  /**
   * payment_method updateMany
   */
  export type payment_methodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payment_methods.
     */
    data: XOR<payment_methodUpdateManyMutationInput, payment_methodUncheckedUpdateManyInput>
    /**
     * Filter which payment_methods to update
     */
    where?: payment_methodWhereInput
    /**
     * Limit how many payment_methods to update.
     */
    limit?: number
  }

  /**
   * payment_method updateManyAndReturn
   */
  export type payment_methodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * The data used to update payment_methods.
     */
    data: XOR<payment_methodUpdateManyMutationInput, payment_methodUncheckedUpdateManyInput>
    /**
     * Filter which payment_methods to update
     */
    where?: payment_methodWhereInput
    /**
     * Limit how many payment_methods to update.
     */
    limit?: number
  }

  /**
   * payment_method upsert
   */
  export type payment_methodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * The filter to search for the payment_method to update in case it exists.
     */
    where: payment_methodWhereUniqueInput
    /**
     * In case the payment_method found by the `where` argument doesn't exist, create a new payment_method with this data.
     */
    create: XOR<payment_methodCreateInput, payment_methodUncheckedCreateInput>
    /**
     * In case the payment_method was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payment_methodUpdateInput, payment_methodUncheckedUpdateInput>
  }

  /**
   * payment_method delete
   */
  export type payment_methodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * Filter which payment_method to delete.
     */
    where: payment_methodWhereUniqueInput
  }

  /**
   * payment_method deleteMany
   */
  export type payment_methodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_methods to delete
     */
    where?: payment_methodWhereInput
    /**
     * Limit how many payment_methods to delete.
     */
    limit?: number
  }

  /**
   * payment_method.payment
   */
  export type payment_method$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    where?: paymentWhereInput
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    cursor?: paymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment_method.payment_releases
   */
  export type payment_method$payment_releasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_releases
     */
    select?: payment_releasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_releases
     */
    omit?: payment_releasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_releasesInclude<ExtArgs> | null
    where?: payment_releasesWhereInput
    orderBy?: payment_releasesOrderByWithRelationInput | payment_releasesOrderByWithRelationInput[]
    cursor?: payment_releasesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Payment_releasesScalarFieldEnum | Payment_releasesScalarFieldEnum[]
  }

  /**
   * payment_method.user_payment_methods
   */
  export type payment_method$user_payment_methodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    where?: user_payment_methodsWhereInput
    orderBy?: user_payment_methodsOrderByWithRelationInput | user_payment_methodsOrderByWithRelationInput[]
    cursor?: user_payment_methodsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_payment_methodsScalarFieldEnum | User_payment_methodsScalarFieldEnum[]
  }

  /**
   * payment_method without action
   */
  export type payment_methodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
  }


  /**
   * Model payment_release_associations
   */

  export type AggregatePayment_release_associations = {
    _count: Payment_release_associationsCountAggregateOutputType | null
    _min: Payment_release_associationsMinAggregateOutputType | null
    _max: Payment_release_associationsMaxAggregateOutputType | null
  }

  export type Payment_release_associationsMinAggregateOutputType = {
    payment_release_id: string | null
    payment_id: string | null
  }

  export type Payment_release_associationsMaxAggregateOutputType = {
    payment_release_id: string | null
    payment_id: string | null
  }

  export type Payment_release_associationsCountAggregateOutputType = {
    payment_release_id: number
    payment_id: number
    _all: number
  }


  export type Payment_release_associationsMinAggregateInputType = {
    payment_release_id?: true
    payment_id?: true
  }

  export type Payment_release_associationsMaxAggregateInputType = {
    payment_release_id?: true
    payment_id?: true
  }

  export type Payment_release_associationsCountAggregateInputType = {
    payment_release_id?: true
    payment_id?: true
    _all?: true
  }

  export type Payment_release_associationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_release_associations to aggregate.
     */
    where?: payment_release_associationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_release_associations to fetch.
     */
    orderBy?: payment_release_associationsOrderByWithRelationInput | payment_release_associationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: payment_release_associationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_release_associations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_release_associations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payment_release_associations
    **/
    _count?: true | Payment_release_associationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Payment_release_associationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Payment_release_associationsMaxAggregateInputType
  }

  export type GetPayment_release_associationsAggregateType<T extends Payment_release_associationsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment_release_associations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment_release_associations[P]>
      : GetScalarType<T[P], AggregatePayment_release_associations[P]>
  }




  export type payment_release_associationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_release_associationsWhereInput
    orderBy?: payment_release_associationsOrderByWithAggregationInput | payment_release_associationsOrderByWithAggregationInput[]
    by: Payment_release_associationsScalarFieldEnum[] | Payment_release_associationsScalarFieldEnum
    having?: payment_release_associationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Payment_release_associationsCountAggregateInputType | true
    _min?: Payment_release_associationsMinAggregateInputType
    _max?: Payment_release_associationsMaxAggregateInputType
  }

  export type Payment_release_associationsGroupByOutputType = {
    payment_release_id: string
    payment_id: string
    _count: Payment_release_associationsCountAggregateOutputType | null
    _min: Payment_release_associationsMinAggregateOutputType | null
    _max: Payment_release_associationsMaxAggregateOutputType | null
  }

  type GetPayment_release_associationsGroupByPayload<T extends payment_release_associationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Payment_release_associationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Payment_release_associationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Payment_release_associationsGroupByOutputType[P]>
            : GetScalarType<T[P], Payment_release_associationsGroupByOutputType[P]>
        }
      >
    >


  export type payment_release_associationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_release_id?: boolean
    payment_id?: boolean
    payment?: boolean | paymentDefaultArgs<ExtArgs>
    payment_releases?: boolean | payment_releasesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment_release_associations"]>

  export type payment_release_associationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_release_id?: boolean
    payment_id?: boolean
    payment?: boolean | paymentDefaultArgs<ExtArgs>
    payment_releases?: boolean | payment_releasesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment_release_associations"]>

  export type payment_release_associationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_release_id?: boolean
    payment_id?: boolean
    payment?: boolean | paymentDefaultArgs<ExtArgs>
    payment_releases?: boolean | payment_releasesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment_release_associations"]>

  export type payment_release_associationsSelectScalar = {
    payment_release_id?: boolean
    payment_id?: boolean
  }

  export type payment_release_associationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"payment_release_id" | "payment_id", ExtArgs["result"]["payment_release_associations"]>
  export type payment_release_associationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | paymentDefaultArgs<ExtArgs>
    payment_releases?: boolean | payment_releasesDefaultArgs<ExtArgs>
  }
  export type payment_release_associationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | paymentDefaultArgs<ExtArgs>
    payment_releases?: boolean | payment_releasesDefaultArgs<ExtArgs>
  }
  export type payment_release_associationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | paymentDefaultArgs<ExtArgs>
    payment_releases?: boolean | payment_releasesDefaultArgs<ExtArgs>
  }

  export type $payment_release_associationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment_release_associations"
    objects: {
      payment: Prisma.$paymentPayload<ExtArgs>
      payment_releases: Prisma.$payment_releasesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      payment_release_id: string
      payment_id: string
    }, ExtArgs["result"]["payment_release_associations"]>
    composites: {}
  }

  type payment_release_associationsGetPayload<S extends boolean | null | undefined | payment_release_associationsDefaultArgs> = $Result.GetResult<Prisma.$payment_release_associationsPayload, S>

  type payment_release_associationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<payment_release_associationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Payment_release_associationsCountAggregateInputType | true
    }

  export interface payment_release_associationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment_release_associations'], meta: { name: 'payment_release_associations' } }
    /**
     * Find zero or one Payment_release_associations that matches the filter.
     * @param {payment_release_associationsFindUniqueArgs} args - Arguments to find a Payment_release_associations
     * @example
     * // Get one Payment_release_associations
     * const payment_release_associations = await prisma.payment_release_associations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends payment_release_associationsFindUniqueArgs>(args: SelectSubset<T, payment_release_associationsFindUniqueArgs<ExtArgs>>): Prisma__payment_release_associationsClient<$Result.GetResult<Prisma.$payment_release_associationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment_release_associations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {payment_release_associationsFindUniqueOrThrowArgs} args - Arguments to find a Payment_release_associations
     * @example
     * // Get one Payment_release_associations
     * const payment_release_associations = await prisma.payment_release_associations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends payment_release_associationsFindUniqueOrThrowArgs>(args: SelectSubset<T, payment_release_associationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__payment_release_associationsClient<$Result.GetResult<Prisma.$payment_release_associationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_release_associations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_release_associationsFindFirstArgs} args - Arguments to find a Payment_release_associations
     * @example
     * // Get one Payment_release_associations
     * const payment_release_associations = await prisma.payment_release_associations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends payment_release_associationsFindFirstArgs>(args?: SelectSubset<T, payment_release_associationsFindFirstArgs<ExtArgs>>): Prisma__payment_release_associationsClient<$Result.GetResult<Prisma.$payment_release_associationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_release_associations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_release_associationsFindFirstOrThrowArgs} args - Arguments to find a Payment_release_associations
     * @example
     * // Get one Payment_release_associations
     * const payment_release_associations = await prisma.payment_release_associations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends payment_release_associationsFindFirstOrThrowArgs>(args?: SelectSubset<T, payment_release_associationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__payment_release_associationsClient<$Result.GetResult<Prisma.$payment_release_associationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payment_release_associations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_release_associationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payment_release_associations
     * const payment_release_associations = await prisma.payment_release_associations.findMany()
     * 
     * // Get first 10 Payment_release_associations
     * const payment_release_associations = await prisma.payment_release_associations.findMany({ take: 10 })
     * 
     * // Only select the `payment_release_id`
     * const payment_release_associationsWithPayment_release_idOnly = await prisma.payment_release_associations.findMany({ select: { payment_release_id: true } })
     * 
     */
    findMany<T extends payment_release_associationsFindManyArgs>(args?: SelectSubset<T, payment_release_associationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_release_associationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment_release_associations.
     * @param {payment_release_associationsCreateArgs} args - Arguments to create a Payment_release_associations.
     * @example
     * // Create one Payment_release_associations
     * const Payment_release_associations = await prisma.payment_release_associations.create({
     *   data: {
     *     // ... data to create a Payment_release_associations
     *   }
     * })
     * 
     */
    create<T extends payment_release_associationsCreateArgs>(args: SelectSubset<T, payment_release_associationsCreateArgs<ExtArgs>>): Prisma__payment_release_associationsClient<$Result.GetResult<Prisma.$payment_release_associationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payment_release_associations.
     * @param {payment_release_associationsCreateManyArgs} args - Arguments to create many Payment_release_associations.
     * @example
     * // Create many Payment_release_associations
     * const payment_release_associations = await prisma.payment_release_associations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends payment_release_associationsCreateManyArgs>(args?: SelectSubset<T, payment_release_associationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payment_release_associations and returns the data saved in the database.
     * @param {payment_release_associationsCreateManyAndReturnArgs} args - Arguments to create many Payment_release_associations.
     * @example
     * // Create many Payment_release_associations
     * const payment_release_associations = await prisma.payment_release_associations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payment_release_associations and only return the `payment_release_id`
     * const payment_release_associationsWithPayment_release_idOnly = await prisma.payment_release_associations.createManyAndReturn({
     *   select: { payment_release_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends payment_release_associationsCreateManyAndReturnArgs>(args?: SelectSubset<T, payment_release_associationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_release_associationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment_release_associations.
     * @param {payment_release_associationsDeleteArgs} args - Arguments to delete one Payment_release_associations.
     * @example
     * // Delete one Payment_release_associations
     * const Payment_release_associations = await prisma.payment_release_associations.delete({
     *   where: {
     *     // ... filter to delete one Payment_release_associations
     *   }
     * })
     * 
     */
    delete<T extends payment_release_associationsDeleteArgs>(args: SelectSubset<T, payment_release_associationsDeleteArgs<ExtArgs>>): Prisma__payment_release_associationsClient<$Result.GetResult<Prisma.$payment_release_associationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment_release_associations.
     * @param {payment_release_associationsUpdateArgs} args - Arguments to update one Payment_release_associations.
     * @example
     * // Update one Payment_release_associations
     * const payment_release_associations = await prisma.payment_release_associations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends payment_release_associationsUpdateArgs>(args: SelectSubset<T, payment_release_associationsUpdateArgs<ExtArgs>>): Prisma__payment_release_associationsClient<$Result.GetResult<Prisma.$payment_release_associationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payment_release_associations.
     * @param {payment_release_associationsDeleteManyArgs} args - Arguments to filter Payment_release_associations to delete.
     * @example
     * // Delete a few Payment_release_associations
     * const { count } = await prisma.payment_release_associations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends payment_release_associationsDeleteManyArgs>(args?: SelectSubset<T, payment_release_associationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_release_associations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_release_associationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payment_release_associations
     * const payment_release_associations = await prisma.payment_release_associations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends payment_release_associationsUpdateManyArgs>(args: SelectSubset<T, payment_release_associationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_release_associations and returns the data updated in the database.
     * @param {payment_release_associationsUpdateManyAndReturnArgs} args - Arguments to update many Payment_release_associations.
     * @example
     * // Update many Payment_release_associations
     * const payment_release_associations = await prisma.payment_release_associations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payment_release_associations and only return the `payment_release_id`
     * const payment_release_associationsWithPayment_release_idOnly = await prisma.payment_release_associations.updateManyAndReturn({
     *   select: { payment_release_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends payment_release_associationsUpdateManyAndReturnArgs>(args: SelectSubset<T, payment_release_associationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_release_associationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment_release_associations.
     * @param {payment_release_associationsUpsertArgs} args - Arguments to update or create a Payment_release_associations.
     * @example
     * // Update or create a Payment_release_associations
     * const payment_release_associations = await prisma.payment_release_associations.upsert({
     *   create: {
     *     // ... data to create a Payment_release_associations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment_release_associations we want to update
     *   }
     * })
     */
    upsert<T extends payment_release_associationsUpsertArgs>(args: SelectSubset<T, payment_release_associationsUpsertArgs<ExtArgs>>): Prisma__payment_release_associationsClient<$Result.GetResult<Prisma.$payment_release_associationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payment_release_associations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_release_associationsCountArgs} args - Arguments to filter Payment_release_associations to count.
     * @example
     * // Count the number of Payment_release_associations
     * const count = await prisma.payment_release_associations.count({
     *   where: {
     *     // ... the filter for the Payment_release_associations we want to count
     *   }
     * })
    **/
    count<T extends payment_release_associationsCountArgs>(
      args?: Subset<T, payment_release_associationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Payment_release_associationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment_release_associations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_release_associationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Payment_release_associationsAggregateArgs>(args: Subset<T, Payment_release_associationsAggregateArgs>): Prisma.PrismaPromise<GetPayment_release_associationsAggregateType<T>>

    /**
     * Group by Payment_release_associations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_release_associationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends payment_release_associationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payment_release_associationsGroupByArgs['orderBy'] }
        : { orderBy?: payment_release_associationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, payment_release_associationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayment_release_associationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment_release_associations model
   */
  readonly fields: payment_release_associationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment_release_associations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payment_release_associationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends paymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, paymentDefaultArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payment_releases<T extends payment_releasesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, payment_releasesDefaultArgs<ExtArgs>>): Prisma__payment_releasesClient<$Result.GetResult<Prisma.$payment_releasesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment_release_associations model
   */
  interface payment_release_associationsFieldRefs {
    readonly payment_release_id: FieldRef<"payment_release_associations", 'String'>
    readonly payment_id: FieldRef<"payment_release_associations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * payment_release_associations findUnique
   */
  export type payment_release_associationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_release_associations
     */
    select?: payment_release_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_release_associations
     */
    omit?: payment_release_associationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_release_associationsInclude<ExtArgs> | null
    /**
     * Filter, which payment_release_associations to fetch.
     */
    where: payment_release_associationsWhereUniqueInput
  }

  /**
   * payment_release_associations findUniqueOrThrow
   */
  export type payment_release_associationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_release_associations
     */
    select?: payment_release_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_release_associations
     */
    omit?: payment_release_associationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_release_associationsInclude<ExtArgs> | null
    /**
     * Filter, which payment_release_associations to fetch.
     */
    where: payment_release_associationsWhereUniqueInput
  }

  /**
   * payment_release_associations findFirst
   */
  export type payment_release_associationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_release_associations
     */
    select?: payment_release_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_release_associations
     */
    omit?: payment_release_associationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_release_associationsInclude<ExtArgs> | null
    /**
     * Filter, which payment_release_associations to fetch.
     */
    where?: payment_release_associationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_release_associations to fetch.
     */
    orderBy?: payment_release_associationsOrderByWithRelationInput | payment_release_associationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_release_associations.
     */
    cursor?: payment_release_associationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_release_associations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_release_associations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_release_associations.
     */
    distinct?: Payment_release_associationsScalarFieldEnum | Payment_release_associationsScalarFieldEnum[]
  }

  /**
   * payment_release_associations findFirstOrThrow
   */
  export type payment_release_associationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_release_associations
     */
    select?: payment_release_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_release_associations
     */
    omit?: payment_release_associationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_release_associationsInclude<ExtArgs> | null
    /**
     * Filter, which payment_release_associations to fetch.
     */
    where?: payment_release_associationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_release_associations to fetch.
     */
    orderBy?: payment_release_associationsOrderByWithRelationInput | payment_release_associationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_release_associations.
     */
    cursor?: payment_release_associationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_release_associations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_release_associations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_release_associations.
     */
    distinct?: Payment_release_associationsScalarFieldEnum | Payment_release_associationsScalarFieldEnum[]
  }

  /**
   * payment_release_associations findMany
   */
  export type payment_release_associationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_release_associations
     */
    select?: payment_release_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_release_associations
     */
    omit?: payment_release_associationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_release_associationsInclude<ExtArgs> | null
    /**
     * Filter, which payment_release_associations to fetch.
     */
    where?: payment_release_associationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_release_associations to fetch.
     */
    orderBy?: payment_release_associationsOrderByWithRelationInput | payment_release_associationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payment_release_associations.
     */
    cursor?: payment_release_associationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_release_associations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_release_associations.
     */
    skip?: number
    distinct?: Payment_release_associationsScalarFieldEnum | Payment_release_associationsScalarFieldEnum[]
  }

  /**
   * payment_release_associations create
   */
  export type payment_release_associationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_release_associations
     */
    select?: payment_release_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_release_associations
     */
    omit?: payment_release_associationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_release_associationsInclude<ExtArgs> | null
    /**
     * The data needed to create a payment_release_associations.
     */
    data: XOR<payment_release_associationsCreateInput, payment_release_associationsUncheckedCreateInput>
  }

  /**
   * payment_release_associations createMany
   */
  export type payment_release_associationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payment_release_associations.
     */
    data: payment_release_associationsCreateManyInput | payment_release_associationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment_release_associations createManyAndReturn
   */
  export type payment_release_associationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_release_associations
     */
    select?: payment_release_associationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_release_associations
     */
    omit?: payment_release_associationsOmit<ExtArgs> | null
    /**
     * The data used to create many payment_release_associations.
     */
    data: payment_release_associationsCreateManyInput | payment_release_associationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_release_associationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment_release_associations update
   */
  export type payment_release_associationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_release_associations
     */
    select?: payment_release_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_release_associations
     */
    omit?: payment_release_associationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_release_associationsInclude<ExtArgs> | null
    /**
     * The data needed to update a payment_release_associations.
     */
    data: XOR<payment_release_associationsUpdateInput, payment_release_associationsUncheckedUpdateInput>
    /**
     * Choose, which payment_release_associations to update.
     */
    where: payment_release_associationsWhereUniqueInput
  }

  /**
   * payment_release_associations updateMany
   */
  export type payment_release_associationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payment_release_associations.
     */
    data: XOR<payment_release_associationsUpdateManyMutationInput, payment_release_associationsUncheckedUpdateManyInput>
    /**
     * Filter which payment_release_associations to update
     */
    where?: payment_release_associationsWhereInput
    /**
     * Limit how many payment_release_associations to update.
     */
    limit?: number
  }

  /**
   * payment_release_associations updateManyAndReturn
   */
  export type payment_release_associationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_release_associations
     */
    select?: payment_release_associationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_release_associations
     */
    omit?: payment_release_associationsOmit<ExtArgs> | null
    /**
     * The data used to update payment_release_associations.
     */
    data: XOR<payment_release_associationsUpdateManyMutationInput, payment_release_associationsUncheckedUpdateManyInput>
    /**
     * Filter which payment_release_associations to update
     */
    where?: payment_release_associationsWhereInput
    /**
     * Limit how many payment_release_associations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_release_associationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment_release_associations upsert
   */
  export type payment_release_associationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_release_associations
     */
    select?: payment_release_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_release_associations
     */
    omit?: payment_release_associationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_release_associationsInclude<ExtArgs> | null
    /**
     * The filter to search for the payment_release_associations to update in case it exists.
     */
    where: payment_release_associationsWhereUniqueInput
    /**
     * In case the payment_release_associations found by the `where` argument doesn't exist, create a new payment_release_associations with this data.
     */
    create: XOR<payment_release_associationsCreateInput, payment_release_associationsUncheckedCreateInput>
    /**
     * In case the payment_release_associations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payment_release_associationsUpdateInput, payment_release_associationsUncheckedUpdateInput>
  }

  /**
   * payment_release_associations delete
   */
  export type payment_release_associationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_release_associations
     */
    select?: payment_release_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_release_associations
     */
    omit?: payment_release_associationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_release_associationsInclude<ExtArgs> | null
    /**
     * Filter which payment_release_associations to delete.
     */
    where: payment_release_associationsWhereUniqueInput
  }

  /**
   * payment_release_associations deleteMany
   */
  export type payment_release_associationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_release_associations to delete
     */
    where?: payment_release_associationsWhereInput
    /**
     * Limit how many payment_release_associations to delete.
     */
    limit?: number
  }

  /**
   * payment_release_associations without action
   */
  export type payment_release_associationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_release_associations
     */
    select?: payment_release_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_release_associations
     */
    omit?: payment_release_associationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_release_associationsInclude<ExtArgs> | null
  }


  /**
   * Model payment_releases
   */

  export type AggregatePayment_releases = {
    _count: Payment_releasesCountAggregateOutputType | null
    _avg: Payment_releasesAvgAggregateOutputType | null
    _sum: Payment_releasesSumAggregateOutputType | null
    _min: Payment_releasesMinAggregateOutputType | null
    _max: Payment_releasesMaxAggregateOutputType | null
  }

  export type Payment_releasesAvgAggregateOutputType = {
    total_net_amount: Decimal | null
    payment_method_id: number | null
  }

  export type Payment_releasesSumAggregateOutputType = {
    total_net_amount: Decimal | null
    payment_method_id: number | null
  }

  export type Payment_releasesMinAggregateOutputType = {
    payment_release_id: string | null
    user_id: string | null
    total_net_amount: Decimal | null
    payment_method_id: number | null
    status: string | null
    external_transaction_id: string | null
    created_at: Date | null
    payee_id: string | null
    release_date: Date | null
    batch_id: string | null
  }

  export type Payment_releasesMaxAggregateOutputType = {
    payment_release_id: string | null
    user_id: string | null
    total_net_amount: Decimal | null
    payment_method_id: number | null
    status: string | null
    external_transaction_id: string | null
    created_at: Date | null
    payee_id: string | null
    release_date: Date | null
    batch_id: string | null
  }

  export type Payment_releasesCountAggregateOutputType = {
    payment_release_id: number
    user_id: number
    total_net_amount: number
    payment_method_id: number
    status: number
    external_transaction_id: number
    metadata: number
    created_at: number
    payee_id: number
    release_date: number
    batch_id: number
    _all: number
  }


  export type Payment_releasesAvgAggregateInputType = {
    total_net_amount?: true
    payment_method_id?: true
  }

  export type Payment_releasesSumAggregateInputType = {
    total_net_amount?: true
    payment_method_id?: true
  }

  export type Payment_releasesMinAggregateInputType = {
    payment_release_id?: true
    user_id?: true
    total_net_amount?: true
    payment_method_id?: true
    status?: true
    external_transaction_id?: true
    created_at?: true
    payee_id?: true
    release_date?: true
    batch_id?: true
  }

  export type Payment_releasesMaxAggregateInputType = {
    payment_release_id?: true
    user_id?: true
    total_net_amount?: true
    payment_method_id?: true
    status?: true
    external_transaction_id?: true
    created_at?: true
    payee_id?: true
    release_date?: true
    batch_id?: true
  }

  export type Payment_releasesCountAggregateInputType = {
    payment_release_id?: true
    user_id?: true
    total_net_amount?: true
    payment_method_id?: true
    status?: true
    external_transaction_id?: true
    metadata?: true
    created_at?: true
    payee_id?: true
    release_date?: true
    batch_id?: true
    _all?: true
  }

  export type Payment_releasesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_releases to aggregate.
     */
    where?: payment_releasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_releases to fetch.
     */
    orderBy?: payment_releasesOrderByWithRelationInput | payment_releasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: payment_releasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_releases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_releases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payment_releases
    **/
    _count?: true | Payment_releasesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Payment_releasesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Payment_releasesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Payment_releasesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Payment_releasesMaxAggregateInputType
  }

  export type GetPayment_releasesAggregateType<T extends Payment_releasesAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment_releases]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment_releases[P]>
      : GetScalarType<T[P], AggregatePayment_releases[P]>
  }




  export type payment_releasesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_releasesWhereInput
    orderBy?: payment_releasesOrderByWithAggregationInput | payment_releasesOrderByWithAggregationInput[]
    by: Payment_releasesScalarFieldEnum[] | Payment_releasesScalarFieldEnum
    having?: payment_releasesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Payment_releasesCountAggregateInputType | true
    _avg?: Payment_releasesAvgAggregateInputType
    _sum?: Payment_releasesSumAggregateInputType
    _min?: Payment_releasesMinAggregateInputType
    _max?: Payment_releasesMaxAggregateInputType
  }

  export type Payment_releasesGroupByOutputType = {
    payment_release_id: string
    user_id: string
    total_net_amount: Decimal
    payment_method_id: number
    status: string | null
    external_transaction_id: string | null
    metadata: JsonValue | null
    created_at: Date | null
    payee_id: string | null
    release_date: Date | null
    batch_id: string | null
    _count: Payment_releasesCountAggregateOutputType | null
    _avg: Payment_releasesAvgAggregateOutputType | null
    _sum: Payment_releasesSumAggregateOutputType | null
    _min: Payment_releasesMinAggregateOutputType | null
    _max: Payment_releasesMaxAggregateOutputType | null
  }

  type GetPayment_releasesGroupByPayload<T extends payment_releasesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Payment_releasesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Payment_releasesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Payment_releasesGroupByOutputType[P]>
            : GetScalarType<T[P], Payment_releasesGroupByOutputType[P]>
        }
      >
    >


  export type payment_releasesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_release_id?: boolean
    user_id?: boolean
    total_net_amount?: boolean
    payment_method_id?: boolean
    status?: boolean
    external_transaction_id?: boolean
    metadata?: boolean
    created_at?: boolean
    payee_id?: boolean
    release_date?: boolean
    batch_id?: boolean
    payment_release_associations?: boolean | payment_releases$payment_release_associationsArgs<ExtArgs>
    payment_method?: boolean | payment_methodDefaultArgs<ExtArgs>
    _count?: boolean | Payment_releasesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment_releases"]>

  export type payment_releasesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_release_id?: boolean
    user_id?: boolean
    total_net_amount?: boolean
    payment_method_id?: boolean
    status?: boolean
    external_transaction_id?: boolean
    metadata?: boolean
    created_at?: boolean
    payee_id?: boolean
    release_date?: boolean
    batch_id?: boolean
    payment_method?: boolean | payment_methodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment_releases"]>

  export type payment_releasesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_release_id?: boolean
    user_id?: boolean
    total_net_amount?: boolean
    payment_method_id?: boolean
    status?: boolean
    external_transaction_id?: boolean
    metadata?: boolean
    created_at?: boolean
    payee_id?: boolean
    release_date?: boolean
    batch_id?: boolean
    payment_method?: boolean | payment_methodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment_releases"]>

  export type payment_releasesSelectScalar = {
    payment_release_id?: boolean
    user_id?: boolean
    total_net_amount?: boolean
    payment_method_id?: boolean
    status?: boolean
    external_transaction_id?: boolean
    metadata?: boolean
    created_at?: boolean
    payee_id?: boolean
    release_date?: boolean
    batch_id?: boolean
  }

  export type payment_releasesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"payment_release_id" | "user_id" | "total_net_amount" | "payment_method_id" | "status" | "external_transaction_id" | "metadata" | "created_at" | "payee_id" | "release_date" | "batch_id", ExtArgs["result"]["payment_releases"]>
  export type payment_releasesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_release_associations?: boolean | payment_releases$payment_release_associationsArgs<ExtArgs>
    payment_method?: boolean | payment_methodDefaultArgs<ExtArgs>
    _count?: boolean | Payment_releasesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type payment_releasesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_method?: boolean | payment_methodDefaultArgs<ExtArgs>
  }
  export type payment_releasesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_method?: boolean | payment_methodDefaultArgs<ExtArgs>
  }

  export type $payment_releasesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment_releases"
    objects: {
      payment_release_associations: Prisma.$payment_release_associationsPayload<ExtArgs>[]
      payment_method: Prisma.$payment_methodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      payment_release_id: string
      user_id: string
      total_net_amount: Prisma.Decimal
      payment_method_id: number
      status: string | null
      external_transaction_id: string | null
      metadata: Prisma.JsonValue | null
      created_at: Date | null
      payee_id: string | null
      release_date: Date | null
      batch_id: string | null
    }, ExtArgs["result"]["payment_releases"]>
    composites: {}
  }

  type payment_releasesGetPayload<S extends boolean | null | undefined | payment_releasesDefaultArgs> = $Result.GetResult<Prisma.$payment_releasesPayload, S>

  type payment_releasesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<payment_releasesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Payment_releasesCountAggregateInputType | true
    }

  export interface payment_releasesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment_releases'], meta: { name: 'payment_releases' } }
    /**
     * Find zero or one Payment_releases that matches the filter.
     * @param {payment_releasesFindUniqueArgs} args - Arguments to find a Payment_releases
     * @example
     * // Get one Payment_releases
     * const payment_releases = await prisma.payment_releases.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends payment_releasesFindUniqueArgs>(args: SelectSubset<T, payment_releasesFindUniqueArgs<ExtArgs>>): Prisma__payment_releasesClient<$Result.GetResult<Prisma.$payment_releasesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment_releases that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {payment_releasesFindUniqueOrThrowArgs} args - Arguments to find a Payment_releases
     * @example
     * // Get one Payment_releases
     * const payment_releases = await prisma.payment_releases.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends payment_releasesFindUniqueOrThrowArgs>(args: SelectSubset<T, payment_releasesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__payment_releasesClient<$Result.GetResult<Prisma.$payment_releasesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_releases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_releasesFindFirstArgs} args - Arguments to find a Payment_releases
     * @example
     * // Get one Payment_releases
     * const payment_releases = await prisma.payment_releases.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends payment_releasesFindFirstArgs>(args?: SelectSubset<T, payment_releasesFindFirstArgs<ExtArgs>>): Prisma__payment_releasesClient<$Result.GetResult<Prisma.$payment_releasesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_releases that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_releasesFindFirstOrThrowArgs} args - Arguments to find a Payment_releases
     * @example
     * // Get one Payment_releases
     * const payment_releases = await prisma.payment_releases.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends payment_releasesFindFirstOrThrowArgs>(args?: SelectSubset<T, payment_releasesFindFirstOrThrowArgs<ExtArgs>>): Prisma__payment_releasesClient<$Result.GetResult<Prisma.$payment_releasesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payment_releases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_releasesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payment_releases
     * const payment_releases = await prisma.payment_releases.findMany()
     * 
     * // Get first 10 Payment_releases
     * const payment_releases = await prisma.payment_releases.findMany({ take: 10 })
     * 
     * // Only select the `payment_release_id`
     * const payment_releasesWithPayment_release_idOnly = await prisma.payment_releases.findMany({ select: { payment_release_id: true } })
     * 
     */
    findMany<T extends payment_releasesFindManyArgs>(args?: SelectSubset<T, payment_releasesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_releasesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment_releases.
     * @param {payment_releasesCreateArgs} args - Arguments to create a Payment_releases.
     * @example
     * // Create one Payment_releases
     * const Payment_releases = await prisma.payment_releases.create({
     *   data: {
     *     // ... data to create a Payment_releases
     *   }
     * })
     * 
     */
    create<T extends payment_releasesCreateArgs>(args: SelectSubset<T, payment_releasesCreateArgs<ExtArgs>>): Prisma__payment_releasesClient<$Result.GetResult<Prisma.$payment_releasesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payment_releases.
     * @param {payment_releasesCreateManyArgs} args - Arguments to create many Payment_releases.
     * @example
     * // Create many Payment_releases
     * const payment_releases = await prisma.payment_releases.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends payment_releasesCreateManyArgs>(args?: SelectSubset<T, payment_releasesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payment_releases and returns the data saved in the database.
     * @param {payment_releasesCreateManyAndReturnArgs} args - Arguments to create many Payment_releases.
     * @example
     * // Create many Payment_releases
     * const payment_releases = await prisma.payment_releases.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payment_releases and only return the `payment_release_id`
     * const payment_releasesWithPayment_release_idOnly = await prisma.payment_releases.createManyAndReturn({
     *   select: { payment_release_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends payment_releasesCreateManyAndReturnArgs>(args?: SelectSubset<T, payment_releasesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_releasesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment_releases.
     * @param {payment_releasesDeleteArgs} args - Arguments to delete one Payment_releases.
     * @example
     * // Delete one Payment_releases
     * const Payment_releases = await prisma.payment_releases.delete({
     *   where: {
     *     // ... filter to delete one Payment_releases
     *   }
     * })
     * 
     */
    delete<T extends payment_releasesDeleteArgs>(args: SelectSubset<T, payment_releasesDeleteArgs<ExtArgs>>): Prisma__payment_releasesClient<$Result.GetResult<Prisma.$payment_releasesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment_releases.
     * @param {payment_releasesUpdateArgs} args - Arguments to update one Payment_releases.
     * @example
     * // Update one Payment_releases
     * const payment_releases = await prisma.payment_releases.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends payment_releasesUpdateArgs>(args: SelectSubset<T, payment_releasesUpdateArgs<ExtArgs>>): Prisma__payment_releasesClient<$Result.GetResult<Prisma.$payment_releasesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payment_releases.
     * @param {payment_releasesDeleteManyArgs} args - Arguments to filter Payment_releases to delete.
     * @example
     * // Delete a few Payment_releases
     * const { count } = await prisma.payment_releases.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends payment_releasesDeleteManyArgs>(args?: SelectSubset<T, payment_releasesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_releases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_releasesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payment_releases
     * const payment_releases = await prisma.payment_releases.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends payment_releasesUpdateManyArgs>(args: SelectSubset<T, payment_releasesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_releases and returns the data updated in the database.
     * @param {payment_releasesUpdateManyAndReturnArgs} args - Arguments to update many Payment_releases.
     * @example
     * // Update many Payment_releases
     * const payment_releases = await prisma.payment_releases.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payment_releases and only return the `payment_release_id`
     * const payment_releasesWithPayment_release_idOnly = await prisma.payment_releases.updateManyAndReturn({
     *   select: { payment_release_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends payment_releasesUpdateManyAndReturnArgs>(args: SelectSubset<T, payment_releasesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_releasesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment_releases.
     * @param {payment_releasesUpsertArgs} args - Arguments to update or create a Payment_releases.
     * @example
     * // Update or create a Payment_releases
     * const payment_releases = await prisma.payment_releases.upsert({
     *   create: {
     *     // ... data to create a Payment_releases
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment_releases we want to update
     *   }
     * })
     */
    upsert<T extends payment_releasesUpsertArgs>(args: SelectSubset<T, payment_releasesUpsertArgs<ExtArgs>>): Prisma__payment_releasesClient<$Result.GetResult<Prisma.$payment_releasesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payment_releases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_releasesCountArgs} args - Arguments to filter Payment_releases to count.
     * @example
     * // Count the number of Payment_releases
     * const count = await prisma.payment_releases.count({
     *   where: {
     *     // ... the filter for the Payment_releases we want to count
     *   }
     * })
    **/
    count<T extends payment_releasesCountArgs>(
      args?: Subset<T, payment_releasesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Payment_releasesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment_releases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_releasesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Payment_releasesAggregateArgs>(args: Subset<T, Payment_releasesAggregateArgs>): Prisma.PrismaPromise<GetPayment_releasesAggregateType<T>>

    /**
     * Group by Payment_releases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_releasesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends payment_releasesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payment_releasesGroupByArgs['orderBy'] }
        : { orderBy?: payment_releasesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, payment_releasesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayment_releasesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment_releases model
   */
  readonly fields: payment_releasesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment_releases.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payment_releasesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment_release_associations<T extends payment_releases$payment_release_associationsArgs<ExtArgs> = {}>(args?: Subset<T, payment_releases$payment_release_associationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_release_associationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payment_method<T extends payment_methodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, payment_methodDefaultArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment_releases model
   */
  interface payment_releasesFieldRefs {
    readonly payment_release_id: FieldRef<"payment_releases", 'String'>
    readonly user_id: FieldRef<"payment_releases", 'String'>
    readonly total_net_amount: FieldRef<"payment_releases", 'Decimal'>
    readonly payment_method_id: FieldRef<"payment_releases", 'Int'>
    readonly status: FieldRef<"payment_releases", 'String'>
    readonly external_transaction_id: FieldRef<"payment_releases", 'String'>
    readonly metadata: FieldRef<"payment_releases", 'Json'>
    readonly created_at: FieldRef<"payment_releases", 'DateTime'>
    readonly payee_id: FieldRef<"payment_releases", 'String'>
    readonly release_date: FieldRef<"payment_releases", 'DateTime'>
    readonly batch_id: FieldRef<"payment_releases", 'String'>
  }
    

  // Custom InputTypes
  /**
   * payment_releases findUnique
   */
  export type payment_releasesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_releases
     */
    select?: payment_releasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_releases
     */
    omit?: payment_releasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_releasesInclude<ExtArgs> | null
    /**
     * Filter, which payment_releases to fetch.
     */
    where: payment_releasesWhereUniqueInput
  }

  /**
   * payment_releases findUniqueOrThrow
   */
  export type payment_releasesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_releases
     */
    select?: payment_releasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_releases
     */
    omit?: payment_releasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_releasesInclude<ExtArgs> | null
    /**
     * Filter, which payment_releases to fetch.
     */
    where: payment_releasesWhereUniqueInput
  }

  /**
   * payment_releases findFirst
   */
  export type payment_releasesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_releases
     */
    select?: payment_releasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_releases
     */
    omit?: payment_releasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_releasesInclude<ExtArgs> | null
    /**
     * Filter, which payment_releases to fetch.
     */
    where?: payment_releasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_releases to fetch.
     */
    orderBy?: payment_releasesOrderByWithRelationInput | payment_releasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_releases.
     */
    cursor?: payment_releasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_releases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_releases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_releases.
     */
    distinct?: Payment_releasesScalarFieldEnum | Payment_releasesScalarFieldEnum[]
  }

  /**
   * payment_releases findFirstOrThrow
   */
  export type payment_releasesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_releases
     */
    select?: payment_releasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_releases
     */
    omit?: payment_releasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_releasesInclude<ExtArgs> | null
    /**
     * Filter, which payment_releases to fetch.
     */
    where?: payment_releasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_releases to fetch.
     */
    orderBy?: payment_releasesOrderByWithRelationInput | payment_releasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_releases.
     */
    cursor?: payment_releasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_releases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_releases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_releases.
     */
    distinct?: Payment_releasesScalarFieldEnum | Payment_releasesScalarFieldEnum[]
  }

  /**
   * payment_releases findMany
   */
  export type payment_releasesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_releases
     */
    select?: payment_releasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_releases
     */
    omit?: payment_releasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_releasesInclude<ExtArgs> | null
    /**
     * Filter, which payment_releases to fetch.
     */
    where?: payment_releasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_releases to fetch.
     */
    orderBy?: payment_releasesOrderByWithRelationInput | payment_releasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payment_releases.
     */
    cursor?: payment_releasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_releases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_releases.
     */
    skip?: number
    distinct?: Payment_releasesScalarFieldEnum | Payment_releasesScalarFieldEnum[]
  }

  /**
   * payment_releases create
   */
  export type payment_releasesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_releases
     */
    select?: payment_releasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_releases
     */
    omit?: payment_releasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_releasesInclude<ExtArgs> | null
    /**
     * The data needed to create a payment_releases.
     */
    data: XOR<payment_releasesCreateInput, payment_releasesUncheckedCreateInput>
  }

  /**
   * payment_releases createMany
   */
  export type payment_releasesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payment_releases.
     */
    data: payment_releasesCreateManyInput | payment_releasesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment_releases createManyAndReturn
   */
  export type payment_releasesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_releases
     */
    select?: payment_releasesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_releases
     */
    omit?: payment_releasesOmit<ExtArgs> | null
    /**
     * The data used to create many payment_releases.
     */
    data: payment_releasesCreateManyInput | payment_releasesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_releasesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment_releases update
   */
  export type payment_releasesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_releases
     */
    select?: payment_releasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_releases
     */
    omit?: payment_releasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_releasesInclude<ExtArgs> | null
    /**
     * The data needed to update a payment_releases.
     */
    data: XOR<payment_releasesUpdateInput, payment_releasesUncheckedUpdateInput>
    /**
     * Choose, which payment_releases to update.
     */
    where: payment_releasesWhereUniqueInput
  }

  /**
   * payment_releases updateMany
   */
  export type payment_releasesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payment_releases.
     */
    data: XOR<payment_releasesUpdateManyMutationInput, payment_releasesUncheckedUpdateManyInput>
    /**
     * Filter which payment_releases to update
     */
    where?: payment_releasesWhereInput
    /**
     * Limit how many payment_releases to update.
     */
    limit?: number
  }

  /**
   * payment_releases updateManyAndReturn
   */
  export type payment_releasesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_releases
     */
    select?: payment_releasesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_releases
     */
    omit?: payment_releasesOmit<ExtArgs> | null
    /**
     * The data used to update payment_releases.
     */
    data: XOR<payment_releasesUpdateManyMutationInput, payment_releasesUncheckedUpdateManyInput>
    /**
     * Filter which payment_releases to update
     */
    where?: payment_releasesWhereInput
    /**
     * Limit how many payment_releases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_releasesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment_releases upsert
   */
  export type payment_releasesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_releases
     */
    select?: payment_releasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_releases
     */
    omit?: payment_releasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_releasesInclude<ExtArgs> | null
    /**
     * The filter to search for the payment_releases to update in case it exists.
     */
    where: payment_releasesWhereUniqueInput
    /**
     * In case the payment_releases found by the `where` argument doesn't exist, create a new payment_releases with this data.
     */
    create: XOR<payment_releasesCreateInput, payment_releasesUncheckedCreateInput>
    /**
     * In case the payment_releases was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payment_releasesUpdateInput, payment_releasesUncheckedUpdateInput>
  }

  /**
   * payment_releases delete
   */
  export type payment_releasesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_releases
     */
    select?: payment_releasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_releases
     */
    omit?: payment_releasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_releasesInclude<ExtArgs> | null
    /**
     * Filter which payment_releases to delete.
     */
    where: payment_releasesWhereUniqueInput
  }

  /**
   * payment_releases deleteMany
   */
  export type payment_releasesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_releases to delete
     */
    where?: payment_releasesWhereInput
    /**
     * Limit how many payment_releases to delete.
     */
    limit?: number
  }

  /**
   * payment_releases.payment_release_associations
   */
  export type payment_releases$payment_release_associationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_release_associations
     */
    select?: payment_release_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_release_associations
     */
    omit?: payment_release_associationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_release_associationsInclude<ExtArgs> | null
    where?: payment_release_associationsWhereInput
    orderBy?: payment_release_associationsOrderByWithRelationInput | payment_release_associationsOrderByWithRelationInput[]
    cursor?: payment_release_associationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Payment_release_associationsScalarFieldEnum | Payment_release_associationsScalarFieldEnum[]
  }

  /**
   * payment_releases without action
   */
  export type payment_releasesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_releases
     */
    select?: payment_releasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_releases
     */
    omit?: payment_releasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_releasesInclude<ExtArgs> | null
  }


  /**
   * Model user_payment_methods
   */

  export type AggregateUser_payment_methods = {
    _count: User_payment_methodsCountAggregateOutputType | null
    _avg: User_payment_methodsAvgAggregateOutputType | null
    _sum: User_payment_methodsSumAggregateOutputType | null
    _min: User_payment_methodsMinAggregateOutputType | null
    _max: User_payment_methodsMaxAggregateOutputType | null
  }

  export type User_payment_methodsAvgAggregateOutputType = {
    payment_method_id: number | null
  }

  export type User_payment_methodsSumAggregateOutputType = {
    payment_method_id: number | null
  }

  export type User_payment_methodsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    payment_method_id: number | null
    status: $Enums.payment_method_status | null
  }

  export type User_payment_methodsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    payment_method_id: number | null
    status: $Enums.payment_method_status | null
  }

  export type User_payment_methodsCountAggregateOutputType = {
    id: number
    user_id: number
    payment_method_id: number
    status: number
    _all: number
  }


  export type User_payment_methodsAvgAggregateInputType = {
    payment_method_id?: true
  }

  export type User_payment_methodsSumAggregateInputType = {
    payment_method_id?: true
  }

  export type User_payment_methodsMinAggregateInputType = {
    id?: true
    user_id?: true
    payment_method_id?: true
    status?: true
  }

  export type User_payment_methodsMaxAggregateInputType = {
    id?: true
    user_id?: true
    payment_method_id?: true
    status?: true
  }

  export type User_payment_methodsCountAggregateInputType = {
    id?: true
    user_id?: true
    payment_method_id?: true
    status?: true
    _all?: true
  }

  export type User_payment_methodsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_payment_methods to aggregate.
     */
    where?: user_payment_methodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_payment_methods to fetch.
     */
    orderBy?: user_payment_methodsOrderByWithRelationInput | user_payment_methodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_payment_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_payment_methods
    **/
    _count?: true | User_payment_methodsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_payment_methodsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_payment_methodsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_payment_methodsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_payment_methodsMaxAggregateInputType
  }

  export type GetUser_payment_methodsAggregateType<T extends User_payment_methodsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_payment_methods]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_payment_methods[P]>
      : GetScalarType<T[P], AggregateUser_payment_methods[P]>
  }




  export type user_payment_methodsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_payment_methodsWhereInput
    orderBy?: user_payment_methodsOrderByWithAggregationInput | user_payment_methodsOrderByWithAggregationInput[]
    by: User_payment_methodsScalarFieldEnum[] | User_payment_methodsScalarFieldEnum
    having?: user_payment_methodsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_payment_methodsCountAggregateInputType | true
    _avg?: User_payment_methodsAvgAggregateInputType
    _sum?: User_payment_methodsSumAggregateInputType
    _min?: User_payment_methodsMinAggregateInputType
    _max?: User_payment_methodsMaxAggregateInputType
  }

  export type User_payment_methodsGroupByOutputType = {
    id: string
    user_id: string
    payment_method_id: number
    status: $Enums.payment_method_status | null
    _count: User_payment_methodsCountAggregateOutputType | null
    _avg: User_payment_methodsAvgAggregateOutputType | null
    _sum: User_payment_methodsSumAggregateOutputType | null
    _min: User_payment_methodsMinAggregateOutputType | null
    _max: User_payment_methodsMaxAggregateOutputType | null
  }

  type GetUser_payment_methodsGroupByPayload<T extends user_payment_methodsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_payment_methodsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_payment_methodsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_payment_methodsGroupByOutputType[P]>
            : GetScalarType<T[P], User_payment_methodsGroupByOutputType[P]>
        }
      >
    >


  export type user_payment_methodsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    payment_method_id?: boolean
    status?: boolean
    trolley_payment_method?: boolean | user_payment_methods$trolley_payment_methodArgs<ExtArgs>
    payment_method?: boolean | payment_methodDefaultArgs<ExtArgs>
    _count?: boolean | User_payment_methodsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_payment_methods"]>

  export type user_payment_methodsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    payment_method_id?: boolean
    status?: boolean
    payment_method?: boolean | payment_methodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_payment_methods"]>

  export type user_payment_methodsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    payment_method_id?: boolean
    status?: boolean
    payment_method?: boolean | payment_methodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_payment_methods"]>

  export type user_payment_methodsSelectScalar = {
    id?: boolean
    user_id?: boolean
    payment_method_id?: boolean
    status?: boolean
  }

  export type user_payment_methodsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "payment_method_id" | "status", ExtArgs["result"]["user_payment_methods"]>
  export type user_payment_methodsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trolley_payment_method?: boolean | user_payment_methods$trolley_payment_methodArgs<ExtArgs>
    payment_method?: boolean | payment_methodDefaultArgs<ExtArgs>
    _count?: boolean | User_payment_methodsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type user_payment_methodsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_method?: boolean | payment_methodDefaultArgs<ExtArgs>
  }
  export type user_payment_methodsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_method?: boolean | payment_methodDefaultArgs<ExtArgs>
  }

  export type $user_payment_methodsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_payment_methods"
    objects: {
      trolley_payment_method: Prisma.$trolley_recipientPayload<ExtArgs>[]
      payment_method: Prisma.$payment_methodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      payment_method_id: number
      status: $Enums.payment_method_status | null
    }, ExtArgs["result"]["user_payment_methods"]>
    composites: {}
  }

  type user_payment_methodsGetPayload<S extends boolean | null | undefined | user_payment_methodsDefaultArgs> = $Result.GetResult<Prisma.$user_payment_methodsPayload, S>

  type user_payment_methodsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_payment_methodsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_payment_methodsCountAggregateInputType | true
    }

  export interface user_payment_methodsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_payment_methods'], meta: { name: 'user_payment_methods' } }
    /**
     * Find zero or one User_payment_methods that matches the filter.
     * @param {user_payment_methodsFindUniqueArgs} args - Arguments to find a User_payment_methods
     * @example
     * // Get one User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_payment_methodsFindUniqueArgs>(args: SelectSubset<T, user_payment_methodsFindUniqueArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_payment_methods that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_payment_methodsFindUniqueOrThrowArgs} args - Arguments to find a User_payment_methods
     * @example
     * // Get one User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_payment_methodsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_payment_methodsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_payment_methods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_payment_methodsFindFirstArgs} args - Arguments to find a User_payment_methods
     * @example
     * // Get one User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_payment_methodsFindFirstArgs>(args?: SelectSubset<T, user_payment_methodsFindFirstArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_payment_methods that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_payment_methodsFindFirstOrThrowArgs} args - Arguments to find a User_payment_methods
     * @example
     * // Get one User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_payment_methodsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_payment_methodsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_payment_methods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_payment_methodsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.findMany()
     * 
     * // Get first 10 User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_payment_methodsWithIdOnly = await prisma.user_payment_methods.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_payment_methodsFindManyArgs>(args?: SelectSubset<T, user_payment_methodsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_payment_methods.
     * @param {user_payment_methodsCreateArgs} args - Arguments to create a User_payment_methods.
     * @example
     * // Create one User_payment_methods
     * const User_payment_methods = await prisma.user_payment_methods.create({
     *   data: {
     *     // ... data to create a User_payment_methods
     *   }
     * })
     * 
     */
    create<T extends user_payment_methodsCreateArgs>(args: SelectSubset<T, user_payment_methodsCreateArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_payment_methods.
     * @param {user_payment_methodsCreateManyArgs} args - Arguments to create many User_payment_methods.
     * @example
     * // Create many User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_payment_methodsCreateManyArgs>(args?: SelectSubset<T, user_payment_methodsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_payment_methods and returns the data saved in the database.
     * @param {user_payment_methodsCreateManyAndReturnArgs} args - Arguments to create many User_payment_methods.
     * @example
     * // Create many User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_payment_methods and only return the `id`
     * const user_payment_methodsWithIdOnly = await prisma.user_payment_methods.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_payment_methodsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_payment_methodsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_payment_methods.
     * @param {user_payment_methodsDeleteArgs} args - Arguments to delete one User_payment_methods.
     * @example
     * // Delete one User_payment_methods
     * const User_payment_methods = await prisma.user_payment_methods.delete({
     *   where: {
     *     // ... filter to delete one User_payment_methods
     *   }
     * })
     * 
     */
    delete<T extends user_payment_methodsDeleteArgs>(args: SelectSubset<T, user_payment_methodsDeleteArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_payment_methods.
     * @param {user_payment_methodsUpdateArgs} args - Arguments to update one User_payment_methods.
     * @example
     * // Update one User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_payment_methodsUpdateArgs>(args: SelectSubset<T, user_payment_methodsUpdateArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_payment_methods.
     * @param {user_payment_methodsDeleteManyArgs} args - Arguments to filter User_payment_methods to delete.
     * @example
     * // Delete a few User_payment_methods
     * const { count } = await prisma.user_payment_methods.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_payment_methodsDeleteManyArgs>(args?: SelectSubset<T, user_payment_methodsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_payment_methodsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_payment_methodsUpdateManyArgs>(args: SelectSubset<T, user_payment_methodsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_payment_methods and returns the data updated in the database.
     * @param {user_payment_methodsUpdateManyAndReturnArgs} args - Arguments to update many User_payment_methods.
     * @example
     * // Update many User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_payment_methods and only return the `id`
     * const user_payment_methodsWithIdOnly = await prisma.user_payment_methods.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_payment_methodsUpdateManyAndReturnArgs>(args: SelectSubset<T, user_payment_methodsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_payment_methods.
     * @param {user_payment_methodsUpsertArgs} args - Arguments to update or create a User_payment_methods.
     * @example
     * // Update or create a User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.upsert({
     *   create: {
     *     // ... data to create a User_payment_methods
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_payment_methods we want to update
     *   }
     * })
     */
    upsert<T extends user_payment_methodsUpsertArgs>(args: SelectSubset<T, user_payment_methodsUpsertArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_payment_methodsCountArgs} args - Arguments to filter User_payment_methods to count.
     * @example
     * // Count the number of User_payment_methods
     * const count = await prisma.user_payment_methods.count({
     *   where: {
     *     // ... the filter for the User_payment_methods we want to count
     *   }
     * })
    **/
    count<T extends user_payment_methodsCountArgs>(
      args?: Subset<T, user_payment_methodsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_payment_methodsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_payment_methodsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_payment_methodsAggregateArgs>(args: Subset<T, User_payment_methodsAggregateArgs>): Prisma.PrismaPromise<GetUser_payment_methodsAggregateType<T>>

    /**
     * Group by User_payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_payment_methodsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_payment_methodsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_payment_methodsGroupByArgs['orderBy'] }
        : { orderBy?: user_payment_methodsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_payment_methodsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_payment_methodsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_payment_methods model
   */
  readonly fields: user_payment_methodsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_payment_methods.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_payment_methodsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trolley_payment_method<T extends user_payment_methods$trolley_payment_methodArgs<ExtArgs> = {}>(args?: Subset<T, user_payment_methods$trolley_payment_methodArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trolley_recipientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payment_method<T extends payment_methodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, payment_methodDefaultArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_payment_methods model
   */
  interface user_payment_methodsFieldRefs {
    readonly id: FieldRef<"user_payment_methods", 'String'>
    readonly user_id: FieldRef<"user_payment_methods", 'String'>
    readonly payment_method_id: FieldRef<"user_payment_methods", 'Int'>
    readonly status: FieldRef<"user_payment_methods", 'payment_method_status'>
  }
    

  // Custom InputTypes
  /**
   * user_payment_methods findUnique
   */
  export type user_payment_methodsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which user_payment_methods to fetch.
     */
    where: user_payment_methodsWhereUniqueInput
  }

  /**
   * user_payment_methods findUniqueOrThrow
   */
  export type user_payment_methodsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which user_payment_methods to fetch.
     */
    where: user_payment_methodsWhereUniqueInput
  }

  /**
   * user_payment_methods findFirst
   */
  export type user_payment_methodsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which user_payment_methods to fetch.
     */
    where?: user_payment_methodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_payment_methods to fetch.
     */
    orderBy?: user_payment_methodsOrderByWithRelationInput | user_payment_methodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_payment_methods.
     */
    cursor?: user_payment_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_payment_methods.
     */
    distinct?: User_payment_methodsScalarFieldEnum | User_payment_methodsScalarFieldEnum[]
  }

  /**
   * user_payment_methods findFirstOrThrow
   */
  export type user_payment_methodsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which user_payment_methods to fetch.
     */
    where?: user_payment_methodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_payment_methods to fetch.
     */
    orderBy?: user_payment_methodsOrderByWithRelationInput | user_payment_methodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_payment_methods.
     */
    cursor?: user_payment_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_payment_methods.
     */
    distinct?: User_payment_methodsScalarFieldEnum | User_payment_methodsScalarFieldEnum[]
  }

  /**
   * user_payment_methods findMany
   */
  export type user_payment_methodsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which user_payment_methods to fetch.
     */
    where?: user_payment_methodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_payment_methods to fetch.
     */
    orderBy?: user_payment_methodsOrderByWithRelationInput | user_payment_methodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_payment_methods.
     */
    cursor?: user_payment_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_payment_methods.
     */
    skip?: number
    distinct?: User_payment_methodsScalarFieldEnum | User_payment_methodsScalarFieldEnum[]
  }

  /**
   * user_payment_methods create
   */
  export type user_payment_methodsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * The data needed to create a user_payment_methods.
     */
    data: XOR<user_payment_methodsCreateInput, user_payment_methodsUncheckedCreateInput>
  }

  /**
   * user_payment_methods createMany
   */
  export type user_payment_methodsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_payment_methods.
     */
    data: user_payment_methodsCreateManyInput | user_payment_methodsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_payment_methods createManyAndReturn
   */
  export type user_payment_methodsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * The data used to create many user_payment_methods.
     */
    data: user_payment_methodsCreateManyInput | user_payment_methodsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_payment_methods update
   */
  export type user_payment_methodsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * The data needed to update a user_payment_methods.
     */
    data: XOR<user_payment_methodsUpdateInput, user_payment_methodsUncheckedUpdateInput>
    /**
     * Choose, which user_payment_methods to update.
     */
    where: user_payment_methodsWhereUniqueInput
  }

  /**
   * user_payment_methods updateMany
   */
  export type user_payment_methodsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_payment_methods.
     */
    data: XOR<user_payment_methodsUpdateManyMutationInput, user_payment_methodsUncheckedUpdateManyInput>
    /**
     * Filter which user_payment_methods to update
     */
    where?: user_payment_methodsWhereInput
    /**
     * Limit how many user_payment_methods to update.
     */
    limit?: number
  }

  /**
   * user_payment_methods updateManyAndReturn
   */
  export type user_payment_methodsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * The data used to update user_payment_methods.
     */
    data: XOR<user_payment_methodsUpdateManyMutationInput, user_payment_methodsUncheckedUpdateManyInput>
    /**
     * Filter which user_payment_methods to update
     */
    where?: user_payment_methodsWhereInput
    /**
     * Limit how many user_payment_methods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_payment_methods upsert
   */
  export type user_payment_methodsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * The filter to search for the user_payment_methods to update in case it exists.
     */
    where: user_payment_methodsWhereUniqueInput
    /**
     * In case the user_payment_methods found by the `where` argument doesn't exist, create a new user_payment_methods with this data.
     */
    create: XOR<user_payment_methodsCreateInput, user_payment_methodsUncheckedCreateInput>
    /**
     * In case the user_payment_methods was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_payment_methodsUpdateInput, user_payment_methodsUncheckedUpdateInput>
  }

  /**
   * user_payment_methods delete
   */
  export type user_payment_methodsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * Filter which user_payment_methods to delete.
     */
    where: user_payment_methodsWhereUniqueInput
  }

  /**
   * user_payment_methods deleteMany
   */
  export type user_payment_methodsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_payment_methods to delete
     */
    where?: user_payment_methodsWhereInput
    /**
     * Limit how many user_payment_methods to delete.
     */
    limit?: number
  }

  /**
   * user_payment_methods.trolley_payment_method
   */
  export type user_payment_methods$trolley_payment_methodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient
     */
    select?: trolley_recipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient
     */
    omit?: trolley_recipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipientInclude<ExtArgs> | null
    where?: trolley_recipientWhereInput
    orderBy?: trolley_recipientOrderByWithRelationInput | trolley_recipientOrderByWithRelationInput[]
    cursor?: trolley_recipientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Trolley_recipientScalarFieldEnum | Trolley_recipientScalarFieldEnum[]
  }

  /**
   * user_payment_methods without action
   */
  export type user_payment_methodsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
  }


  /**
   * Model user_tax_form_associations
   */

  export type AggregateUser_tax_form_associations = {
    _count: User_tax_form_associationsCountAggregateOutputType | null
    _min: User_tax_form_associationsMinAggregateOutputType | null
    _max: User_tax_form_associationsMaxAggregateOutputType | null
  }

  export type User_tax_form_associationsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    tax_form_id: string | null
    date_filed: Date | null
    tax_form_status: $Enums.tax_form_status | null
  }

  export type User_tax_form_associationsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    tax_form_id: string | null
    date_filed: Date | null
    tax_form_status: $Enums.tax_form_status | null
  }

  export type User_tax_form_associationsCountAggregateOutputType = {
    id: number
    user_id: number
    tax_form_id: number
    date_filed: number
    tax_form_status: number
    _all: number
  }


  export type User_tax_form_associationsMinAggregateInputType = {
    id?: true
    user_id?: true
    tax_form_id?: true
    date_filed?: true
    tax_form_status?: true
  }

  export type User_tax_form_associationsMaxAggregateInputType = {
    id?: true
    user_id?: true
    tax_form_id?: true
    date_filed?: true
    tax_form_status?: true
  }

  export type User_tax_form_associationsCountAggregateInputType = {
    id?: true
    user_id?: true
    tax_form_id?: true
    date_filed?: true
    tax_form_status?: true
    _all?: true
  }

  export type User_tax_form_associationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_tax_form_associations to aggregate.
     */
    where?: user_tax_form_associationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_tax_form_associations to fetch.
     */
    orderBy?: user_tax_form_associationsOrderByWithRelationInput | user_tax_form_associationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_tax_form_associationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_tax_form_associations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_tax_form_associations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_tax_form_associations
    **/
    _count?: true | User_tax_form_associationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_tax_form_associationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_tax_form_associationsMaxAggregateInputType
  }

  export type GetUser_tax_form_associationsAggregateType<T extends User_tax_form_associationsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_tax_form_associations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_tax_form_associations[P]>
      : GetScalarType<T[P], AggregateUser_tax_form_associations[P]>
  }




  export type user_tax_form_associationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_tax_form_associationsWhereInput
    orderBy?: user_tax_form_associationsOrderByWithAggregationInput | user_tax_form_associationsOrderByWithAggregationInput[]
    by: User_tax_form_associationsScalarFieldEnum[] | User_tax_form_associationsScalarFieldEnum
    having?: user_tax_form_associationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_tax_form_associationsCountAggregateInputType | true
    _min?: User_tax_form_associationsMinAggregateInputType
    _max?: User_tax_form_associationsMaxAggregateInputType
  }

  export type User_tax_form_associationsGroupByOutputType = {
    id: string
    user_id: string
    tax_form_id: string
    date_filed: Date
    tax_form_status: $Enums.tax_form_status
    _count: User_tax_form_associationsCountAggregateOutputType | null
    _min: User_tax_form_associationsMinAggregateOutputType | null
    _max: User_tax_form_associationsMaxAggregateOutputType | null
  }

  type GetUser_tax_form_associationsGroupByPayload<T extends user_tax_form_associationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_tax_form_associationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_tax_form_associationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_tax_form_associationsGroupByOutputType[P]>
            : GetScalarType<T[P], User_tax_form_associationsGroupByOutputType[P]>
        }
      >
    >


  export type user_tax_form_associationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    tax_form_id?: boolean
    date_filed?: boolean
    tax_form_status?: boolean
  }, ExtArgs["result"]["user_tax_form_associations"]>

  export type user_tax_form_associationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    tax_form_id?: boolean
    date_filed?: boolean
    tax_form_status?: boolean
  }, ExtArgs["result"]["user_tax_form_associations"]>

  export type user_tax_form_associationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    tax_form_id?: boolean
    date_filed?: boolean
    tax_form_status?: boolean
  }, ExtArgs["result"]["user_tax_form_associations"]>

  export type user_tax_form_associationsSelectScalar = {
    id?: boolean
    user_id?: boolean
    tax_form_id?: boolean
    date_filed?: boolean
    tax_form_status?: boolean
  }

  export type user_tax_form_associationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "tax_form_id" | "date_filed" | "tax_form_status", ExtArgs["result"]["user_tax_form_associations"]>

  export type $user_tax_form_associationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_tax_form_associations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      tax_form_id: string
      date_filed: Date
      tax_form_status: $Enums.tax_form_status
    }, ExtArgs["result"]["user_tax_form_associations"]>
    composites: {}
  }

  type user_tax_form_associationsGetPayload<S extends boolean | null | undefined | user_tax_form_associationsDefaultArgs> = $Result.GetResult<Prisma.$user_tax_form_associationsPayload, S>

  type user_tax_form_associationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_tax_form_associationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_tax_form_associationsCountAggregateInputType | true
    }

  export interface user_tax_form_associationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_tax_form_associations'], meta: { name: 'user_tax_form_associations' } }
    /**
     * Find zero or one User_tax_form_associations that matches the filter.
     * @param {user_tax_form_associationsFindUniqueArgs} args - Arguments to find a User_tax_form_associations
     * @example
     * // Get one User_tax_form_associations
     * const user_tax_form_associations = await prisma.user_tax_form_associations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_tax_form_associationsFindUniqueArgs>(args: SelectSubset<T, user_tax_form_associationsFindUniqueArgs<ExtArgs>>): Prisma__user_tax_form_associationsClient<$Result.GetResult<Prisma.$user_tax_form_associationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_tax_form_associations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_tax_form_associationsFindUniqueOrThrowArgs} args - Arguments to find a User_tax_form_associations
     * @example
     * // Get one User_tax_form_associations
     * const user_tax_form_associations = await prisma.user_tax_form_associations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_tax_form_associationsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_tax_form_associationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_tax_form_associationsClient<$Result.GetResult<Prisma.$user_tax_form_associationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_tax_form_associations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_tax_form_associationsFindFirstArgs} args - Arguments to find a User_tax_form_associations
     * @example
     * // Get one User_tax_form_associations
     * const user_tax_form_associations = await prisma.user_tax_form_associations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_tax_form_associationsFindFirstArgs>(args?: SelectSubset<T, user_tax_form_associationsFindFirstArgs<ExtArgs>>): Prisma__user_tax_form_associationsClient<$Result.GetResult<Prisma.$user_tax_form_associationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_tax_form_associations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_tax_form_associationsFindFirstOrThrowArgs} args - Arguments to find a User_tax_form_associations
     * @example
     * // Get one User_tax_form_associations
     * const user_tax_form_associations = await prisma.user_tax_form_associations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_tax_form_associationsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_tax_form_associationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_tax_form_associationsClient<$Result.GetResult<Prisma.$user_tax_form_associationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_tax_form_associations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_tax_form_associationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_tax_form_associations
     * const user_tax_form_associations = await prisma.user_tax_form_associations.findMany()
     * 
     * // Get first 10 User_tax_form_associations
     * const user_tax_form_associations = await prisma.user_tax_form_associations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_tax_form_associationsWithIdOnly = await prisma.user_tax_form_associations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_tax_form_associationsFindManyArgs>(args?: SelectSubset<T, user_tax_form_associationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_tax_form_associationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_tax_form_associations.
     * @param {user_tax_form_associationsCreateArgs} args - Arguments to create a User_tax_form_associations.
     * @example
     * // Create one User_tax_form_associations
     * const User_tax_form_associations = await prisma.user_tax_form_associations.create({
     *   data: {
     *     // ... data to create a User_tax_form_associations
     *   }
     * })
     * 
     */
    create<T extends user_tax_form_associationsCreateArgs>(args: SelectSubset<T, user_tax_form_associationsCreateArgs<ExtArgs>>): Prisma__user_tax_form_associationsClient<$Result.GetResult<Prisma.$user_tax_form_associationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_tax_form_associations.
     * @param {user_tax_form_associationsCreateManyArgs} args - Arguments to create many User_tax_form_associations.
     * @example
     * // Create many User_tax_form_associations
     * const user_tax_form_associations = await prisma.user_tax_form_associations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_tax_form_associationsCreateManyArgs>(args?: SelectSubset<T, user_tax_form_associationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_tax_form_associations and returns the data saved in the database.
     * @param {user_tax_form_associationsCreateManyAndReturnArgs} args - Arguments to create many User_tax_form_associations.
     * @example
     * // Create many User_tax_form_associations
     * const user_tax_form_associations = await prisma.user_tax_form_associations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_tax_form_associations and only return the `id`
     * const user_tax_form_associationsWithIdOnly = await prisma.user_tax_form_associations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_tax_form_associationsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_tax_form_associationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_tax_form_associationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_tax_form_associations.
     * @param {user_tax_form_associationsDeleteArgs} args - Arguments to delete one User_tax_form_associations.
     * @example
     * // Delete one User_tax_form_associations
     * const User_tax_form_associations = await prisma.user_tax_form_associations.delete({
     *   where: {
     *     // ... filter to delete one User_tax_form_associations
     *   }
     * })
     * 
     */
    delete<T extends user_tax_form_associationsDeleteArgs>(args: SelectSubset<T, user_tax_form_associationsDeleteArgs<ExtArgs>>): Prisma__user_tax_form_associationsClient<$Result.GetResult<Prisma.$user_tax_form_associationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_tax_form_associations.
     * @param {user_tax_form_associationsUpdateArgs} args - Arguments to update one User_tax_form_associations.
     * @example
     * // Update one User_tax_form_associations
     * const user_tax_form_associations = await prisma.user_tax_form_associations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_tax_form_associationsUpdateArgs>(args: SelectSubset<T, user_tax_form_associationsUpdateArgs<ExtArgs>>): Prisma__user_tax_form_associationsClient<$Result.GetResult<Prisma.$user_tax_form_associationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_tax_form_associations.
     * @param {user_tax_form_associationsDeleteManyArgs} args - Arguments to filter User_tax_form_associations to delete.
     * @example
     * // Delete a few User_tax_form_associations
     * const { count } = await prisma.user_tax_form_associations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_tax_form_associationsDeleteManyArgs>(args?: SelectSubset<T, user_tax_form_associationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_tax_form_associations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_tax_form_associationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_tax_form_associations
     * const user_tax_form_associations = await prisma.user_tax_form_associations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_tax_form_associationsUpdateManyArgs>(args: SelectSubset<T, user_tax_form_associationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_tax_form_associations and returns the data updated in the database.
     * @param {user_tax_form_associationsUpdateManyAndReturnArgs} args - Arguments to update many User_tax_form_associations.
     * @example
     * // Update many User_tax_form_associations
     * const user_tax_form_associations = await prisma.user_tax_form_associations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_tax_form_associations and only return the `id`
     * const user_tax_form_associationsWithIdOnly = await prisma.user_tax_form_associations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_tax_form_associationsUpdateManyAndReturnArgs>(args: SelectSubset<T, user_tax_form_associationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_tax_form_associationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_tax_form_associations.
     * @param {user_tax_form_associationsUpsertArgs} args - Arguments to update or create a User_tax_form_associations.
     * @example
     * // Update or create a User_tax_form_associations
     * const user_tax_form_associations = await prisma.user_tax_form_associations.upsert({
     *   create: {
     *     // ... data to create a User_tax_form_associations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_tax_form_associations we want to update
     *   }
     * })
     */
    upsert<T extends user_tax_form_associationsUpsertArgs>(args: SelectSubset<T, user_tax_form_associationsUpsertArgs<ExtArgs>>): Prisma__user_tax_form_associationsClient<$Result.GetResult<Prisma.$user_tax_form_associationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_tax_form_associations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_tax_form_associationsCountArgs} args - Arguments to filter User_tax_form_associations to count.
     * @example
     * // Count the number of User_tax_form_associations
     * const count = await prisma.user_tax_form_associations.count({
     *   where: {
     *     // ... the filter for the User_tax_form_associations we want to count
     *   }
     * })
    **/
    count<T extends user_tax_form_associationsCountArgs>(
      args?: Subset<T, user_tax_form_associationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_tax_form_associationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_tax_form_associations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_tax_form_associationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_tax_form_associationsAggregateArgs>(args: Subset<T, User_tax_form_associationsAggregateArgs>): Prisma.PrismaPromise<GetUser_tax_form_associationsAggregateType<T>>

    /**
     * Group by User_tax_form_associations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_tax_form_associationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_tax_form_associationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_tax_form_associationsGroupByArgs['orderBy'] }
        : { orderBy?: user_tax_form_associationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_tax_form_associationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_tax_form_associationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_tax_form_associations model
   */
  readonly fields: user_tax_form_associationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_tax_form_associations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_tax_form_associationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_tax_form_associations model
   */
  interface user_tax_form_associationsFieldRefs {
    readonly id: FieldRef<"user_tax_form_associations", 'String'>
    readonly user_id: FieldRef<"user_tax_form_associations", 'String'>
    readonly tax_form_id: FieldRef<"user_tax_form_associations", 'String'>
    readonly date_filed: FieldRef<"user_tax_form_associations", 'DateTime'>
    readonly tax_form_status: FieldRef<"user_tax_form_associations", 'tax_form_status'>
  }
    

  // Custom InputTypes
  /**
   * user_tax_form_associations findUnique
   */
  export type user_tax_form_associationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_tax_form_associations
     */
    select?: user_tax_form_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_tax_form_associations
     */
    omit?: user_tax_form_associationsOmit<ExtArgs> | null
    /**
     * Filter, which user_tax_form_associations to fetch.
     */
    where: user_tax_form_associationsWhereUniqueInput
  }

  /**
   * user_tax_form_associations findUniqueOrThrow
   */
  export type user_tax_form_associationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_tax_form_associations
     */
    select?: user_tax_form_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_tax_form_associations
     */
    omit?: user_tax_form_associationsOmit<ExtArgs> | null
    /**
     * Filter, which user_tax_form_associations to fetch.
     */
    where: user_tax_form_associationsWhereUniqueInput
  }

  /**
   * user_tax_form_associations findFirst
   */
  export type user_tax_form_associationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_tax_form_associations
     */
    select?: user_tax_form_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_tax_form_associations
     */
    omit?: user_tax_form_associationsOmit<ExtArgs> | null
    /**
     * Filter, which user_tax_form_associations to fetch.
     */
    where?: user_tax_form_associationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_tax_form_associations to fetch.
     */
    orderBy?: user_tax_form_associationsOrderByWithRelationInput | user_tax_form_associationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_tax_form_associations.
     */
    cursor?: user_tax_form_associationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_tax_form_associations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_tax_form_associations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_tax_form_associations.
     */
    distinct?: User_tax_form_associationsScalarFieldEnum | User_tax_form_associationsScalarFieldEnum[]
  }

  /**
   * user_tax_form_associations findFirstOrThrow
   */
  export type user_tax_form_associationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_tax_form_associations
     */
    select?: user_tax_form_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_tax_form_associations
     */
    omit?: user_tax_form_associationsOmit<ExtArgs> | null
    /**
     * Filter, which user_tax_form_associations to fetch.
     */
    where?: user_tax_form_associationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_tax_form_associations to fetch.
     */
    orderBy?: user_tax_form_associationsOrderByWithRelationInput | user_tax_form_associationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_tax_form_associations.
     */
    cursor?: user_tax_form_associationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_tax_form_associations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_tax_form_associations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_tax_form_associations.
     */
    distinct?: User_tax_form_associationsScalarFieldEnum | User_tax_form_associationsScalarFieldEnum[]
  }

  /**
   * user_tax_form_associations findMany
   */
  export type user_tax_form_associationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_tax_form_associations
     */
    select?: user_tax_form_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_tax_form_associations
     */
    omit?: user_tax_form_associationsOmit<ExtArgs> | null
    /**
     * Filter, which user_tax_form_associations to fetch.
     */
    where?: user_tax_form_associationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_tax_form_associations to fetch.
     */
    orderBy?: user_tax_form_associationsOrderByWithRelationInput | user_tax_form_associationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_tax_form_associations.
     */
    cursor?: user_tax_form_associationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_tax_form_associations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_tax_form_associations.
     */
    skip?: number
    distinct?: User_tax_form_associationsScalarFieldEnum | User_tax_form_associationsScalarFieldEnum[]
  }

  /**
   * user_tax_form_associations create
   */
  export type user_tax_form_associationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_tax_form_associations
     */
    select?: user_tax_form_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_tax_form_associations
     */
    omit?: user_tax_form_associationsOmit<ExtArgs> | null
    /**
     * The data needed to create a user_tax_form_associations.
     */
    data: XOR<user_tax_form_associationsCreateInput, user_tax_form_associationsUncheckedCreateInput>
  }

  /**
   * user_tax_form_associations createMany
   */
  export type user_tax_form_associationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_tax_form_associations.
     */
    data: user_tax_form_associationsCreateManyInput | user_tax_form_associationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_tax_form_associations createManyAndReturn
   */
  export type user_tax_form_associationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_tax_form_associations
     */
    select?: user_tax_form_associationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_tax_form_associations
     */
    omit?: user_tax_form_associationsOmit<ExtArgs> | null
    /**
     * The data used to create many user_tax_form_associations.
     */
    data: user_tax_form_associationsCreateManyInput | user_tax_form_associationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_tax_form_associations update
   */
  export type user_tax_form_associationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_tax_form_associations
     */
    select?: user_tax_form_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_tax_form_associations
     */
    omit?: user_tax_form_associationsOmit<ExtArgs> | null
    /**
     * The data needed to update a user_tax_form_associations.
     */
    data: XOR<user_tax_form_associationsUpdateInput, user_tax_form_associationsUncheckedUpdateInput>
    /**
     * Choose, which user_tax_form_associations to update.
     */
    where: user_tax_form_associationsWhereUniqueInput
  }

  /**
   * user_tax_form_associations updateMany
   */
  export type user_tax_form_associationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_tax_form_associations.
     */
    data: XOR<user_tax_form_associationsUpdateManyMutationInput, user_tax_form_associationsUncheckedUpdateManyInput>
    /**
     * Filter which user_tax_form_associations to update
     */
    where?: user_tax_form_associationsWhereInput
    /**
     * Limit how many user_tax_form_associations to update.
     */
    limit?: number
  }

  /**
   * user_tax_form_associations updateManyAndReturn
   */
  export type user_tax_form_associationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_tax_form_associations
     */
    select?: user_tax_form_associationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_tax_form_associations
     */
    omit?: user_tax_form_associationsOmit<ExtArgs> | null
    /**
     * The data used to update user_tax_form_associations.
     */
    data: XOR<user_tax_form_associationsUpdateManyMutationInput, user_tax_form_associationsUncheckedUpdateManyInput>
    /**
     * Filter which user_tax_form_associations to update
     */
    where?: user_tax_form_associationsWhereInput
    /**
     * Limit how many user_tax_form_associations to update.
     */
    limit?: number
  }

  /**
   * user_tax_form_associations upsert
   */
  export type user_tax_form_associationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_tax_form_associations
     */
    select?: user_tax_form_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_tax_form_associations
     */
    omit?: user_tax_form_associationsOmit<ExtArgs> | null
    /**
     * The filter to search for the user_tax_form_associations to update in case it exists.
     */
    where: user_tax_form_associationsWhereUniqueInput
    /**
     * In case the user_tax_form_associations found by the `where` argument doesn't exist, create a new user_tax_form_associations with this data.
     */
    create: XOR<user_tax_form_associationsCreateInput, user_tax_form_associationsUncheckedCreateInput>
    /**
     * In case the user_tax_form_associations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_tax_form_associationsUpdateInput, user_tax_form_associationsUncheckedUpdateInput>
  }

  /**
   * user_tax_form_associations delete
   */
  export type user_tax_form_associationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_tax_form_associations
     */
    select?: user_tax_form_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_tax_form_associations
     */
    omit?: user_tax_form_associationsOmit<ExtArgs> | null
    /**
     * Filter which user_tax_form_associations to delete.
     */
    where: user_tax_form_associationsWhereUniqueInput
  }

  /**
   * user_tax_form_associations deleteMany
   */
  export type user_tax_form_associationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_tax_form_associations to delete
     */
    where?: user_tax_form_associationsWhereInput
    /**
     * Limit how many user_tax_form_associations to delete.
     */
    limit?: number
  }

  /**
   * user_tax_form_associations without action
   */
  export type user_tax_form_associationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_tax_form_associations
     */
    select?: user_tax_form_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_tax_form_associations
     */
    omit?: user_tax_form_associationsOmit<ExtArgs> | null
  }


  /**
   * Model winnings
   */

  export type AggregateWinnings = {
    _count: WinningsCountAggregateOutputType | null
    _avg: WinningsAvgAggregateOutputType | null
    _sum: WinningsSumAggregateOutputType | null
    _min: WinningsMinAggregateOutputType | null
    _max: WinningsMaxAggregateOutputType | null
  }

  export type WinningsAvgAggregateOutputType = {
    origin_id: number | null
  }

  export type WinningsSumAggregateOutputType = {
    origin_id: number | null
  }

  export type WinningsMinAggregateOutputType = {
    winning_id: string | null
    winner_id: string | null
    type: $Enums.winnings_type | null
    origin_id: number | null
    category: $Enums.winnings_category | null
    title: string | null
    description: string | null
    external_id: string | null
    created_by: string | null
    updated_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WinningsMaxAggregateOutputType = {
    winning_id: string | null
    winner_id: string | null
    type: $Enums.winnings_type | null
    origin_id: number | null
    category: $Enums.winnings_category | null
    title: string | null
    description: string | null
    external_id: string | null
    created_by: string | null
    updated_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WinningsCountAggregateOutputType = {
    winning_id: number
    winner_id: number
    type: number
    origin_id: number
    category: number
    title: number
    description: number
    external_id: number
    attributes: number
    created_by: number
    updated_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type WinningsAvgAggregateInputType = {
    origin_id?: true
  }

  export type WinningsSumAggregateInputType = {
    origin_id?: true
  }

  export type WinningsMinAggregateInputType = {
    winning_id?: true
    winner_id?: true
    type?: true
    origin_id?: true
    category?: true
    title?: true
    description?: true
    external_id?: true
    created_by?: true
    updated_by?: true
    created_at?: true
    updated_at?: true
  }

  export type WinningsMaxAggregateInputType = {
    winning_id?: true
    winner_id?: true
    type?: true
    origin_id?: true
    category?: true
    title?: true
    description?: true
    external_id?: true
    created_by?: true
    updated_by?: true
    created_at?: true
    updated_at?: true
  }

  export type WinningsCountAggregateInputType = {
    winning_id?: true
    winner_id?: true
    type?: true
    origin_id?: true
    category?: true
    title?: true
    description?: true
    external_id?: true
    attributes?: true
    created_by?: true
    updated_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type WinningsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which winnings to aggregate.
     */
    where?: winningsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of winnings to fetch.
     */
    orderBy?: winningsOrderByWithRelationInput | winningsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: winningsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` winnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` winnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned winnings
    **/
    _count?: true | WinningsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WinningsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WinningsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WinningsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WinningsMaxAggregateInputType
  }

  export type GetWinningsAggregateType<T extends WinningsAggregateArgs> = {
        [P in keyof T & keyof AggregateWinnings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWinnings[P]>
      : GetScalarType<T[P], AggregateWinnings[P]>
  }




  export type winningsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: winningsWhereInput
    orderBy?: winningsOrderByWithAggregationInput | winningsOrderByWithAggregationInput[]
    by: WinningsScalarFieldEnum[] | WinningsScalarFieldEnum
    having?: winningsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WinningsCountAggregateInputType | true
    _avg?: WinningsAvgAggregateInputType
    _sum?: WinningsSumAggregateInputType
    _min?: WinningsMinAggregateInputType
    _max?: WinningsMaxAggregateInputType
  }

  export type WinningsGroupByOutputType = {
    winning_id: string
    winner_id: string
    type: $Enums.winnings_type
    origin_id: number | null
    category: $Enums.winnings_category | null
    title: string | null
    description: string | null
    external_id: string | null
    attributes: JsonValue | null
    created_by: string
    updated_by: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: WinningsCountAggregateOutputType | null
    _avg: WinningsAvgAggregateOutputType | null
    _sum: WinningsSumAggregateOutputType | null
    _min: WinningsMinAggregateOutputType | null
    _max: WinningsMaxAggregateOutputType | null
  }

  type GetWinningsGroupByPayload<T extends winningsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WinningsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WinningsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WinningsGroupByOutputType[P]>
            : GetScalarType<T[P], WinningsGroupByOutputType[P]>
        }
      >
    >


  export type winningsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    winning_id?: boolean
    winner_id?: boolean
    type?: boolean
    origin_id?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    external_id?: boolean
    attributes?: boolean
    created_by?: boolean
    updated_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    audit?: boolean | winnings$auditArgs<ExtArgs>
    payment?: boolean | winnings$paymentArgs<ExtArgs>
    origin?: boolean | winnings$originArgs<ExtArgs>
    _count?: boolean | WinningsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["winnings"]>

  export type winningsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    winning_id?: boolean
    winner_id?: boolean
    type?: boolean
    origin_id?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    external_id?: boolean
    attributes?: boolean
    created_by?: boolean
    updated_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    origin?: boolean | winnings$originArgs<ExtArgs>
  }, ExtArgs["result"]["winnings"]>

  export type winningsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    winning_id?: boolean
    winner_id?: boolean
    type?: boolean
    origin_id?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    external_id?: boolean
    attributes?: boolean
    created_by?: boolean
    updated_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    origin?: boolean | winnings$originArgs<ExtArgs>
  }, ExtArgs["result"]["winnings"]>

  export type winningsSelectScalar = {
    winning_id?: boolean
    winner_id?: boolean
    type?: boolean
    origin_id?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    external_id?: boolean
    attributes?: boolean
    created_by?: boolean
    updated_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type winningsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"winning_id" | "winner_id" | "type" | "origin_id" | "category" | "title" | "description" | "external_id" | "attributes" | "created_by" | "updated_by" | "created_at" | "updated_at", ExtArgs["result"]["winnings"]>
  export type winningsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | winnings$auditArgs<ExtArgs>
    payment?: boolean | winnings$paymentArgs<ExtArgs>
    origin?: boolean | winnings$originArgs<ExtArgs>
    _count?: boolean | WinningsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type winningsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    origin?: boolean | winnings$originArgs<ExtArgs>
  }
  export type winningsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    origin?: boolean | winnings$originArgs<ExtArgs>
  }

  export type $winningsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "winnings"
    objects: {
      audit: Prisma.$auditPayload<ExtArgs>[]
      payment: Prisma.$paymentPayload<ExtArgs>[]
      origin: Prisma.$originPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      winning_id: string
      winner_id: string
      type: $Enums.winnings_type
      origin_id: number | null
      category: $Enums.winnings_category | null
      title: string | null
      description: string | null
      external_id: string | null
      attributes: Prisma.JsonValue | null
      created_by: string
      updated_by: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["winnings"]>
    composites: {}
  }

  type winningsGetPayload<S extends boolean | null | undefined | winningsDefaultArgs> = $Result.GetResult<Prisma.$winningsPayload, S>

  type winningsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<winningsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WinningsCountAggregateInputType | true
    }

  export interface winningsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['winnings'], meta: { name: 'winnings' } }
    /**
     * Find zero or one Winnings that matches the filter.
     * @param {winningsFindUniqueArgs} args - Arguments to find a Winnings
     * @example
     * // Get one Winnings
     * const winnings = await prisma.winnings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends winningsFindUniqueArgs>(args: SelectSubset<T, winningsFindUniqueArgs<ExtArgs>>): Prisma__winningsClient<$Result.GetResult<Prisma.$winningsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Winnings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {winningsFindUniqueOrThrowArgs} args - Arguments to find a Winnings
     * @example
     * // Get one Winnings
     * const winnings = await prisma.winnings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends winningsFindUniqueOrThrowArgs>(args: SelectSubset<T, winningsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__winningsClient<$Result.GetResult<Prisma.$winningsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Winnings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {winningsFindFirstArgs} args - Arguments to find a Winnings
     * @example
     * // Get one Winnings
     * const winnings = await prisma.winnings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends winningsFindFirstArgs>(args?: SelectSubset<T, winningsFindFirstArgs<ExtArgs>>): Prisma__winningsClient<$Result.GetResult<Prisma.$winningsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Winnings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {winningsFindFirstOrThrowArgs} args - Arguments to find a Winnings
     * @example
     * // Get one Winnings
     * const winnings = await prisma.winnings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends winningsFindFirstOrThrowArgs>(args?: SelectSubset<T, winningsFindFirstOrThrowArgs<ExtArgs>>): Prisma__winningsClient<$Result.GetResult<Prisma.$winningsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Winnings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {winningsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Winnings
     * const winnings = await prisma.winnings.findMany()
     * 
     * // Get first 10 Winnings
     * const winnings = await prisma.winnings.findMany({ take: 10 })
     * 
     * // Only select the `winning_id`
     * const winningsWithWinning_idOnly = await prisma.winnings.findMany({ select: { winning_id: true } })
     * 
     */
    findMany<T extends winningsFindManyArgs>(args?: SelectSubset<T, winningsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$winningsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Winnings.
     * @param {winningsCreateArgs} args - Arguments to create a Winnings.
     * @example
     * // Create one Winnings
     * const Winnings = await prisma.winnings.create({
     *   data: {
     *     // ... data to create a Winnings
     *   }
     * })
     * 
     */
    create<T extends winningsCreateArgs>(args: SelectSubset<T, winningsCreateArgs<ExtArgs>>): Prisma__winningsClient<$Result.GetResult<Prisma.$winningsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Winnings.
     * @param {winningsCreateManyArgs} args - Arguments to create many Winnings.
     * @example
     * // Create many Winnings
     * const winnings = await prisma.winnings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends winningsCreateManyArgs>(args?: SelectSubset<T, winningsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Winnings and returns the data saved in the database.
     * @param {winningsCreateManyAndReturnArgs} args - Arguments to create many Winnings.
     * @example
     * // Create many Winnings
     * const winnings = await prisma.winnings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Winnings and only return the `winning_id`
     * const winningsWithWinning_idOnly = await prisma.winnings.createManyAndReturn({
     *   select: { winning_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends winningsCreateManyAndReturnArgs>(args?: SelectSubset<T, winningsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$winningsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Winnings.
     * @param {winningsDeleteArgs} args - Arguments to delete one Winnings.
     * @example
     * // Delete one Winnings
     * const Winnings = await prisma.winnings.delete({
     *   where: {
     *     // ... filter to delete one Winnings
     *   }
     * })
     * 
     */
    delete<T extends winningsDeleteArgs>(args: SelectSubset<T, winningsDeleteArgs<ExtArgs>>): Prisma__winningsClient<$Result.GetResult<Prisma.$winningsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Winnings.
     * @param {winningsUpdateArgs} args - Arguments to update one Winnings.
     * @example
     * // Update one Winnings
     * const winnings = await prisma.winnings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends winningsUpdateArgs>(args: SelectSubset<T, winningsUpdateArgs<ExtArgs>>): Prisma__winningsClient<$Result.GetResult<Prisma.$winningsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Winnings.
     * @param {winningsDeleteManyArgs} args - Arguments to filter Winnings to delete.
     * @example
     * // Delete a few Winnings
     * const { count } = await prisma.winnings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends winningsDeleteManyArgs>(args?: SelectSubset<T, winningsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Winnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {winningsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Winnings
     * const winnings = await prisma.winnings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends winningsUpdateManyArgs>(args: SelectSubset<T, winningsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Winnings and returns the data updated in the database.
     * @param {winningsUpdateManyAndReturnArgs} args - Arguments to update many Winnings.
     * @example
     * // Update many Winnings
     * const winnings = await prisma.winnings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Winnings and only return the `winning_id`
     * const winningsWithWinning_idOnly = await prisma.winnings.updateManyAndReturn({
     *   select: { winning_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends winningsUpdateManyAndReturnArgs>(args: SelectSubset<T, winningsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$winningsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Winnings.
     * @param {winningsUpsertArgs} args - Arguments to update or create a Winnings.
     * @example
     * // Update or create a Winnings
     * const winnings = await prisma.winnings.upsert({
     *   create: {
     *     // ... data to create a Winnings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Winnings we want to update
     *   }
     * })
     */
    upsert<T extends winningsUpsertArgs>(args: SelectSubset<T, winningsUpsertArgs<ExtArgs>>): Prisma__winningsClient<$Result.GetResult<Prisma.$winningsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Winnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {winningsCountArgs} args - Arguments to filter Winnings to count.
     * @example
     * // Count the number of Winnings
     * const count = await prisma.winnings.count({
     *   where: {
     *     // ... the filter for the Winnings we want to count
     *   }
     * })
    **/
    count<T extends winningsCountArgs>(
      args?: Subset<T, winningsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WinningsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Winnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WinningsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WinningsAggregateArgs>(args: Subset<T, WinningsAggregateArgs>): Prisma.PrismaPromise<GetWinningsAggregateType<T>>

    /**
     * Group by Winnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {winningsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends winningsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: winningsGroupByArgs['orderBy'] }
        : { orderBy?: winningsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, winningsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWinningsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the winnings model
   */
  readonly fields: winningsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for winnings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__winningsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    audit<T extends winnings$auditArgs<ExtArgs> = {}>(args?: Subset<T, winnings$auditArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payment<T extends winnings$paymentArgs<ExtArgs> = {}>(args?: Subset<T, winnings$paymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    origin<T extends winnings$originArgs<ExtArgs> = {}>(args?: Subset<T, winnings$originArgs<ExtArgs>>): Prisma__originClient<$Result.GetResult<Prisma.$originPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the winnings model
   */
  interface winningsFieldRefs {
    readonly winning_id: FieldRef<"winnings", 'String'>
    readonly winner_id: FieldRef<"winnings", 'String'>
    readonly type: FieldRef<"winnings", 'winnings_type'>
    readonly origin_id: FieldRef<"winnings", 'Int'>
    readonly category: FieldRef<"winnings", 'winnings_category'>
    readonly title: FieldRef<"winnings", 'String'>
    readonly description: FieldRef<"winnings", 'String'>
    readonly external_id: FieldRef<"winnings", 'String'>
    readonly attributes: FieldRef<"winnings", 'Json'>
    readonly created_by: FieldRef<"winnings", 'String'>
    readonly updated_by: FieldRef<"winnings", 'String'>
    readonly created_at: FieldRef<"winnings", 'DateTime'>
    readonly updated_at: FieldRef<"winnings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * winnings findUnique
   */
  export type winningsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the winnings
     */
    select?: winningsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the winnings
     */
    omit?: winningsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: winningsInclude<ExtArgs> | null
    /**
     * Filter, which winnings to fetch.
     */
    where: winningsWhereUniqueInput
  }

  /**
   * winnings findUniqueOrThrow
   */
  export type winningsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the winnings
     */
    select?: winningsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the winnings
     */
    omit?: winningsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: winningsInclude<ExtArgs> | null
    /**
     * Filter, which winnings to fetch.
     */
    where: winningsWhereUniqueInput
  }

  /**
   * winnings findFirst
   */
  export type winningsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the winnings
     */
    select?: winningsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the winnings
     */
    omit?: winningsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: winningsInclude<ExtArgs> | null
    /**
     * Filter, which winnings to fetch.
     */
    where?: winningsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of winnings to fetch.
     */
    orderBy?: winningsOrderByWithRelationInput | winningsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for winnings.
     */
    cursor?: winningsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` winnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` winnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of winnings.
     */
    distinct?: WinningsScalarFieldEnum | WinningsScalarFieldEnum[]
  }

  /**
   * winnings findFirstOrThrow
   */
  export type winningsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the winnings
     */
    select?: winningsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the winnings
     */
    omit?: winningsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: winningsInclude<ExtArgs> | null
    /**
     * Filter, which winnings to fetch.
     */
    where?: winningsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of winnings to fetch.
     */
    orderBy?: winningsOrderByWithRelationInput | winningsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for winnings.
     */
    cursor?: winningsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` winnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` winnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of winnings.
     */
    distinct?: WinningsScalarFieldEnum | WinningsScalarFieldEnum[]
  }

  /**
   * winnings findMany
   */
  export type winningsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the winnings
     */
    select?: winningsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the winnings
     */
    omit?: winningsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: winningsInclude<ExtArgs> | null
    /**
     * Filter, which winnings to fetch.
     */
    where?: winningsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of winnings to fetch.
     */
    orderBy?: winningsOrderByWithRelationInput | winningsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing winnings.
     */
    cursor?: winningsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` winnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` winnings.
     */
    skip?: number
    distinct?: WinningsScalarFieldEnum | WinningsScalarFieldEnum[]
  }

  /**
   * winnings create
   */
  export type winningsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the winnings
     */
    select?: winningsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the winnings
     */
    omit?: winningsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: winningsInclude<ExtArgs> | null
    /**
     * The data needed to create a winnings.
     */
    data: XOR<winningsCreateInput, winningsUncheckedCreateInput>
  }

  /**
   * winnings createMany
   */
  export type winningsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many winnings.
     */
    data: winningsCreateManyInput | winningsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * winnings createManyAndReturn
   */
  export type winningsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the winnings
     */
    select?: winningsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the winnings
     */
    omit?: winningsOmit<ExtArgs> | null
    /**
     * The data used to create many winnings.
     */
    data: winningsCreateManyInput | winningsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: winningsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * winnings update
   */
  export type winningsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the winnings
     */
    select?: winningsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the winnings
     */
    omit?: winningsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: winningsInclude<ExtArgs> | null
    /**
     * The data needed to update a winnings.
     */
    data: XOR<winningsUpdateInput, winningsUncheckedUpdateInput>
    /**
     * Choose, which winnings to update.
     */
    where: winningsWhereUniqueInput
  }

  /**
   * winnings updateMany
   */
  export type winningsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update winnings.
     */
    data: XOR<winningsUpdateManyMutationInput, winningsUncheckedUpdateManyInput>
    /**
     * Filter which winnings to update
     */
    where?: winningsWhereInput
    /**
     * Limit how many winnings to update.
     */
    limit?: number
  }

  /**
   * winnings updateManyAndReturn
   */
  export type winningsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the winnings
     */
    select?: winningsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the winnings
     */
    omit?: winningsOmit<ExtArgs> | null
    /**
     * The data used to update winnings.
     */
    data: XOR<winningsUpdateManyMutationInput, winningsUncheckedUpdateManyInput>
    /**
     * Filter which winnings to update
     */
    where?: winningsWhereInput
    /**
     * Limit how many winnings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: winningsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * winnings upsert
   */
  export type winningsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the winnings
     */
    select?: winningsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the winnings
     */
    omit?: winningsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: winningsInclude<ExtArgs> | null
    /**
     * The filter to search for the winnings to update in case it exists.
     */
    where: winningsWhereUniqueInput
    /**
     * In case the winnings found by the `where` argument doesn't exist, create a new winnings with this data.
     */
    create: XOR<winningsCreateInput, winningsUncheckedCreateInput>
    /**
     * In case the winnings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<winningsUpdateInput, winningsUncheckedUpdateInput>
  }

  /**
   * winnings delete
   */
  export type winningsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the winnings
     */
    select?: winningsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the winnings
     */
    omit?: winningsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: winningsInclude<ExtArgs> | null
    /**
     * Filter which winnings to delete.
     */
    where: winningsWhereUniqueInput
  }

  /**
   * winnings deleteMany
   */
  export type winningsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which winnings to delete
     */
    where?: winningsWhereInput
    /**
     * Limit how many winnings to delete.
     */
    limit?: number
  }

  /**
   * winnings.audit
   */
  export type winnings$auditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit
     */
    select?: auditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit
     */
    omit?: auditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditInclude<ExtArgs> | null
    where?: auditWhereInput
    orderBy?: auditOrderByWithRelationInput | auditOrderByWithRelationInput[]
    cursor?: auditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * winnings.payment
   */
  export type winnings$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    where?: paymentWhereInput
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    cursor?: paymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * winnings.origin
   */
  export type winnings$originArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the origin
     */
    select?: originSelect<ExtArgs> | null
    /**
     * Omit specific fields from the origin
     */
    omit?: originOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: originInclude<ExtArgs> | null
    where?: originWhereInput
  }

  /**
   * winnings without action
   */
  export type winningsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the winnings
     */
    select?: winningsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the winnings
     */
    omit?: winningsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: winningsInclude<ExtArgs> | null
  }


  /**
   * Model trolley_recipient
   */

  export type AggregateTrolley_recipient = {
    _count: Trolley_recipientCountAggregateOutputType | null
    _avg: Trolley_recipientAvgAggregateOutputType | null
    _sum: Trolley_recipientSumAggregateOutputType | null
    _min: Trolley_recipientMinAggregateOutputType | null
    _max: Trolley_recipientMaxAggregateOutputType | null
  }

  export type Trolley_recipientAvgAggregateOutputType = {
    id: number | null
  }

  export type Trolley_recipientSumAggregateOutputType = {
    id: number | null
  }

  export type Trolley_recipientMinAggregateOutputType = {
    id: number | null
    user_payment_method_id: string | null
    user_id: string | null
    trolley_id: string | null
  }

  export type Trolley_recipientMaxAggregateOutputType = {
    id: number | null
    user_payment_method_id: string | null
    user_id: string | null
    trolley_id: string | null
  }

  export type Trolley_recipientCountAggregateOutputType = {
    id: number
    user_payment_method_id: number
    user_id: number
    trolley_id: number
    _all: number
  }


  export type Trolley_recipientAvgAggregateInputType = {
    id?: true
  }

  export type Trolley_recipientSumAggregateInputType = {
    id?: true
  }

  export type Trolley_recipientMinAggregateInputType = {
    id?: true
    user_payment_method_id?: true
    user_id?: true
    trolley_id?: true
  }

  export type Trolley_recipientMaxAggregateInputType = {
    id?: true
    user_payment_method_id?: true
    user_id?: true
    trolley_id?: true
  }

  export type Trolley_recipientCountAggregateInputType = {
    id?: true
    user_payment_method_id?: true
    user_id?: true
    trolley_id?: true
    _all?: true
  }

  export type Trolley_recipientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trolley_recipient to aggregate.
     */
    where?: trolley_recipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trolley_recipients to fetch.
     */
    orderBy?: trolley_recipientOrderByWithRelationInput | trolley_recipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: trolley_recipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trolley_recipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trolley_recipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trolley_recipients
    **/
    _count?: true | Trolley_recipientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Trolley_recipientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Trolley_recipientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Trolley_recipientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Trolley_recipientMaxAggregateInputType
  }

  export type GetTrolley_recipientAggregateType<T extends Trolley_recipientAggregateArgs> = {
        [P in keyof T & keyof AggregateTrolley_recipient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrolley_recipient[P]>
      : GetScalarType<T[P], AggregateTrolley_recipient[P]>
  }




  export type trolley_recipientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: trolley_recipientWhereInput
    orderBy?: trolley_recipientOrderByWithAggregationInput | trolley_recipientOrderByWithAggregationInput[]
    by: Trolley_recipientScalarFieldEnum[] | Trolley_recipientScalarFieldEnum
    having?: trolley_recipientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Trolley_recipientCountAggregateInputType | true
    _avg?: Trolley_recipientAvgAggregateInputType
    _sum?: Trolley_recipientSumAggregateInputType
    _min?: Trolley_recipientMinAggregateInputType
    _max?: Trolley_recipientMaxAggregateInputType
  }

  export type Trolley_recipientGroupByOutputType = {
    id: number
    user_payment_method_id: string
    user_id: string
    trolley_id: string
    _count: Trolley_recipientCountAggregateOutputType | null
    _avg: Trolley_recipientAvgAggregateOutputType | null
    _sum: Trolley_recipientSumAggregateOutputType | null
    _min: Trolley_recipientMinAggregateOutputType | null
    _max: Trolley_recipientMaxAggregateOutputType | null
  }

  type GetTrolley_recipientGroupByPayload<T extends trolley_recipientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Trolley_recipientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Trolley_recipientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Trolley_recipientGroupByOutputType[P]>
            : GetScalarType<T[P], Trolley_recipientGroupByOutputType[P]>
        }
      >
    >


  export type trolley_recipientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_payment_method_id?: boolean
    user_id?: boolean
    trolley_id?: boolean
    trolley_recipient_payment_methods?: boolean | trolley_recipient$trolley_recipient_payment_methodsArgs<ExtArgs>
    user_payment_methods?: boolean | user_payment_methodsDefaultArgs<ExtArgs>
    _count?: boolean | Trolley_recipientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trolley_recipient"]>

  export type trolley_recipientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_payment_method_id?: boolean
    user_id?: boolean
    trolley_id?: boolean
    user_payment_methods?: boolean | user_payment_methodsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trolley_recipient"]>

  export type trolley_recipientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_payment_method_id?: boolean
    user_id?: boolean
    trolley_id?: boolean
    user_payment_methods?: boolean | user_payment_methodsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trolley_recipient"]>

  export type trolley_recipientSelectScalar = {
    id?: boolean
    user_payment_method_id?: boolean
    user_id?: boolean
    trolley_id?: boolean
  }

  export type trolley_recipientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_payment_method_id" | "user_id" | "trolley_id", ExtArgs["result"]["trolley_recipient"]>
  export type trolley_recipientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trolley_recipient_payment_methods?: boolean | trolley_recipient$trolley_recipient_payment_methodsArgs<ExtArgs>
    user_payment_methods?: boolean | user_payment_methodsDefaultArgs<ExtArgs>
    _count?: boolean | Trolley_recipientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type trolley_recipientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_payment_methods?: boolean | user_payment_methodsDefaultArgs<ExtArgs>
  }
  export type trolley_recipientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_payment_methods?: boolean | user_payment_methodsDefaultArgs<ExtArgs>
  }

  export type $trolley_recipientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "trolley_recipient"
    objects: {
      trolley_recipient_payment_methods: Prisma.$trolley_recipient_payment_methodPayload<ExtArgs>[]
      user_payment_methods: Prisma.$user_payment_methodsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_payment_method_id: string
      user_id: string
      trolley_id: string
    }, ExtArgs["result"]["trolley_recipient"]>
    composites: {}
  }

  type trolley_recipientGetPayload<S extends boolean | null | undefined | trolley_recipientDefaultArgs> = $Result.GetResult<Prisma.$trolley_recipientPayload, S>

  type trolley_recipientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<trolley_recipientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Trolley_recipientCountAggregateInputType | true
    }

  export interface trolley_recipientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['trolley_recipient'], meta: { name: 'trolley_recipient' } }
    /**
     * Find zero or one Trolley_recipient that matches the filter.
     * @param {trolley_recipientFindUniqueArgs} args - Arguments to find a Trolley_recipient
     * @example
     * // Get one Trolley_recipient
     * const trolley_recipient = await prisma.trolley_recipient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends trolley_recipientFindUniqueArgs>(args: SelectSubset<T, trolley_recipientFindUniqueArgs<ExtArgs>>): Prisma__trolley_recipientClient<$Result.GetResult<Prisma.$trolley_recipientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Trolley_recipient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {trolley_recipientFindUniqueOrThrowArgs} args - Arguments to find a Trolley_recipient
     * @example
     * // Get one Trolley_recipient
     * const trolley_recipient = await prisma.trolley_recipient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends trolley_recipientFindUniqueOrThrowArgs>(args: SelectSubset<T, trolley_recipientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__trolley_recipientClient<$Result.GetResult<Prisma.$trolley_recipientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trolley_recipient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trolley_recipientFindFirstArgs} args - Arguments to find a Trolley_recipient
     * @example
     * // Get one Trolley_recipient
     * const trolley_recipient = await prisma.trolley_recipient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends trolley_recipientFindFirstArgs>(args?: SelectSubset<T, trolley_recipientFindFirstArgs<ExtArgs>>): Prisma__trolley_recipientClient<$Result.GetResult<Prisma.$trolley_recipientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trolley_recipient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trolley_recipientFindFirstOrThrowArgs} args - Arguments to find a Trolley_recipient
     * @example
     * // Get one Trolley_recipient
     * const trolley_recipient = await prisma.trolley_recipient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends trolley_recipientFindFirstOrThrowArgs>(args?: SelectSubset<T, trolley_recipientFindFirstOrThrowArgs<ExtArgs>>): Prisma__trolley_recipientClient<$Result.GetResult<Prisma.$trolley_recipientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Trolley_recipients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trolley_recipientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trolley_recipients
     * const trolley_recipients = await prisma.trolley_recipient.findMany()
     * 
     * // Get first 10 Trolley_recipients
     * const trolley_recipients = await prisma.trolley_recipient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trolley_recipientWithIdOnly = await prisma.trolley_recipient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends trolley_recipientFindManyArgs>(args?: SelectSubset<T, trolley_recipientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trolley_recipientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Trolley_recipient.
     * @param {trolley_recipientCreateArgs} args - Arguments to create a Trolley_recipient.
     * @example
     * // Create one Trolley_recipient
     * const Trolley_recipient = await prisma.trolley_recipient.create({
     *   data: {
     *     // ... data to create a Trolley_recipient
     *   }
     * })
     * 
     */
    create<T extends trolley_recipientCreateArgs>(args: SelectSubset<T, trolley_recipientCreateArgs<ExtArgs>>): Prisma__trolley_recipientClient<$Result.GetResult<Prisma.$trolley_recipientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Trolley_recipients.
     * @param {trolley_recipientCreateManyArgs} args - Arguments to create many Trolley_recipients.
     * @example
     * // Create many Trolley_recipients
     * const trolley_recipient = await prisma.trolley_recipient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends trolley_recipientCreateManyArgs>(args?: SelectSubset<T, trolley_recipientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trolley_recipients and returns the data saved in the database.
     * @param {trolley_recipientCreateManyAndReturnArgs} args - Arguments to create many Trolley_recipients.
     * @example
     * // Create many Trolley_recipients
     * const trolley_recipient = await prisma.trolley_recipient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trolley_recipients and only return the `id`
     * const trolley_recipientWithIdOnly = await prisma.trolley_recipient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends trolley_recipientCreateManyAndReturnArgs>(args?: SelectSubset<T, trolley_recipientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trolley_recipientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Trolley_recipient.
     * @param {trolley_recipientDeleteArgs} args - Arguments to delete one Trolley_recipient.
     * @example
     * // Delete one Trolley_recipient
     * const Trolley_recipient = await prisma.trolley_recipient.delete({
     *   where: {
     *     // ... filter to delete one Trolley_recipient
     *   }
     * })
     * 
     */
    delete<T extends trolley_recipientDeleteArgs>(args: SelectSubset<T, trolley_recipientDeleteArgs<ExtArgs>>): Prisma__trolley_recipientClient<$Result.GetResult<Prisma.$trolley_recipientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Trolley_recipient.
     * @param {trolley_recipientUpdateArgs} args - Arguments to update one Trolley_recipient.
     * @example
     * // Update one Trolley_recipient
     * const trolley_recipient = await prisma.trolley_recipient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends trolley_recipientUpdateArgs>(args: SelectSubset<T, trolley_recipientUpdateArgs<ExtArgs>>): Prisma__trolley_recipientClient<$Result.GetResult<Prisma.$trolley_recipientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Trolley_recipients.
     * @param {trolley_recipientDeleteManyArgs} args - Arguments to filter Trolley_recipients to delete.
     * @example
     * // Delete a few Trolley_recipients
     * const { count } = await prisma.trolley_recipient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends trolley_recipientDeleteManyArgs>(args?: SelectSubset<T, trolley_recipientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trolley_recipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trolley_recipientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trolley_recipients
     * const trolley_recipient = await prisma.trolley_recipient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends trolley_recipientUpdateManyArgs>(args: SelectSubset<T, trolley_recipientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trolley_recipients and returns the data updated in the database.
     * @param {trolley_recipientUpdateManyAndReturnArgs} args - Arguments to update many Trolley_recipients.
     * @example
     * // Update many Trolley_recipients
     * const trolley_recipient = await prisma.trolley_recipient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Trolley_recipients and only return the `id`
     * const trolley_recipientWithIdOnly = await prisma.trolley_recipient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends trolley_recipientUpdateManyAndReturnArgs>(args: SelectSubset<T, trolley_recipientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trolley_recipientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Trolley_recipient.
     * @param {trolley_recipientUpsertArgs} args - Arguments to update or create a Trolley_recipient.
     * @example
     * // Update or create a Trolley_recipient
     * const trolley_recipient = await prisma.trolley_recipient.upsert({
     *   create: {
     *     // ... data to create a Trolley_recipient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trolley_recipient we want to update
     *   }
     * })
     */
    upsert<T extends trolley_recipientUpsertArgs>(args: SelectSubset<T, trolley_recipientUpsertArgs<ExtArgs>>): Prisma__trolley_recipientClient<$Result.GetResult<Prisma.$trolley_recipientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Trolley_recipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trolley_recipientCountArgs} args - Arguments to filter Trolley_recipients to count.
     * @example
     * // Count the number of Trolley_recipients
     * const count = await prisma.trolley_recipient.count({
     *   where: {
     *     // ... the filter for the Trolley_recipients we want to count
     *   }
     * })
    **/
    count<T extends trolley_recipientCountArgs>(
      args?: Subset<T, trolley_recipientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Trolley_recipientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trolley_recipient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Trolley_recipientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Trolley_recipientAggregateArgs>(args: Subset<T, Trolley_recipientAggregateArgs>): Prisma.PrismaPromise<GetTrolley_recipientAggregateType<T>>

    /**
     * Group by Trolley_recipient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trolley_recipientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends trolley_recipientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: trolley_recipientGroupByArgs['orderBy'] }
        : { orderBy?: trolley_recipientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, trolley_recipientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrolley_recipientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the trolley_recipient model
   */
  readonly fields: trolley_recipientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for trolley_recipient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__trolley_recipientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trolley_recipient_payment_methods<T extends trolley_recipient$trolley_recipient_payment_methodsArgs<ExtArgs> = {}>(args?: Subset<T, trolley_recipient$trolley_recipient_payment_methodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trolley_recipient_payment_methodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_payment_methods<T extends user_payment_methodsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, user_payment_methodsDefaultArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the trolley_recipient model
   */
  interface trolley_recipientFieldRefs {
    readonly id: FieldRef<"trolley_recipient", 'Int'>
    readonly user_payment_method_id: FieldRef<"trolley_recipient", 'String'>
    readonly user_id: FieldRef<"trolley_recipient", 'String'>
    readonly trolley_id: FieldRef<"trolley_recipient", 'String'>
  }
    

  // Custom InputTypes
  /**
   * trolley_recipient findUnique
   */
  export type trolley_recipientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient
     */
    select?: trolley_recipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient
     */
    omit?: trolley_recipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipientInclude<ExtArgs> | null
    /**
     * Filter, which trolley_recipient to fetch.
     */
    where: trolley_recipientWhereUniqueInput
  }

  /**
   * trolley_recipient findUniqueOrThrow
   */
  export type trolley_recipientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient
     */
    select?: trolley_recipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient
     */
    omit?: trolley_recipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipientInclude<ExtArgs> | null
    /**
     * Filter, which trolley_recipient to fetch.
     */
    where: trolley_recipientWhereUniqueInput
  }

  /**
   * trolley_recipient findFirst
   */
  export type trolley_recipientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient
     */
    select?: trolley_recipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient
     */
    omit?: trolley_recipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipientInclude<ExtArgs> | null
    /**
     * Filter, which trolley_recipient to fetch.
     */
    where?: trolley_recipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trolley_recipients to fetch.
     */
    orderBy?: trolley_recipientOrderByWithRelationInput | trolley_recipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trolley_recipients.
     */
    cursor?: trolley_recipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trolley_recipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trolley_recipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trolley_recipients.
     */
    distinct?: Trolley_recipientScalarFieldEnum | Trolley_recipientScalarFieldEnum[]
  }

  /**
   * trolley_recipient findFirstOrThrow
   */
  export type trolley_recipientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient
     */
    select?: trolley_recipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient
     */
    omit?: trolley_recipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipientInclude<ExtArgs> | null
    /**
     * Filter, which trolley_recipient to fetch.
     */
    where?: trolley_recipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trolley_recipients to fetch.
     */
    orderBy?: trolley_recipientOrderByWithRelationInput | trolley_recipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trolley_recipients.
     */
    cursor?: trolley_recipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trolley_recipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trolley_recipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trolley_recipients.
     */
    distinct?: Trolley_recipientScalarFieldEnum | Trolley_recipientScalarFieldEnum[]
  }

  /**
   * trolley_recipient findMany
   */
  export type trolley_recipientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient
     */
    select?: trolley_recipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient
     */
    omit?: trolley_recipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipientInclude<ExtArgs> | null
    /**
     * Filter, which trolley_recipients to fetch.
     */
    where?: trolley_recipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trolley_recipients to fetch.
     */
    orderBy?: trolley_recipientOrderByWithRelationInput | trolley_recipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trolley_recipients.
     */
    cursor?: trolley_recipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trolley_recipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trolley_recipients.
     */
    skip?: number
    distinct?: Trolley_recipientScalarFieldEnum | Trolley_recipientScalarFieldEnum[]
  }

  /**
   * trolley_recipient create
   */
  export type trolley_recipientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient
     */
    select?: trolley_recipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient
     */
    omit?: trolley_recipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipientInclude<ExtArgs> | null
    /**
     * The data needed to create a trolley_recipient.
     */
    data: XOR<trolley_recipientCreateInput, trolley_recipientUncheckedCreateInput>
  }

  /**
   * trolley_recipient createMany
   */
  export type trolley_recipientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many trolley_recipients.
     */
    data: trolley_recipientCreateManyInput | trolley_recipientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * trolley_recipient createManyAndReturn
   */
  export type trolley_recipientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient
     */
    select?: trolley_recipientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient
     */
    omit?: trolley_recipientOmit<ExtArgs> | null
    /**
     * The data used to create many trolley_recipients.
     */
    data: trolley_recipientCreateManyInput | trolley_recipientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * trolley_recipient update
   */
  export type trolley_recipientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient
     */
    select?: trolley_recipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient
     */
    omit?: trolley_recipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipientInclude<ExtArgs> | null
    /**
     * The data needed to update a trolley_recipient.
     */
    data: XOR<trolley_recipientUpdateInput, trolley_recipientUncheckedUpdateInput>
    /**
     * Choose, which trolley_recipient to update.
     */
    where: trolley_recipientWhereUniqueInput
  }

  /**
   * trolley_recipient updateMany
   */
  export type trolley_recipientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update trolley_recipients.
     */
    data: XOR<trolley_recipientUpdateManyMutationInput, trolley_recipientUncheckedUpdateManyInput>
    /**
     * Filter which trolley_recipients to update
     */
    where?: trolley_recipientWhereInput
    /**
     * Limit how many trolley_recipients to update.
     */
    limit?: number
  }

  /**
   * trolley_recipient updateManyAndReturn
   */
  export type trolley_recipientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient
     */
    select?: trolley_recipientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient
     */
    omit?: trolley_recipientOmit<ExtArgs> | null
    /**
     * The data used to update trolley_recipients.
     */
    data: XOR<trolley_recipientUpdateManyMutationInput, trolley_recipientUncheckedUpdateManyInput>
    /**
     * Filter which trolley_recipients to update
     */
    where?: trolley_recipientWhereInput
    /**
     * Limit how many trolley_recipients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * trolley_recipient upsert
   */
  export type trolley_recipientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient
     */
    select?: trolley_recipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient
     */
    omit?: trolley_recipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipientInclude<ExtArgs> | null
    /**
     * The filter to search for the trolley_recipient to update in case it exists.
     */
    where: trolley_recipientWhereUniqueInput
    /**
     * In case the trolley_recipient found by the `where` argument doesn't exist, create a new trolley_recipient with this data.
     */
    create: XOR<trolley_recipientCreateInput, trolley_recipientUncheckedCreateInput>
    /**
     * In case the trolley_recipient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<trolley_recipientUpdateInput, trolley_recipientUncheckedUpdateInput>
  }

  /**
   * trolley_recipient delete
   */
  export type trolley_recipientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient
     */
    select?: trolley_recipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient
     */
    omit?: trolley_recipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipientInclude<ExtArgs> | null
    /**
     * Filter which trolley_recipient to delete.
     */
    where: trolley_recipientWhereUniqueInput
  }

  /**
   * trolley_recipient deleteMany
   */
  export type trolley_recipientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trolley_recipients to delete
     */
    where?: trolley_recipientWhereInput
    /**
     * Limit how many trolley_recipients to delete.
     */
    limit?: number
  }

  /**
   * trolley_recipient.trolley_recipient_payment_methods
   */
  export type trolley_recipient$trolley_recipient_payment_methodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient_payment_method
     */
    select?: trolley_recipient_payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient_payment_method
     */
    omit?: trolley_recipient_payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipient_payment_methodInclude<ExtArgs> | null
    where?: trolley_recipient_payment_methodWhereInput
    orderBy?: trolley_recipient_payment_methodOrderByWithRelationInput | trolley_recipient_payment_methodOrderByWithRelationInput[]
    cursor?: trolley_recipient_payment_methodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Trolley_recipient_payment_methodScalarFieldEnum | Trolley_recipient_payment_methodScalarFieldEnum[]
  }

  /**
   * trolley_recipient without action
   */
  export type trolley_recipientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient
     */
    select?: trolley_recipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient
     */
    omit?: trolley_recipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipientInclude<ExtArgs> | null
  }


  /**
   * Model trolley_webhook_log
   */

  export type AggregateTrolley_webhook_log = {
    _count: Trolley_webhook_logCountAggregateOutputType | null
    _min: Trolley_webhook_logMinAggregateOutputType | null
    _max: Trolley_webhook_logMaxAggregateOutputType | null
  }

  export type Trolley_webhook_logMinAggregateOutputType = {
    id: string | null
    event_id: string | null
    event_time: Date | null
    event_model: string | null
    event_action: string | null
    status: $Enums.webhook_status | null
    error_message: string | null
    created_at: Date | null
  }

  export type Trolley_webhook_logMaxAggregateOutputType = {
    id: string | null
    event_id: string | null
    event_time: Date | null
    event_model: string | null
    event_action: string | null
    status: $Enums.webhook_status | null
    error_message: string | null
    created_at: Date | null
  }

  export type Trolley_webhook_logCountAggregateOutputType = {
    id: number
    event_id: number
    event_time: number
    event_payload: number
    event_model: number
    event_action: number
    status: number
    error_message: number
    created_at: number
    _all: number
  }


  export type Trolley_webhook_logMinAggregateInputType = {
    id?: true
    event_id?: true
    event_time?: true
    event_model?: true
    event_action?: true
    status?: true
    error_message?: true
    created_at?: true
  }

  export type Trolley_webhook_logMaxAggregateInputType = {
    id?: true
    event_id?: true
    event_time?: true
    event_model?: true
    event_action?: true
    status?: true
    error_message?: true
    created_at?: true
  }

  export type Trolley_webhook_logCountAggregateInputType = {
    id?: true
    event_id?: true
    event_time?: true
    event_payload?: true
    event_model?: true
    event_action?: true
    status?: true
    error_message?: true
    created_at?: true
    _all?: true
  }

  export type Trolley_webhook_logAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trolley_webhook_log to aggregate.
     */
    where?: trolley_webhook_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trolley_webhook_logs to fetch.
     */
    orderBy?: trolley_webhook_logOrderByWithRelationInput | trolley_webhook_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: trolley_webhook_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trolley_webhook_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trolley_webhook_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trolley_webhook_logs
    **/
    _count?: true | Trolley_webhook_logCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Trolley_webhook_logMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Trolley_webhook_logMaxAggregateInputType
  }

  export type GetTrolley_webhook_logAggregateType<T extends Trolley_webhook_logAggregateArgs> = {
        [P in keyof T & keyof AggregateTrolley_webhook_log]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrolley_webhook_log[P]>
      : GetScalarType<T[P], AggregateTrolley_webhook_log[P]>
  }




  export type trolley_webhook_logGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: trolley_webhook_logWhereInput
    orderBy?: trolley_webhook_logOrderByWithAggregationInput | trolley_webhook_logOrderByWithAggregationInput[]
    by: Trolley_webhook_logScalarFieldEnum[] | Trolley_webhook_logScalarFieldEnum
    having?: trolley_webhook_logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Trolley_webhook_logCountAggregateInputType | true
    _min?: Trolley_webhook_logMinAggregateInputType
    _max?: Trolley_webhook_logMaxAggregateInputType
  }

  export type Trolley_webhook_logGroupByOutputType = {
    id: string
    event_id: string
    event_time: Date
    event_payload: JsonValue
    event_model: string | null
    event_action: string | null
    status: $Enums.webhook_status
    error_message: string | null
    created_at: Date | null
    _count: Trolley_webhook_logCountAggregateOutputType | null
    _min: Trolley_webhook_logMinAggregateOutputType | null
    _max: Trolley_webhook_logMaxAggregateOutputType | null
  }

  type GetTrolley_webhook_logGroupByPayload<T extends trolley_webhook_logGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Trolley_webhook_logGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Trolley_webhook_logGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Trolley_webhook_logGroupByOutputType[P]>
            : GetScalarType<T[P], Trolley_webhook_logGroupByOutputType[P]>
        }
      >
    >


  export type trolley_webhook_logSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event_id?: boolean
    event_time?: boolean
    event_payload?: boolean
    event_model?: boolean
    event_action?: boolean
    status?: boolean
    error_message?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["trolley_webhook_log"]>

  export type trolley_webhook_logSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event_id?: boolean
    event_time?: boolean
    event_payload?: boolean
    event_model?: boolean
    event_action?: boolean
    status?: boolean
    error_message?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["trolley_webhook_log"]>

  export type trolley_webhook_logSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event_id?: boolean
    event_time?: boolean
    event_payload?: boolean
    event_model?: boolean
    event_action?: boolean
    status?: boolean
    error_message?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["trolley_webhook_log"]>

  export type trolley_webhook_logSelectScalar = {
    id?: boolean
    event_id?: boolean
    event_time?: boolean
    event_payload?: boolean
    event_model?: boolean
    event_action?: boolean
    status?: boolean
    error_message?: boolean
    created_at?: boolean
  }

  export type trolley_webhook_logOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "event_id" | "event_time" | "event_payload" | "event_model" | "event_action" | "status" | "error_message" | "created_at", ExtArgs["result"]["trolley_webhook_log"]>

  export type $trolley_webhook_logPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "trolley_webhook_log"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      event_id: string
      event_time: Date
      event_payload: Prisma.JsonValue
      event_model: string | null
      event_action: string | null
      status: $Enums.webhook_status
      error_message: string | null
      created_at: Date | null
    }, ExtArgs["result"]["trolley_webhook_log"]>
    composites: {}
  }

  type trolley_webhook_logGetPayload<S extends boolean | null | undefined | trolley_webhook_logDefaultArgs> = $Result.GetResult<Prisma.$trolley_webhook_logPayload, S>

  type trolley_webhook_logCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<trolley_webhook_logFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Trolley_webhook_logCountAggregateInputType | true
    }

  export interface trolley_webhook_logDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['trolley_webhook_log'], meta: { name: 'trolley_webhook_log' } }
    /**
     * Find zero or one Trolley_webhook_log that matches the filter.
     * @param {trolley_webhook_logFindUniqueArgs} args - Arguments to find a Trolley_webhook_log
     * @example
     * // Get one Trolley_webhook_log
     * const trolley_webhook_log = await prisma.trolley_webhook_log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends trolley_webhook_logFindUniqueArgs>(args: SelectSubset<T, trolley_webhook_logFindUniqueArgs<ExtArgs>>): Prisma__trolley_webhook_logClient<$Result.GetResult<Prisma.$trolley_webhook_logPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Trolley_webhook_log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {trolley_webhook_logFindUniqueOrThrowArgs} args - Arguments to find a Trolley_webhook_log
     * @example
     * // Get one Trolley_webhook_log
     * const trolley_webhook_log = await prisma.trolley_webhook_log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends trolley_webhook_logFindUniqueOrThrowArgs>(args: SelectSubset<T, trolley_webhook_logFindUniqueOrThrowArgs<ExtArgs>>): Prisma__trolley_webhook_logClient<$Result.GetResult<Prisma.$trolley_webhook_logPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trolley_webhook_log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trolley_webhook_logFindFirstArgs} args - Arguments to find a Trolley_webhook_log
     * @example
     * // Get one Trolley_webhook_log
     * const trolley_webhook_log = await prisma.trolley_webhook_log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends trolley_webhook_logFindFirstArgs>(args?: SelectSubset<T, trolley_webhook_logFindFirstArgs<ExtArgs>>): Prisma__trolley_webhook_logClient<$Result.GetResult<Prisma.$trolley_webhook_logPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trolley_webhook_log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trolley_webhook_logFindFirstOrThrowArgs} args - Arguments to find a Trolley_webhook_log
     * @example
     * // Get one Trolley_webhook_log
     * const trolley_webhook_log = await prisma.trolley_webhook_log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends trolley_webhook_logFindFirstOrThrowArgs>(args?: SelectSubset<T, trolley_webhook_logFindFirstOrThrowArgs<ExtArgs>>): Prisma__trolley_webhook_logClient<$Result.GetResult<Prisma.$trolley_webhook_logPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Trolley_webhook_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trolley_webhook_logFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trolley_webhook_logs
     * const trolley_webhook_logs = await prisma.trolley_webhook_log.findMany()
     * 
     * // Get first 10 Trolley_webhook_logs
     * const trolley_webhook_logs = await prisma.trolley_webhook_log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trolley_webhook_logWithIdOnly = await prisma.trolley_webhook_log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends trolley_webhook_logFindManyArgs>(args?: SelectSubset<T, trolley_webhook_logFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trolley_webhook_logPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Trolley_webhook_log.
     * @param {trolley_webhook_logCreateArgs} args - Arguments to create a Trolley_webhook_log.
     * @example
     * // Create one Trolley_webhook_log
     * const Trolley_webhook_log = await prisma.trolley_webhook_log.create({
     *   data: {
     *     // ... data to create a Trolley_webhook_log
     *   }
     * })
     * 
     */
    create<T extends trolley_webhook_logCreateArgs>(args: SelectSubset<T, trolley_webhook_logCreateArgs<ExtArgs>>): Prisma__trolley_webhook_logClient<$Result.GetResult<Prisma.$trolley_webhook_logPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Trolley_webhook_logs.
     * @param {trolley_webhook_logCreateManyArgs} args - Arguments to create many Trolley_webhook_logs.
     * @example
     * // Create many Trolley_webhook_logs
     * const trolley_webhook_log = await prisma.trolley_webhook_log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends trolley_webhook_logCreateManyArgs>(args?: SelectSubset<T, trolley_webhook_logCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trolley_webhook_logs and returns the data saved in the database.
     * @param {trolley_webhook_logCreateManyAndReturnArgs} args - Arguments to create many Trolley_webhook_logs.
     * @example
     * // Create many Trolley_webhook_logs
     * const trolley_webhook_log = await prisma.trolley_webhook_log.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trolley_webhook_logs and only return the `id`
     * const trolley_webhook_logWithIdOnly = await prisma.trolley_webhook_log.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends trolley_webhook_logCreateManyAndReturnArgs>(args?: SelectSubset<T, trolley_webhook_logCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trolley_webhook_logPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Trolley_webhook_log.
     * @param {trolley_webhook_logDeleteArgs} args - Arguments to delete one Trolley_webhook_log.
     * @example
     * // Delete one Trolley_webhook_log
     * const Trolley_webhook_log = await prisma.trolley_webhook_log.delete({
     *   where: {
     *     // ... filter to delete one Trolley_webhook_log
     *   }
     * })
     * 
     */
    delete<T extends trolley_webhook_logDeleteArgs>(args: SelectSubset<T, trolley_webhook_logDeleteArgs<ExtArgs>>): Prisma__trolley_webhook_logClient<$Result.GetResult<Prisma.$trolley_webhook_logPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Trolley_webhook_log.
     * @param {trolley_webhook_logUpdateArgs} args - Arguments to update one Trolley_webhook_log.
     * @example
     * // Update one Trolley_webhook_log
     * const trolley_webhook_log = await prisma.trolley_webhook_log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends trolley_webhook_logUpdateArgs>(args: SelectSubset<T, trolley_webhook_logUpdateArgs<ExtArgs>>): Prisma__trolley_webhook_logClient<$Result.GetResult<Prisma.$trolley_webhook_logPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Trolley_webhook_logs.
     * @param {trolley_webhook_logDeleteManyArgs} args - Arguments to filter Trolley_webhook_logs to delete.
     * @example
     * // Delete a few Trolley_webhook_logs
     * const { count } = await prisma.trolley_webhook_log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends trolley_webhook_logDeleteManyArgs>(args?: SelectSubset<T, trolley_webhook_logDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trolley_webhook_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trolley_webhook_logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trolley_webhook_logs
     * const trolley_webhook_log = await prisma.trolley_webhook_log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends trolley_webhook_logUpdateManyArgs>(args: SelectSubset<T, trolley_webhook_logUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trolley_webhook_logs and returns the data updated in the database.
     * @param {trolley_webhook_logUpdateManyAndReturnArgs} args - Arguments to update many Trolley_webhook_logs.
     * @example
     * // Update many Trolley_webhook_logs
     * const trolley_webhook_log = await prisma.trolley_webhook_log.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Trolley_webhook_logs and only return the `id`
     * const trolley_webhook_logWithIdOnly = await prisma.trolley_webhook_log.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends trolley_webhook_logUpdateManyAndReturnArgs>(args: SelectSubset<T, trolley_webhook_logUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trolley_webhook_logPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Trolley_webhook_log.
     * @param {trolley_webhook_logUpsertArgs} args - Arguments to update or create a Trolley_webhook_log.
     * @example
     * // Update or create a Trolley_webhook_log
     * const trolley_webhook_log = await prisma.trolley_webhook_log.upsert({
     *   create: {
     *     // ... data to create a Trolley_webhook_log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trolley_webhook_log we want to update
     *   }
     * })
     */
    upsert<T extends trolley_webhook_logUpsertArgs>(args: SelectSubset<T, trolley_webhook_logUpsertArgs<ExtArgs>>): Prisma__trolley_webhook_logClient<$Result.GetResult<Prisma.$trolley_webhook_logPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Trolley_webhook_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trolley_webhook_logCountArgs} args - Arguments to filter Trolley_webhook_logs to count.
     * @example
     * // Count the number of Trolley_webhook_logs
     * const count = await prisma.trolley_webhook_log.count({
     *   where: {
     *     // ... the filter for the Trolley_webhook_logs we want to count
     *   }
     * })
    **/
    count<T extends trolley_webhook_logCountArgs>(
      args?: Subset<T, trolley_webhook_logCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Trolley_webhook_logCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trolley_webhook_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Trolley_webhook_logAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Trolley_webhook_logAggregateArgs>(args: Subset<T, Trolley_webhook_logAggregateArgs>): Prisma.PrismaPromise<GetTrolley_webhook_logAggregateType<T>>

    /**
     * Group by Trolley_webhook_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trolley_webhook_logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends trolley_webhook_logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: trolley_webhook_logGroupByArgs['orderBy'] }
        : { orderBy?: trolley_webhook_logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, trolley_webhook_logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrolley_webhook_logGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the trolley_webhook_log model
   */
  readonly fields: trolley_webhook_logFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for trolley_webhook_log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__trolley_webhook_logClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the trolley_webhook_log model
   */
  interface trolley_webhook_logFieldRefs {
    readonly id: FieldRef<"trolley_webhook_log", 'String'>
    readonly event_id: FieldRef<"trolley_webhook_log", 'String'>
    readonly event_time: FieldRef<"trolley_webhook_log", 'DateTime'>
    readonly event_payload: FieldRef<"trolley_webhook_log", 'Json'>
    readonly event_model: FieldRef<"trolley_webhook_log", 'String'>
    readonly event_action: FieldRef<"trolley_webhook_log", 'String'>
    readonly status: FieldRef<"trolley_webhook_log", 'webhook_status'>
    readonly error_message: FieldRef<"trolley_webhook_log", 'String'>
    readonly created_at: FieldRef<"trolley_webhook_log", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * trolley_webhook_log findUnique
   */
  export type trolley_webhook_logFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_webhook_log
     */
    select?: trolley_webhook_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_webhook_log
     */
    omit?: trolley_webhook_logOmit<ExtArgs> | null
    /**
     * Filter, which trolley_webhook_log to fetch.
     */
    where: trolley_webhook_logWhereUniqueInput
  }

  /**
   * trolley_webhook_log findUniqueOrThrow
   */
  export type trolley_webhook_logFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_webhook_log
     */
    select?: trolley_webhook_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_webhook_log
     */
    omit?: trolley_webhook_logOmit<ExtArgs> | null
    /**
     * Filter, which trolley_webhook_log to fetch.
     */
    where: trolley_webhook_logWhereUniqueInput
  }

  /**
   * trolley_webhook_log findFirst
   */
  export type trolley_webhook_logFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_webhook_log
     */
    select?: trolley_webhook_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_webhook_log
     */
    omit?: trolley_webhook_logOmit<ExtArgs> | null
    /**
     * Filter, which trolley_webhook_log to fetch.
     */
    where?: trolley_webhook_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trolley_webhook_logs to fetch.
     */
    orderBy?: trolley_webhook_logOrderByWithRelationInput | trolley_webhook_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trolley_webhook_logs.
     */
    cursor?: trolley_webhook_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trolley_webhook_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trolley_webhook_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trolley_webhook_logs.
     */
    distinct?: Trolley_webhook_logScalarFieldEnum | Trolley_webhook_logScalarFieldEnum[]
  }

  /**
   * trolley_webhook_log findFirstOrThrow
   */
  export type trolley_webhook_logFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_webhook_log
     */
    select?: trolley_webhook_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_webhook_log
     */
    omit?: trolley_webhook_logOmit<ExtArgs> | null
    /**
     * Filter, which trolley_webhook_log to fetch.
     */
    where?: trolley_webhook_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trolley_webhook_logs to fetch.
     */
    orderBy?: trolley_webhook_logOrderByWithRelationInput | trolley_webhook_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trolley_webhook_logs.
     */
    cursor?: trolley_webhook_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trolley_webhook_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trolley_webhook_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trolley_webhook_logs.
     */
    distinct?: Trolley_webhook_logScalarFieldEnum | Trolley_webhook_logScalarFieldEnum[]
  }

  /**
   * trolley_webhook_log findMany
   */
  export type trolley_webhook_logFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_webhook_log
     */
    select?: trolley_webhook_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_webhook_log
     */
    omit?: trolley_webhook_logOmit<ExtArgs> | null
    /**
     * Filter, which trolley_webhook_logs to fetch.
     */
    where?: trolley_webhook_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trolley_webhook_logs to fetch.
     */
    orderBy?: trolley_webhook_logOrderByWithRelationInput | trolley_webhook_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trolley_webhook_logs.
     */
    cursor?: trolley_webhook_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trolley_webhook_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trolley_webhook_logs.
     */
    skip?: number
    distinct?: Trolley_webhook_logScalarFieldEnum | Trolley_webhook_logScalarFieldEnum[]
  }

  /**
   * trolley_webhook_log create
   */
  export type trolley_webhook_logCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_webhook_log
     */
    select?: trolley_webhook_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_webhook_log
     */
    omit?: trolley_webhook_logOmit<ExtArgs> | null
    /**
     * The data needed to create a trolley_webhook_log.
     */
    data: XOR<trolley_webhook_logCreateInput, trolley_webhook_logUncheckedCreateInput>
  }

  /**
   * trolley_webhook_log createMany
   */
  export type trolley_webhook_logCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many trolley_webhook_logs.
     */
    data: trolley_webhook_logCreateManyInput | trolley_webhook_logCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * trolley_webhook_log createManyAndReturn
   */
  export type trolley_webhook_logCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_webhook_log
     */
    select?: trolley_webhook_logSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_webhook_log
     */
    omit?: trolley_webhook_logOmit<ExtArgs> | null
    /**
     * The data used to create many trolley_webhook_logs.
     */
    data: trolley_webhook_logCreateManyInput | trolley_webhook_logCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * trolley_webhook_log update
   */
  export type trolley_webhook_logUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_webhook_log
     */
    select?: trolley_webhook_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_webhook_log
     */
    omit?: trolley_webhook_logOmit<ExtArgs> | null
    /**
     * The data needed to update a trolley_webhook_log.
     */
    data: XOR<trolley_webhook_logUpdateInput, trolley_webhook_logUncheckedUpdateInput>
    /**
     * Choose, which trolley_webhook_log to update.
     */
    where: trolley_webhook_logWhereUniqueInput
  }

  /**
   * trolley_webhook_log updateMany
   */
  export type trolley_webhook_logUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update trolley_webhook_logs.
     */
    data: XOR<trolley_webhook_logUpdateManyMutationInput, trolley_webhook_logUncheckedUpdateManyInput>
    /**
     * Filter which trolley_webhook_logs to update
     */
    where?: trolley_webhook_logWhereInput
    /**
     * Limit how many trolley_webhook_logs to update.
     */
    limit?: number
  }

  /**
   * trolley_webhook_log updateManyAndReturn
   */
  export type trolley_webhook_logUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_webhook_log
     */
    select?: trolley_webhook_logSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_webhook_log
     */
    omit?: trolley_webhook_logOmit<ExtArgs> | null
    /**
     * The data used to update trolley_webhook_logs.
     */
    data: XOR<trolley_webhook_logUpdateManyMutationInput, trolley_webhook_logUncheckedUpdateManyInput>
    /**
     * Filter which trolley_webhook_logs to update
     */
    where?: trolley_webhook_logWhereInput
    /**
     * Limit how many trolley_webhook_logs to update.
     */
    limit?: number
  }

  /**
   * trolley_webhook_log upsert
   */
  export type trolley_webhook_logUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_webhook_log
     */
    select?: trolley_webhook_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_webhook_log
     */
    omit?: trolley_webhook_logOmit<ExtArgs> | null
    /**
     * The filter to search for the trolley_webhook_log to update in case it exists.
     */
    where: trolley_webhook_logWhereUniqueInput
    /**
     * In case the trolley_webhook_log found by the `where` argument doesn't exist, create a new trolley_webhook_log with this data.
     */
    create: XOR<trolley_webhook_logCreateInput, trolley_webhook_logUncheckedCreateInput>
    /**
     * In case the trolley_webhook_log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<trolley_webhook_logUpdateInput, trolley_webhook_logUncheckedUpdateInput>
  }

  /**
   * trolley_webhook_log delete
   */
  export type trolley_webhook_logDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_webhook_log
     */
    select?: trolley_webhook_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_webhook_log
     */
    omit?: trolley_webhook_logOmit<ExtArgs> | null
    /**
     * Filter which trolley_webhook_log to delete.
     */
    where: trolley_webhook_logWhereUniqueInput
  }

  /**
   * trolley_webhook_log deleteMany
   */
  export type trolley_webhook_logDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trolley_webhook_logs to delete
     */
    where?: trolley_webhook_logWhereInput
    /**
     * Limit how many trolley_webhook_logs to delete.
     */
    limit?: number
  }

  /**
   * trolley_webhook_log without action
   */
  export type trolley_webhook_logDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_webhook_log
     */
    select?: trolley_webhook_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_webhook_log
     */
    omit?: trolley_webhook_logOmit<ExtArgs> | null
  }


  /**
   * Model user_identity_verification_associations
   */

  export type AggregateUser_identity_verification_associations = {
    _count: User_identity_verification_associationsCountAggregateOutputType | null
    _min: User_identity_verification_associationsMinAggregateOutputType | null
    _max: User_identity_verification_associationsMaxAggregateOutputType | null
  }

  export type User_identity_verification_associationsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    verification_id: string | null
    date_filed: Date | null
    verification_status: $Enums.verification_status | null
  }

  export type User_identity_verification_associationsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    verification_id: string | null
    date_filed: Date | null
    verification_status: $Enums.verification_status | null
  }

  export type User_identity_verification_associationsCountAggregateOutputType = {
    id: number
    user_id: number
    verification_id: number
    date_filed: number
    verification_status: number
    _all: number
  }


  export type User_identity_verification_associationsMinAggregateInputType = {
    id?: true
    user_id?: true
    verification_id?: true
    date_filed?: true
    verification_status?: true
  }

  export type User_identity_verification_associationsMaxAggregateInputType = {
    id?: true
    user_id?: true
    verification_id?: true
    date_filed?: true
    verification_status?: true
  }

  export type User_identity_verification_associationsCountAggregateInputType = {
    id?: true
    user_id?: true
    verification_id?: true
    date_filed?: true
    verification_status?: true
    _all?: true
  }

  export type User_identity_verification_associationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_identity_verification_associations to aggregate.
     */
    where?: user_identity_verification_associationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_identity_verification_associations to fetch.
     */
    orderBy?: user_identity_verification_associationsOrderByWithRelationInput | user_identity_verification_associationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_identity_verification_associationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_identity_verification_associations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_identity_verification_associations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_identity_verification_associations
    **/
    _count?: true | User_identity_verification_associationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_identity_verification_associationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_identity_verification_associationsMaxAggregateInputType
  }

  export type GetUser_identity_verification_associationsAggregateType<T extends User_identity_verification_associationsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_identity_verification_associations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_identity_verification_associations[P]>
      : GetScalarType<T[P], AggregateUser_identity_verification_associations[P]>
  }




  export type user_identity_verification_associationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_identity_verification_associationsWhereInput
    orderBy?: user_identity_verification_associationsOrderByWithAggregationInput | user_identity_verification_associationsOrderByWithAggregationInput[]
    by: User_identity_verification_associationsScalarFieldEnum[] | User_identity_verification_associationsScalarFieldEnum
    having?: user_identity_verification_associationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_identity_verification_associationsCountAggregateInputType | true
    _min?: User_identity_verification_associationsMinAggregateInputType
    _max?: User_identity_verification_associationsMaxAggregateInputType
  }

  export type User_identity_verification_associationsGroupByOutputType = {
    id: string
    user_id: string
    verification_id: string
    date_filed: Date
    verification_status: $Enums.verification_status
    _count: User_identity_verification_associationsCountAggregateOutputType | null
    _min: User_identity_verification_associationsMinAggregateOutputType | null
    _max: User_identity_verification_associationsMaxAggregateOutputType | null
  }

  type GetUser_identity_verification_associationsGroupByPayload<T extends user_identity_verification_associationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_identity_verification_associationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_identity_verification_associationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_identity_verification_associationsGroupByOutputType[P]>
            : GetScalarType<T[P], User_identity_verification_associationsGroupByOutputType[P]>
        }
      >
    >


  export type user_identity_verification_associationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    verification_id?: boolean
    date_filed?: boolean
    verification_status?: boolean
  }, ExtArgs["result"]["user_identity_verification_associations"]>

  export type user_identity_verification_associationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    verification_id?: boolean
    date_filed?: boolean
    verification_status?: boolean
  }, ExtArgs["result"]["user_identity_verification_associations"]>

  export type user_identity_verification_associationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    verification_id?: boolean
    date_filed?: boolean
    verification_status?: boolean
  }, ExtArgs["result"]["user_identity_verification_associations"]>

  export type user_identity_verification_associationsSelectScalar = {
    id?: boolean
    user_id?: boolean
    verification_id?: boolean
    date_filed?: boolean
    verification_status?: boolean
  }

  export type user_identity_verification_associationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "verification_id" | "date_filed" | "verification_status", ExtArgs["result"]["user_identity_verification_associations"]>

  export type $user_identity_verification_associationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_identity_verification_associations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      verification_id: string
      date_filed: Date
      verification_status: $Enums.verification_status
    }, ExtArgs["result"]["user_identity_verification_associations"]>
    composites: {}
  }

  type user_identity_verification_associationsGetPayload<S extends boolean | null | undefined | user_identity_verification_associationsDefaultArgs> = $Result.GetResult<Prisma.$user_identity_verification_associationsPayload, S>

  type user_identity_verification_associationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_identity_verification_associationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_identity_verification_associationsCountAggregateInputType | true
    }

  export interface user_identity_verification_associationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_identity_verification_associations'], meta: { name: 'user_identity_verification_associations' } }
    /**
     * Find zero or one User_identity_verification_associations that matches the filter.
     * @param {user_identity_verification_associationsFindUniqueArgs} args - Arguments to find a User_identity_verification_associations
     * @example
     * // Get one User_identity_verification_associations
     * const user_identity_verification_associations = await prisma.user_identity_verification_associations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_identity_verification_associationsFindUniqueArgs>(args: SelectSubset<T, user_identity_verification_associationsFindUniqueArgs<ExtArgs>>): Prisma__user_identity_verification_associationsClient<$Result.GetResult<Prisma.$user_identity_verification_associationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_identity_verification_associations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_identity_verification_associationsFindUniqueOrThrowArgs} args - Arguments to find a User_identity_verification_associations
     * @example
     * // Get one User_identity_verification_associations
     * const user_identity_verification_associations = await prisma.user_identity_verification_associations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_identity_verification_associationsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_identity_verification_associationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_identity_verification_associationsClient<$Result.GetResult<Prisma.$user_identity_verification_associationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_identity_verification_associations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_identity_verification_associationsFindFirstArgs} args - Arguments to find a User_identity_verification_associations
     * @example
     * // Get one User_identity_verification_associations
     * const user_identity_verification_associations = await prisma.user_identity_verification_associations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_identity_verification_associationsFindFirstArgs>(args?: SelectSubset<T, user_identity_verification_associationsFindFirstArgs<ExtArgs>>): Prisma__user_identity_verification_associationsClient<$Result.GetResult<Prisma.$user_identity_verification_associationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_identity_verification_associations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_identity_verification_associationsFindFirstOrThrowArgs} args - Arguments to find a User_identity_verification_associations
     * @example
     * // Get one User_identity_verification_associations
     * const user_identity_verification_associations = await prisma.user_identity_verification_associations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_identity_verification_associationsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_identity_verification_associationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_identity_verification_associationsClient<$Result.GetResult<Prisma.$user_identity_verification_associationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_identity_verification_associations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_identity_verification_associationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_identity_verification_associations
     * const user_identity_verification_associations = await prisma.user_identity_verification_associations.findMany()
     * 
     * // Get first 10 User_identity_verification_associations
     * const user_identity_verification_associations = await prisma.user_identity_verification_associations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_identity_verification_associationsWithIdOnly = await prisma.user_identity_verification_associations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_identity_verification_associationsFindManyArgs>(args?: SelectSubset<T, user_identity_verification_associationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_identity_verification_associationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_identity_verification_associations.
     * @param {user_identity_verification_associationsCreateArgs} args - Arguments to create a User_identity_verification_associations.
     * @example
     * // Create one User_identity_verification_associations
     * const User_identity_verification_associations = await prisma.user_identity_verification_associations.create({
     *   data: {
     *     // ... data to create a User_identity_verification_associations
     *   }
     * })
     * 
     */
    create<T extends user_identity_verification_associationsCreateArgs>(args: SelectSubset<T, user_identity_verification_associationsCreateArgs<ExtArgs>>): Prisma__user_identity_verification_associationsClient<$Result.GetResult<Prisma.$user_identity_verification_associationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_identity_verification_associations.
     * @param {user_identity_verification_associationsCreateManyArgs} args - Arguments to create many User_identity_verification_associations.
     * @example
     * // Create many User_identity_verification_associations
     * const user_identity_verification_associations = await prisma.user_identity_verification_associations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_identity_verification_associationsCreateManyArgs>(args?: SelectSubset<T, user_identity_verification_associationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_identity_verification_associations and returns the data saved in the database.
     * @param {user_identity_verification_associationsCreateManyAndReturnArgs} args - Arguments to create many User_identity_verification_associations.
     * @example
     * // Create many User_identity_verification_associations
     * const user_identity_verification_associations = await prisma.user_identity_verification_associations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_identity_verification_associations and only return the `id`
     * const user_identity_verification_associationsWithIdOnly = await prisma.user_identity_verification_associations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_identity_verification_associationsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_identity_verification_associationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_identity_verification_associationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_identity_verification_associations.
     * @param {user_identity_verification_associationsDeleteArgs} args - Arguments to delete one User_identity_verification_associations.
     * @example
     * // Delete one User_identity_verification_associations
     * const User_identity_verification_associations = await prisma.user_identity_verification_associations.delete({
     *   where: {
     *     // ... filter to delete one User_identity_verification_associations
     *   }
     * })
     * 
     */
    delete<T extends user_identity_verification_associationsDeleteArgs>(args: SelectSubset<T, user_identity_verification_associationsDeleteArgs<ExtArgs>>): Prisma__user_identity_verification_associationsClient<$Result.GetResult<Prisma.$user_identity_verification_associationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_identity_verification_associations.
     * @param {user_identity_verification_associationsUpdateArgs} args - Arguments to update one User_identity_verification_associations.
     * @example
     * // Update one User_identity_verification_associations
     * const user_identity_verification_associations = await prisma.user_identity_verification_associations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_identity_verification_associationsUpdateArgs>(args: SelectSubset<T, user_identity_verification_associationsUpdateArgs<ExtArgs>>): Prisma__user_identity_verification_associationsClient<$Result.GetResult<Prisma.$user_identity_verification_associationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_identity_verification_associations.
     * @param {user_identity_verification_associationsDeleteManyArgs} args - Arguments to filter User_identity_verification_associations to delete.
     * @example
     * // Delete a few User_identity_verification_associations
     * const { count } = await prisma.user_identity_verification_associations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_identity_verification_associationsDeleteManyArgs>(args?: SelectSubset<T, user_identity_verification_associationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_identity_verification_associations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_identity_verification_associationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_identity_verification_associations
     * const user_identity_verification_associations = await prisma.user_identity_verification_associations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_identity_verification_associationsUpdateManyArgs>(args: SelectSubset<T, user_identity_verification_associationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_identity_verification_associations and returns the data updated in the database.
     * @param {user_identity_verification_associationsUpdateManyAndReturnArgs} args - Arguments to update many User_identity_verification_associations.
     * @example
     * // Update many User_identity_verification_associations
     * const user_identity_verification_associations = await prisma.user_identity_verification_associations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_identity_verification_associations and only return the `id`
     * const user_identity_verification_associationsWithIdOnly = await prisma.user_identity_verification_associations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_identity_verification_associationsUpdateManyAndReturnArgs>(args: SelectSubset<T, user_identity_verification_associationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_identity_verification_associationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_identity_verification_associations.
     * @param {user_identity_verification_associationsUpsertArgs} args - Arguments to update or create a User_identity_verification_associations.
     * @example
     * // Update or create a User_identity_verification_associations
     * const user_identity_verification_associations = await prisma.user_identity_verification_associations.upsert({
     *   create: {
     *     // ... data to create a User_identity_verification_associations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_identity_verification_associations we want to update
     *   }
     * })
     */
    upsert<T extends user_identity_verification_associationsUpsertArgs>(args: SelectSubset<T, user_identity_verification_associationsUpsertArgs<ExtArgs>>): Prisma__user_identity_verification_associationsClient<$Result.GetResult<Prisma.$user_identity_verification_associationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_identity_verification_associations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_identity_verification_associationsCountArgs} args - Arguments to filter User_identity_verification_associations to count.
     * @example
     * // Count the number of User_identity_verification_associations
     * const count = await prisma.user_identity_verification_associations.count({
     *   where: {
     *     // ... the filter for the User_identity_verification_associations we want to count
     *   }
     * })
    **/
    count<T extends user_identity_verification_associationsCountArgs>(
      args?: Subset<T, user_identity_verification_associationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_identity_verification_associationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_identity_verification_associations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_identity_verification_associationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_identity_verification_associationsAggregateArgs>(args: Subset<T, User_identity_verification_associationsAggregateArgs>): Prisma.PrismaPromise<GetUser_identity_verification_associationsAggregateType<T>>

    /**
     * Group by User_identity_verification_associations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_identity_verification_associationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_identity_verification_associationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_identity_verification_associationsGroupByArgs['orderBy'] }
        : { orderBy?: user_identity_verification_associationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_identity_verification_associationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_identity_verification_associationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_identity_verification_associations model
   */
  readonly fields: user_identity_verification_associationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_identity_verification_associations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_identity_verification_associationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_identity_verification_associations model
   */
  interface user_identity_verification_associationsFieldRefs {
    readonly id: FieldRef<"user_identity_verification_associations", 'String'>
    readonly user_id: FieldRef<"user_identity_verification_associations", 'String'>
    readonly verification_id: FieldRef<"user_identity_verification_associations", 'String'>
    readonly date_filed: FieldRef<"user_identity_verification_associations", 'DateTime'>
    readonly verification_status: FieldRef<"user_identity_verification_associations", 'verification_status'>
  }
    

  // Custom InputTypes
  /**
   * user_identity_verification_associations findUnique
   */
  export type user_identity_verification_associationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_identity_verification_associations
     */
    select?: user_identity_verification_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_identity_verification_associations
     */
    omit?: user_identity_verification_associationsOmit<ExtArgs> | null
    /**
     * Filter, which user_identity_verification_associations to fetch.
     */
    where: user_identity_verification_associationsWhereUniqueInput
  }

  /**
   * user_identity_verification_associations findUniqueOrThrow
   */
  export type user_identity_verification_associationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_identity_verification_associations
     */
    select?: user_identity_verification_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_identity_verification_associations
     */
    omit?: user_identity_verification_associationsOmit<ExtArgs> | null
    /**
     * Filter, which user_identity_verification_associations to fetch.
     */
    where: user_identity_verification_associationsWhereUniqueInput
  }

  /**
   * user_identity_verification_associations findFirst
   */
  export type user_identity_verification_associationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_identity_verification_associations
     */
    select?: user_identity_verification_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_identity_verification_associations
     */
    omit?: user_identity_verification_associationsOmit<ExtArgs> | null
    /**
     * Filter, which user_identity_verification_associations to fetch.
     */
    where?: user_identity_verification_associationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_identity_verification_associations to fetch.
     */
    orderBy?: user_identity_verification_associationsOrderByWithRelationInput | user_identity_verification_associationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_identity_verification_associations.
     */
    cursor?: user_identity_verification_associationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_identity_verification_associations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_identity_verification_associations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_identity_verification_associations.
     */
    distinct?: User_identity_verification_associationsScalarFieldEnum | User_identity_verification_associationsScalarFieldEnum[]
  }

  /**
   * user_identity_verification_associations findFirstOrThrow
   */
  export type user_identity_verification_associationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_identity_verification_associations
     */
    select?: user_identity_verification_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_identity_verification_associations
     */
    omit?: user_identity_verification_associationsOmit<ExtArgs> | null
    /**
     * Filter, which user_identity_verification_associations to fetch.
     */
    where?: user_identity_verification_associationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_identity_verification_associations to fetch.
     */
    orderBy?: user_identity_verification_associationsOrderByWithRelationInput | user_identity_verification_associationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_identity_verification_associations.
     */
    cursor?: user_identity_verification_associationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_identity_verification_associations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_identity_verification_associations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_identity_verification_associations.
     */
    distinct?: User_identity_verification_associationsScalarFieldEnum | User_identity_verification_associationsScalarFieldEnum[]
  }

  /**
   * user_identity_verification_associations findMany
   */
  export type user_identity_verification_associationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_identity_verification_associations
     */
    select?: user_identity_verification_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_identity_verification_associations
     */
    omit?: user_identity_verification_associationsOmit<ExtArgs> | null
    /**
     * Filter, which user_identity_verification_associations to fetch.
     */
    where?: user_identity_verification_associationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_identity_verification_associations to fetch.
     */
    orderBy?: user_identity_verification_associationsOrderByWithRelationInput | user_identity_verification_associationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_identity_verification_associations.
     */
    cursor?: user_identity_verification_associationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_identity_verification_associations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_identity_verification_associations.
     */
    skip?: number
    distinct?: User_identity_verification_associationsScalarFieldEnum | User_identity_verification_associationsScalarFieldEnum[]
  }

  /**
   * user_identity_verification_associations create
   */
  export type user_identity_verification_associationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_identity_verification_associations
     */
    select?: user_identity_verification_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_identity_verification_associations
     */
    omit?: user_identity_verification_associationsOmit<ExtArgs> | null
    /**
     * The data needed to create a user_identity_verification_associations.
     */
    data: XOR<user_identity_verification_associationsCreateInput, user_identity_verification_associationsUncheckedCreateInput>
  }

  /**
   * user_identity_verification_associations createMany
   */
  export type user_identity_verification_associationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_identity_verification_associations.
     */
    data: user_identity_verification_associationsCreateManyInput | user_identity_verification_associationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_identity_verification_associations createManyAndReturn
   */
  export type user_identity_verification_associationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_identity_verification_associations
     */
    select?: user_identity_verification_associationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_identity_verification_associations
     */
    omit?: user_identity_verification_associationsOmit<ExtArgs> | null
    /**
     * The data used to create many user_identity_verification_associations.
     */
    data: user_identity_verification_associationsCreateManyInput | user_identity_verification_associationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_identity_verification_associations update
   */
  export type user_identity_verification_associationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_identity_verification_associations
     */
    select?: user_identity_verification_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_identity_verification_associations
     */
    omit?: user_identity_verification_associationsOmit<ExtArgs> | null
    /**
     * The data needed to update a user_identity_verification_associations.
     */
    data: XOR<user_identity_verification_associationsUpdateInput, user_identity_verification_associationsUncheckedUpdateInput>
    /**
     * Choose, which user_identity_verification_associations to update.
     */
    where: user_identity_verification_associationsWhereUniqueInput
  }

  /**
   * user_identity_verification_associations updateMany
   */
  export type user_identity_verification_associationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_identity_verification_associations.
     */
    data: XOR<user_identity_verification_associationsUpdateManyMutationInput, user_identity_verification_associationsUncheckedUpdateManyInput>
    /**
     * Filter which user_identity_verification_associations to update
     */
    where?: user_identity_verification_associationsWhereInput
    /**
     * Limit how many user_identity_verification_associations to update.
     */
    limit?: number
  }

  /**
   * user_identity_verification_associations updateManyAndReturn
   */
  export type user_identity_verification_associationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_identity_verification_associations
     */
    select?: user_identity_verification_associationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_identity_verification_associations
     */
    omit?: user_identity_verification_associationsOmit<ExtArgs> | null
    /**
     * The data used to update user_identity_verification_associations.
     */
    data: XOR<user_identity_verification_associationsUpdateManyMutationInput, user_identity_verification_associationsUncheckedUpdateManyInput>
    /**
     * Filter which user_identity_verification_associations to update
     */
    where?: user_identity_verification_associationsWhereInput
    /**
     * Limit how many user_identity_verification_associations to update.
     */
    limit?: number
  }

  /**
   * user_identity_verification_associations upsert
   */
  export type user_identity_verification_associationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_identity_verification_associations
     */
    select?: user_identity_verification_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_identity_verification_associations
     */
    omit?: user_identity_verification_associationsOmit<ExtArgs> | null
    /**
     * The filter to search for the user_identity_verification_associations to update in case it exists.
     */
    where: user_identity_verification_associationsWhereUniqueInput
    /**
     * In case the user_identity_verification_associations found by the `where` argument doesn't exist, create a new user_identity_verification_associations with this data.
     */
    create: XOR<user_identity_verification_associationsCreateInput, user_identity_verification_associationsUncheckedCreateInput>
    /**
     * In case the user_identity_verification_associations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_identity_verification_associationsUpdateInput, user_identity_verification_associationsUncheckedUpdateInput>
  }

  /**
   * user_identity_verification_associations delete
   */
  export type user_identity_verification_associationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_identity_verification_associations
     */
    select?: user_identity_verification_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_identity_verification_associations
     */
    omit?: user_identity_verification_associationsOmit<ExtArgs> | null
    /**
     * Filter which user_identity_verification_associations to delete.
     */
    where: user_identity_verification_associationsWhereUniqueInput
  }

  /**
   * user_identity_verification_associations deleteMany
   */
  export type user_identity_verification_associationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_identity_verification_associations to delete
     */
    where?: user_identity_verification_associationsWhereInput
    /**
     * Limit how many user_identity_verification_associations to delete.
     */
    limit?: number
  }

  /**
   * user_identity_verification_associations without action
   */
  export type user_identity_verification_associationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_identity_verification_associations
     */
    select?: user_identity_verification_associationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_identity_verification_associations
     */
    omit?: user_identity_verification_associationsOmit<ExtArgs> | null
  }


  /**
   * Model trolley_recipient_payment_method
   */

  export type AggregateTrolley_recipient_payment_method = {
    _count: Trolley_recipient_payment_methodCountAggregateOutputType | null
    _avg: Trolley_recipient_payment_methodAvgAggregateOutputType | null
    _sum: Trolley_recipient_payment_methodSumAggregateOutputType | null
    _min: Trolley_recipient_payment_methodMinAggregateOutputType | null
    _max: Trolley_recipient_payment_methodMaxAggregateOutputType | null
  }

  export type Trolley_recipient_payment_methodAvgAggregateOutputType = {
    trolley_recipient_id: number | null
  }

  export type Trolley_recipient_payment_methodSumAggregateOutputType = {
    trolley_recipient_id: number | null
  }

  export type Trolley_recipient_payment_methodMinAggregateOutputType = {
    id: string | null
    trolley_recipient_id: number | null
    recipient_account_id: string | null
  }

  export type Trolley_recipient_payment_methodMaxAggregateOutputType = {
    id: string | null
    trolley_recipient_id: number | null
    recipient_account_id: string | null
  }

  export type Trolley_recipient_payment_methodCountAggregateOutputType = {
    id: number
    trolley_recipient_id: number
    recipient_account_id: number
    _all: number
  }


  export type Trolley_recipient_payment_methodAvgAggregateInputType = {
    trolley_recipient_id?: true
  }

  export type Trolley_recipient_payment_methodSumAggregateInputType = {
    trolley_recipient_id?: true
  }

  export type Trolley_recipient_payment_methodMinAggregateInputType = {
    id?: true
    trolley_recipient_id?: true
    recipient_account_id?: true
  }

  export type Trolley_recipient_payment_methodMaxAggregateInputType = {
    id?: true
    trolley_recipient_id?: true
    recipient_account_id?: true
  }

  export type Trolley_recipient_payment_methodCountAggregateInputType = {
    id?: true
    trolley_recipient_id?: true
    recipient_account_id?: true
    _all?: true
  }

  export type Trolley_recipient_payment_methodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trolley_recipient_payment_method to aggregate.
     */
    where?: trolley_recipient_payment_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trolley_recipient_payment_methods to fetch.
     */
    orderBy?: trolley_recipient_payment_methodOrderByWithRelationInput | trolley_recipient_payment_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: trolley_recipient_payment_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trolley_recipient_payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trolley_recipient_payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trolley_recipient_payment_methods
    **/
    _count?: true | Trolley_recipient_payment_methodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Trolley_recipient_payment_methodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Trolley_recipient_payment_methodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Trolley_recipient_payment_methodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Trolley_recipient_payment_methodMaxAggregateInputType
  }

  export type GetTrolley_recipient_payment_methodAggregateType<T extends Trolley_recipient_payment_methodAggregateArgs> = {
        [P in keyof T & keyof AggregateTrolley_recipient_payment_method]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrolley_recipient_payment_method[P]>
      : GetScalarType<T[P], AggregateTrolley_recipient_payment_method[P]>
  }




  export type trolley_recipient_payment_methodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: trolley_recipient_payment_methodWhereInput
    orderBy?: trolley_recipient_payment_methodOrderByWithAggregationInput | trolley_recipient_payment_methodOrderByWithAggregationInput[]
    by: Trolley_recipient_payment_methodScalarFieldEnum[] | Trolley_recipient_payment_methodScalarFieldEnum
    having?: trolley_recipient_payment_methodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Trolley_recipient_payment_methodCountAggregateInputType | true
    _avg?: Trolley_recipient_payment_methodAvgAggregateInputType
    _sum?: Trolley_recipient_payment_methodSumAggregateInputType
    _min?: Trolley_recipient_payment_methodMinAggregateInputType
    _max?: Trolley_recipient_payment_methodMaxAggregateInputType
  }

  export type Trolley_recipient_payment_methodGroupByOutputType = {
    id: string
    trolley_recipient_id: number
    recipient_account_id: string
    _count: Trolley_recipient_payment_methodCountAggregateOutputType | null
    _avg: Trolley_recipient_payment_methodAvgAggregateOutputType | null
    _sum: Trolley_recipient_payment_methodSumAggregateOutputType | null
    _min: Trolley_recipient_payment_methodMinAggregateOutputType | null
    _max: Trolley_recipient_payment_methodMaxAggregateOutputType | null
  }

  type GetTrolley_recipient_payment_methodGroupByPayload<T extends trolley_recipient_payment_methodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Trolley_recipient_payment_methodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Trolley_recipient_payment_methodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Trolley_recipient_payment_methodGroupByOutputType[P]>
            : GetScalarType<T[P], Trolley_recipient_payment_methodGroupByOutputType[P]>
        }
      >
    >


  export type trolley_recipient_payment_methodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trolley_recipient_id?: boolean
    recipient_account_id?: boolean
    trolley_recipient?: boolean | trolley_recipientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trolley_recipient_payment_method"]>

  export type trolley_recipient_payment_methodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trolley_recipient_id?: boolean
    recipient_account_id?: boolean
    trolley_recipient?: boolean | trolley_recipientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trolley_recipient_payment_method"]>

  export type trolley_recipient_payment_methodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trolley_recipient_id?: boolean
    recipient_account_id?: boolean
    trolley_recipient?: boolean | trolley_recipientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trolley_recipient_payment_method"]>

  export type trolley_recipient_payment_methodSelectScalar = {
    id?: boolean
    trolley_recipient_id?: boolean
    recipient_account_id?: boolean
  }

  export type trolley_recipient_payment_methodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trolley_recipient_id" | "recipient_account_id", ExtArgs["result"]["trolley_recipient_payment_method"]>
  export type trolley_recipient_payment_methodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trolley_recipient?: boolean | trolley_recipientDefaultArgs<ExtArgs>
  }
  export type trolley_recipient_payment_methodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trolley_recipient?: boolean | trolley_recipientDefaultArgs<ExtArgs>
  }
  export type trolley_recipient_payment_methodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trolley_recipient?: boolean | trolley_recipientDefaultArgs<ExtArgs>
  }

  export type $trolley_recipient_payment_methodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "trolley_recipient_payment_method"
    objects: {
      trolley_recipient: Prisma.$trolley_recipientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trolley_recipient_id: number
      recipient_account_id: string
    }, ExtArgs["result"]["trolley_recipient_payment_method"]>
    composites: {}
  }

  type trolley_recipient_payment_methodGetPayload<S extends boolean | null | undefined | trolley_recipient_payment_methodDefaultArgs> = $Result.GetResult<Prisma.$trolley_recipient_payment_methodPayload, S>

  type trolley_recipient_payment_methodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<trolley_recipient_payment_methodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Trolley_recipient_payment_methodCountAggregateInputType | true
    }

  export interface trolley_recipient_payment_methodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['trolley_recipient_payment_method'], meta: { name: 'trolley_recipient_payment_method' } }
    /**
     * Find zero or one Trolley_recipient_payment_method that matches the filter.
     * @param {trolley_recipient_payment_methodFindUniqueArgs} args - Arguments to find a Trolley_recipient_payment_method
     * @example
     * // Get one Trolley_recipient_payment_method
     * const trolley_recipient_payment_method = await prisma.trolley_recipient_payment_method.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends trolley_recipient_payment_methodFindUniqueArgs>(args: SelectSubset<T, trolley_recipient_payment_methodFindUniqueArgs<ExtArgs>>): Prisma__trolley_recipient_payment_methodClient<$Result.GetResult<Prisma.$trolley_recipient_payment_methodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Trolley_recipient_payment_method that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {trolley_recipient_payment_methodFindUniqueOrThrowArgs} args - Arguments to find a Trolley_recipient_payment_method
     * @example
     * // Get one Trolley_recipient_payment_method
     * const trolley_recipient_payment_method = await prisma.trolley_recipient_payment_method.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends trolley_recipient_payment_methodFindUniqueOrThrowArgs>(args: SelectSubset<T, trolley_recipient_payment_methodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__trolley_recipient_payment_methodClient<$Result.GetResult<Prisma.$trolley_recipient_payment_methodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trolley_recipient_payment_method that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trolley_recipient_payment_methodFindFirstArgs} args - Arguments to find a Trolley_recipient_payment_method
     * @example
     * // Get one Trolley_recipient_payment_method
     * const trolley_recipient_payment_method = await prisma.trolley_recipient_payment_method.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends trolley_recipient_payment_methodFindFirstArgs>(args?: SelectSubset<T, trolley_recipient_payment_methodFindFirstArgs<ExtArgs>>): Prisma__trolley_recipient_payment_methodClient<$Result.GetResult<Prisma.$trolley_recipient_payment_methodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trolley_recipient_payment_method that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trolley_recipient_payment_methodFindFirstOrThrowArgs} args - Arguments to find a Trolley_recipient_payment_method
     * @example
     * // Get one Trolley_recipient_payment_method
     * const trolley_recipient_payment_method = await prisma.trolley_recipient_payment_method.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends trolley_recipient_payment_methodFindFirstOrThrowArgs>(args?: SelectSubset<T, trolley_recipient_payment_methodFindFirstOrThrowArgs<ExtArgs>>): Prisma__trolley_recipient_payment_methodClient<$Result.GetResult<Prisma.$trolley_recipient_payment_methodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Trolley_recipient_payment_methods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trolley_recipient_payment_methodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trolley_recipient_payment_methods
     * const trolley_recipient_payment_methods = await prisma.trolley_recipient_payment_method.findMany()
     * 
     * // Get first 10 Trolley_recipient_payment_methods
     * const trolley_recipient_payment_methods = await prisma.trolley_recipient_payment_method.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trolley_recipient_payment_methodWithIdOnly = await prisma.trolley_recipient_payment_method.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends trolley_recipient_payment_methodFindManyArgs>(args?: SelectSubset<T, trolley_recipient_payment_methodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trolley_recipient_payment_methodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Trolley_recipient_payment_method.
     * @param {trolley_recipient_payment_methodCreateArgs} args - Arguments to create a Trolley_recipient_payment_method.
     * @example
     * // Create one Trolley_recipient_payment_method
     * const Trolley_recipient_payment_method = await prisma.trolley_recipient_payment_method.create({
     *   data: {
     *     // ... data to create a Trolley_recipient_payment_method
     *   }
     * })
     * 
     */
    create<T extends trolley_recipient_payment_methodCreateArgs>(args: SelectSubset<T, trolley_recipient_payment_methodCreateArgs<ExtArgs>>): Prisma__trolley_recipient_payment_methodClient<$Result.GetResult<Prisma.$trolley_recipient_payment_methodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Trolley_recipient_payment_methods.
     * @param {trolley_recipient_payment_methodCreateManyArgs} args - Arguments to create many Trolley_recipient_payment_methods.
     * @example
     * // Create many Trolley_recipient_payment_methods
     * const trolley_recipient_payment_method = await prisma.trolley_recipient_payment_method.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends trolley_recipient_payment_methodCreateManyArgs>(args?: SelectSubset<T, trolley_recipient_payment_methodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trolley_recipient_payment_methods and returns the data saved in the database.
     * @param {trolley_recipient_payment_methodCreateManyAndReturnArgs} args - Arguments to create many Trolley_recipient_payment_methods.
     * @example
     * // Create many Trolley_recipient_payment_methods
     * const trolley_recipient_payment_method = await prisma.trolley_recipient_payment_method.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trolley_recipient_payment_methods and only return the `id`
     * const trolley_recipient_payment_methodWithIdOnly = await prisma.trolley_recipient_payment_method.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends trolley_recipient_payment_methodCreateManyAndReturnArgs>(args?: SelectSubset<T, trolley_recipient_payment_methodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trolley_recipient_payment_methodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Trolley_recipient_payment_method.
     * @param {trolley_recipient_payment_methodDeleteArgs} args - Arguments to delete one Trolley_recipient_payment_method.
     * @example
     * // Delete one Trolley_recipient_payment_method
     * const Trolley_recipient_payment_method = await prisma.trolley_recipient_payment_method.delete({
     *   where: {
     *     // ... filter to delete one Trolley_recipient_payment_method
     *   }
     * })
     * 
     */
    delete<T extends trolley_recipient_payment_methodDeleteArgs>(args: SelectSubset<T, trolley_recipient_payment_methodDeleteArgs<ExtArgs>>): Prisma__trolley_recipient_payment_methodClient<$Result.GetResult<Prisma.$trolley_recipient_payment_methodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Trolley_recipient_payment_method.
     * @param {trolley_recipient_payment_methodUpdateArgs} args - Arguments to update one Trolley_recipient_payment_method.
     * @example
     * // Update one Trolley_recipient_payment_method
     * const trolley_recipient_payment_method = await prisma.trolley_recipient_payment_method.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends trolley_recipient_payment_methodUpdateArgs>(args: SelectSubset<T, trolley_recipient_payment_methodUpdateArgs<ExtArgs>>): Prisma__trolley_recipient_payment_methodClient<$Result.GetResult<Prisma.$trolley_recipient_payment_methodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Trolley_recipient_payment_methods.
     * @param {trolley_recipient_payment_methodDeleteManyArgs} args - Arguments to filter Trolley_recipient_payment_methods to delete.
     * @example
     * // Delete a few Trolley_recipient_payment_methods
     * const { count } = await prisma.trolley_recipient_payment_method.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends trolley_recipient_payment_methodDeleteManyArgs>(args?: SelectSubset<T, trolley_recipient_payment_methodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trolley_recipient_payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trolley_recipient_payment_methodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trolley_recipient_payment_methods
     * const trolley_recipient_payment_method = await prisma.trolley_recipient_payment_method.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends trolley_recipient_payment_methodUpdateManyArgs>(args: SelectSubset<T, trolley_recipient_payment_methodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trolley_recipient_payment_methods and returns the data updated in the database.
     * @param {trolley_recipient_payment_methodUpdateManyAndReturnArgs} args - Arguments to update many Trolley_recipient_payment_methods.
     * @example
     * // Update many Trolley_recipient_payment_methods
     * const trolley_recipient_payment_method = await prisma.trolley_recipient_payment_method.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Trolley_recipient_payment_methods and only return the `id`
     * const trolley_recipient_payment_methodWithIdOnly = await prisma.trolley_recipient_payment_method.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends trolley_recipient_payment_methodUpdateManyAndReturnArgs>(args: SelectSubset<T, trolley_recipient_payment_methodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trolley_recipient_payment_methodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Trolley_recipient_payment_method.
     * @param {trolley_recipient_payment_methodUpsertArgs} args - Arguments to update or create a Trolley_recipient_payment_method.
     * @example
     * // Update or create a Trolley_recipient_payment_method
     * const trolley_recipient_payment_method = await prisma.trolley_recipient_payment_method.upsert({
     *   create: {
     *     // ... data to create a Trolley_recipient_payment_method
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trolley_recipient_payment_method we want to update
     *   }
     * })
     */
    upsert<T extends trolley_recipient_payment_methodUpsertArgs>(args: SelectSubset<T, trolley_recipient_payment_methodUpsertArgs<ExtArgs>>): Prisma__trolley_recipient_payment_methodClient<$Result.GetResult<Prisma.$trolley_recipient_payment_methodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Trolley_recipient_payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trolley_recipient_payment_methodCountArgs} args - Arguments to filter Trolley_recipient_payment_methods to count.
     * @example
     * // Count the number of Trolley_recipient_payment_methods
     * const count = await prisma.trolley_recipient_payment_method.count({
     *   where: {
     *     // ... the filter for the Trolley_recipient_payment_methods we want to count
     *   }
     * })
    **/
    count<T extends trolley_recipient_payment_methodCountArgs>(
      args?: Subset<T, trolley_recipient_payment_methodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Trolley_recipient_payment_methodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trolley_recipient_payment_method.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Trolley_recipient_payment_methodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Trolley_recipient_payment_methodAggregateArgs>(args: Subset<T, Trolley_recipient_payment_methodAggregateArgs>): Prisma.PrismaPromise<GetTrolley_recipient_payment_methodAggregateType<T>>

    /**
     * Group by Trolley_recipient_payment_method.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trolley_recipient_payment_methodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends trolley_recipient_payment_methodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: trolley_recipient_payment_methodGroupByArgs['orderBy'] }
        : { orderBy?: trolley_recipient_payment_methodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, trolley_recipient_payment_methodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrolley_recipient_payment_methodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the trolley_recipient_payment_method model
   */
  readonly fields: trolley_recipient_payment_methodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for trolley_recipient_payment_method.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__trolley_recipient_payment_methodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trolley_recipient<T extends trolley_recipientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, trolley_recipientDefaultArgs<ExtArgs>>): Prisma__trolley_recipientClient<$Result.GetResult<Prisma.$trolley_recipientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the trolley_recipient_payment_method model
   */
  interface trolley_recipient_payment_methodFieldRefs {
    readonly id: FieldRef<"trolley_recipient_payment_method", 'String'>
    readonly trolley_recipient_id: FieldRef<"trolley_recipient_payment_method", 'Int'>
    readonly recipient_account_id: FieldRef<"trolley_recipient_payment_method", 'String'>
  }
    

  // Custom InputTypes
  /**
   * trolley_recipient_payment_method findUnique
   */
  export type trolley_recipient_payment_methodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient_payment_method
     */
    select?: trolley_recipient_payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient_payment_method
     */
    omit?: trolley_recipient_payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipient_payment_methodInclude<ExtArgs> | null
    /**
     * Filter, which trolley_recipient_payment_method to fetch.
     */
    where: trolley_recipient_payment_methodWhereUniqueInput
  }

  /**
   * trolley_recipient_payment_method findUniqueOrThrow
   */
  export type trolley_recipient_payment_methodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient_payment_method
     */
    select?: trolley_recipient_payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient_payment_method
     */
    omit?: trolley_recipient_payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipient_payment_methodInclude<ExtArgs> | null
    /**
     * Filter, which trolley_recipient_payment_method to fetch.
     */
    where: trolley_recipient_payment_methodWhereUniqueInput
  }

  /**
   * trolley_recipient_payment_method findFirst
   */
  export type trolley_recipient_payment_methodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient_payment_method
     */
    select?: trolley_recipient_payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient_payment_method
     */
    omit?: trolley_recipient_payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipient_payment_methodInclude<ExtArgs> | null
    /**
     * Filter, which trolley_recipient_payment_method to fetch.
     */
    where?: trolley_recipient_payment_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trolley_recipient_payment_methods to fetch.
     */
    orderBy?: trolley_recipient_payment_methodOrderByWithRelationInput | trolley_recipient_payment_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trolley_recipient_payment_methods.
     */
    cursor?: trolley_recipient_payment_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trolley_recipient_payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trolley_recipient_payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trolley_recipient_payment_methods.
     */
    distinct?: Trolley_recipient_payment_methodScalarFieldEnum | Trolley_recipient_payment_methodScalarFieldEnum[]
  }

  /**
   * trolley_recipient_payment_method findFirstOrThrow
   */
  export type trolley_recipient_payment_methodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient_payment_method
     */
    select?: trolley_recipient_payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient_payment_method
     */
    omit?: trolley_recipient_payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipient_payment_methodInclude<ExtArgs> | null
    /**
     * Filter, which trolley_recipient_payment_method to fetch.
     */
    where?: trolley_recipient_payment_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trolley_recipient_payment_methods to fetch.
     */
    orderBy?: trolley_recipient_payment_methodOrderByWithRelationInput | trolley_recipient_payment_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trolley_recipient_payment_methods.
     */
    cursor?: trolley_recipient_payment_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trolley_recipient_payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trolley_recipient_payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trolley_recipient_payment_methods.
     */
    distinct?: Trolley_recipient_payment_methodScalarFieldEnum | Trolley_recipient_payment_methodScalarFieldEnum[]
  }

  /**
   * trolley_recipient_payment_method findMany
   */
  export type trolley_recipient_payment_methodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient_payment_method
     */
    select?: trolley_recipient_payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient_payment_method
     */
    omit?: trolley_recipient_payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipient_payment_methodInclude<ExtArgs> | null
    /**
     * Filter, which trolley_recipient_payment_methods to fetch.
     */
    where?: trolley_recipient_payment_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trolley_recipient_payment_methods to fetch.
     */
    orderBy?: trolley_recipient_payment_methodOrderByWithRelationInput | trolley_recipient_payment_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trolley_recipient_payment_methods.
     */
    cursor?: trolley_recipient_payment_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trolley_recipient_payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trolley_recipient_payment_methods.
     */
    skip?: number
    distinct?: Trolley_recipient_payment_methodScalarFieldEnum | Trolley_recipient_payment_methodScalarFieldEnum[]
  }

  /**
   * trolley_recipient_payment_method create
   */
  export type trolley_recipient_payment_methodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient_payment_method
     */
    select?: trolley_recipient_payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient_payment_method
     */
    omit?: trolley_recipient_payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipient_payment_methodInclude<ExtArgs> | null
    /**
     * The data needed to create a trolley_recipient_payment_method.
     */
    data: XOR<trolley_recipient_payment_methodCreateInput, trolley_recipient_payment_methodUncheckedCreateInput>
  }

  /**
   * trolley_recipient_payment_method createMany
   */
  export type trolley_recipient_payment_methodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many trolley_recipient_payment_methods.
     */
    data: trolley_recipient_payment_methodCreateManyInput | trolley_recipient_payment_methodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * trolley_recipient_payment_method createManyAndReturn
   */
  export type trolley_recipient_payment_methodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient_payment_method
     */
    select?: trolley_recipient_payment_methodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient_payment_method
     */
    omit?: trolley_recipient_payment_methodOmit<ExtArgs> | null
    /**
     * The data used to create many trolley_recipient_payment_methods.
     */
    data: trolley_recipient_payment_methodCreateManyInput | trolley_recipient_payment_methodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipient_payment_methodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * trolley_recipient_payment_method update
   */
  export type trolley_recipient_payment_methodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient_payment_method
     */
    select?: trolley_recipient_payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient_payment_method
     */
    omit?: trolley_recipient_payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipient_payment_methodInclude<ExtArgs> | null
    /**
     * The data needed to update a trolley_recipient_payment_method.
     */
    data: XOR<trolley_recipient_payment_methodUpdateInput, trolley_recipient_payment_methodUncheckedUpdateInput>
    /**
     * Choose, which trolley_recipient_payment_method to update.
     */
    where: trolley_recipient_payment_methodWhereUniqueInput
  }

  /**
   * trolley_recipient_payment_method updateMany
   */
  export type trolley_recipient_payment_methodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update trolley_recipient_payment_methods.
     */
    data: XOR<trolley_recipient_payment_methodUpdateManyMutationInput, trolley_recipient_payment_methodUncheckedUpdateManyInput>
    /**
     * Filter which trolley_recipient_payment_methods to update
     */
    where?: trolley_recipient_payment_methodWhereInput
    /**
     * Limit how many trolley_recipient_payment_methods to update.
     */
    limit?: number
  }

  /**
   * trolley_recipient_payment_method updateManyAndReturn
   */
  export type trolley_recipient_payment_methodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient_payment_method
     */
    select?: trolley_recipient_payment_methodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient_payment_method
     */
    omit?: trolley_recipient_payment_methodOmit<ExtArgs> | null
    /**
     * The data used to update trolley_recipient_payment_methods.
     */
    data: XOR<trolley_recipient_payment_methodUpdateManyMutationInput, trolley_recipient_payment_methodUncheckedUpdateManyInput>
    /**
     * Filter which trolley_recipient_payment_methods to update
     */
    where?: trolley_recipient_payment_methodWhereInput
    /**
     * Limit how many trolley_recipient_payment_methods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipient_payment_methodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * trolley_recipient_payment_method upsert
   */
  export type trolley_recipient_payment_methodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient_payment_method
     */
    select?: trolley_recipient_payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient_payment_method
     */
    omit?: trolley_recipient_payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipient_payment_methodInclude<ExtArgs> | null
    /**
     * The filter to search for the trolley_recipient_payment_method to update in case it exists.
     */
    where: trolley_recipient_payment_methodWhereUniqueInput
    /**
     * In case the trolley_recipient_payment_method found by the `where` argument doesn't exist, create a new trolley_recipient_payment_method with this data.
     */
    create: XOR<trolley_recipient_payment_methodCreateInput, trolley_recipient_payment_methodUncheckedCreateInput>
    /**
     * In case the trolley_recipient_payment_method was found with the provided `where` argument, update it with this data.
     */
    update: XOR<trolley_recipient_payment_methodUpdateInput, trolley_recipient_payment_methodUncheckedUpdateInput>
  }

  /**
   * trolley_recipient_payment_method delete
   */
  export type trolley_recipient_payment_methodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient_payment_method
     */
    select?: trolley_recipient_payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient_payment_method
     */
    omit?: trolley_recipient_payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipient_payment_methodInclude<ExtArgs> | null
    /**
     * Filter which trolley_recipient_payment_method to delete.
     */
    where: trolley_recipient_payment_methodWhereUniqueInput
  }

  /**
   * trolley_recipient_payment_method deleteMany
   */
  export type trolley_recipient_payment_methodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trolley_recipient_payment_methods to delete
     */
    where?: trolley_recipient_payment_methodWhereInput
    /**
     * Limit how many trolley_recipient_payment_methods to delete.
     */
    limit?: number
  }

  /**
   * trolley_recipient_payment_method without action
   */
  export type trolley_recipient_payment_methodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trolley_recipient_payment_method
     */
    select?: trolley_recipient_payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trolley_recipient_payment_method
     */
    omit?: trolley_recipient_payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trolley_recipient_payment_methodInclude<ExtArgs> | null
  }


  /**
   * Model challenge_lock
   */

  export type AggregateChallenge_lock = {
    _count: Challenge_lockCountAggregateOutputType | null
    _avg: Challenge_lockAvgAggregateOutputType | null
    _sum: Challenge_lockSumAggregateOutputType | null
    _min: Challenge_lockMinAggregateOutputType | null
    _max: Challenge_lockMaxAggregateOutputType | null
  }

  export type Challenge_lockAvgAggregateOutputType = {
    id: number | null
  }

  export type Challenge_lockSumAggregateOutputType = {
    id: number | null
  }

  export type Challenge_lockMinAggregateOutputType = {
    id: number | null
    external_id: string | null
    lock_time: Date | null
    error: string | null
  }

  export type Challenge_lockMaxAggregateOutputType = {
    id: number | null
    external_id: string | null
    lock_time: Date | null
    error: string | null
  }

  export type Challenge_lockCountAggregateOutputType = {
    id: number
    external_id: number
    lock_time: number
    error: number
    _all: number
  }


  export type Challenge_lockAvgAggregateInputType = {
    id?: true
  }

  export type Challenge_lockSumAggregateInputType = {
    id?: true
  }

  export type Challenge_lockMinAggregateInputType = {
    id?: true
    external_id?: true
    lock_time?: true
    error?: true
  }

  export type Challenge_lockMaxAggregateInputType = {
    id?: true
    external_id?: true
    lock_time?: true
    error?: true
  }

  export type Challenge_lockCountAggregateInputType = {
    id?: true
    external_id?: true
    lock_time?: true
    error?: true
    _all?: true
  }

  export type Challenge_lockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which challenge_lock to aggregate.
     */
    where?: challenge_lockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of challenge_locks to fetch.
     */
    orderBy?: challenge_lockOrderByWithRelationInput | challenge_lockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: challenge_lockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` challenge_locks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` challenge_locks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned challenge_locks
    **/
    _count?: true | Challenge_lockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Challenge_lockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Challenge_lockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Challenge_lockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Challenge_lockMaxAggregateInputType
  }

  export type GetChallenge_lockAggregateType<T extends Challenge_lockAggregateArgs> = {
        [P in keyof T & keyof AggregateChallenge_lock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallenge_lock[P]>
      : GetScalarType<T[P], AggregateChallenge_lock[P]>
  }




  export type challenge_lockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: challenge_lockWhereInput
    orderBy?: challenge_lockOrderByWithAggregationInput | challenge_lockOrderByWithAggregationInput[]
    by: Challenge_lockScalarFieldEnum[] | Challenge_lockScalarFieldEnum
    having?: challenge_lockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Challenge_lockCountAggregateInputType | true
    _avg?: Challenge_lockAvgAggregateInputType
    _sum?: Challenge_lockSumAggregateInputType
    _min?: Challenge_lockMinAggregateInputType
    _max?: Challenge_lockMaxAggregateInputType
  }

  export type Challenge_lockGroupByOutputType = {
    id: number
    external_id: string
    lock_time: Date
    error: string | null
    _count: Challenge_lockCountAggregateOutputType | null
    _avg: Challenge_lockAvgAggregateOutputType | null
    _sum: Challenge_lockSumAggregateOutputType | null
    _min: Challenge_lockMinAggregateOutputType | null
    _max: Challenge_lockMaxAggregateOutputType | null
  }

  type GetChallenge_lockGroupByPayload<T extends challenge_lockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Challenge_lockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Challenge_lockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Challenge_lockGroupByOutputType[P]>
            : GetScalarType<T[P], Challenge_lockGroupByOutputType[P]>
        }
      >
    >


  export type challenge_lockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    external_id?: boolean
    lock_time?: boolean
    error?: boolean
  }, ExtArgs["result"]["challenge_lock"]>

  export type challenge_lockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    external_id?: boolean
    lock_time?: boolean
    error?: boolean
  }, ExtArgs["result"]["challenge_lock"]>

  export type challenge_lockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    external_id?: boolean
    lock_time?: boolean
    error?: boolean
  }, ExtArgs["result"]["challenge_lock"]>

  export type challenge_lockSelectScalar = {
    id?: boolean
    external_id?: boolean
    lock_time?: boolean
    error?: boolean
  }

  export type challenge_lockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "external_id" | "lock_time" | "error", ExtArgs["result"]["challenge_lock"]>

  export type $challenge_lockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "challenge_lock"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      external_id: string
      lock_time: Date
      error: string | null
    }, ExtArgs["result"]["challenge_lock"]>
    composites: {}
  }

  type challenge_lockGetPayload<S extends boolean | null | undefined | challenge_lockDefaultArgs> = $Result.GetResult<Prisma.$challenge_lockPayload, S>

  type challenge_lockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<challenge_lockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Challenge_lockCountAggregateInputType | true
    }

  export interface challenge_lockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['challenge_lock'], meta: { name: 'challenge_lock' } }
    /**
     * Find zero or one Challenge_lock that matches the filter.
     * @param {challenge_lockFindUniqueArgs} args - Arguments to find a Challenge_lock
     * @example
     * // Get one Challenge_lock
     * const challenge_lock = await prisma.challenge_lock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends challenge_lockFindUniqueArgs>(args: SelectSubset<T, challenge_lockFindUniqueArgs<ExtArgs>>): Prisma__challenge_lockClient<$Result.GetResult<Prisma.$challenge_lockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Challenge_lock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {challenge_lockFindUniqueOrThrowArgs} args - Arguments to find a Challenge_lock
     * @example
     * // Get one Challenge_lock
     * const challenge_lock = await prisma.challenge_lock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends challenge_lockFindUniqueOrThrowArgs>(args: SelectSubset<T, challenge_lockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__challenge_lockClient<$Result.GetResult<Prisma.$challenge_lockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Challenge_lock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {challenge_lockFindFirstArgs} args - Arguments to find a Challenge_lock
     * @example
     * // Get one Challenge_lock
     * const challenge_lock = await prisma.challenge_lock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends challenge_lockFindFirstArgs>(args?: SelectSubset<T, challenge_lockFindFirstArgs<ExtArgs>>): Prisma__challenge_lockClient<$Result.GetResult<Prisma.$challenge_lockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Challenge_lock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {challenge_lockFindFirstOrThrowArgs} args - Arguments to find a Challenge_lock
     * @example
     * // Get one Challenge_lock
     * const challenge_lock = await prisma.challenge_lock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends challenge_lockFindFirstOrThrowArgs>(args?: SelectSubset<T, challenge_lockFindFirstOrThrowArgs<ExtArgs>>): Prisma__challenge_lockClient<$Result.GetResult<Prisma.$challenge_lockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Challenge_locks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {challenge_lockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Challenge_locks
     * const challenge_locks = await prisma.challenge_lock.findMany()
     * 
     * // Get first 10 Challenge_locks
     * const challenge_locks = await prisma.challenge_lock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challenge_lockWithIdOnly = await prisma.challenge_lock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends challenge_lockFindManyArgs>(args?: SelectSubset<T, challenge_lockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$challenge_lockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Challenge_lock.
     * @param {challenge_lockCreateArgs} args - Arguments to create a Challenge_lock.
     * @example
     * // Create one Challenge_lock
     * const Challenge_lock = await prisma.challenge_lock.create({
     *   data: {
     *     // ... data to create a Challenge_lock
     *   }
     * })
     * 
     */
    create<T extends challenge_lockCreateArgs>(args: SelectSubset<T, challenge_lockCreateArgs<ExtArgs>>): Prisma__challenge_lockClient<$Result.GetResult<Prisma.$challenge_lockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Challenge_locks.
     * @param {challenge_lockCreateManyArgs} args - Arguments to create many Challenge_locks.
     * @example
     * // Create many Challenge_locks
     * const challenge_lock = await prisma.challenge_lock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends challenge_lockCreateManyArgs>(args?: SelectSubset<T, challenge_lockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Challenge_locks and returns the data saved in the database.
     * @param {challenge_lockCreateManyAndReturnArgs} args - Arguments to create many Challenge_locks.
     * @example
     * // Create many Challenge_locks
     * const challenge_lock = await prisma.challenge_lock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Challenge_locks and only return the `id`
     * const challenge_lockWithIdOnly = await prisma.challenge_lock.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends challenge_lockCreateManyAndReturnArgs>(args?: SelectSubset<T, challenge_lockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$challenge_lockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Challenge_lock.
     * @param {challenge_lockDeleteArgs} args - Arguments to delete one Challenge_lock.
     * @example
     * // Delete one Challenge_lock
     * const Challenge_lock = await prisma.challenge_lock.delete({
     *   where: {
     *     // ... filter to delete one Challenge_lock
     *   }
     * })
     * 
     */
    delete<T extends challenge_lockDeleteArgs>(args: SelectSubset<T, challenge_lockDeleteArgs<ExtArgs>>): Prisma__challenge_lockClient<$Result.GetResult<Prisma.$challenge_lockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Challenge_lock.
     * @param {challenge_lockUpdateArgs} args - Arguments to update one Challenge_lock.
     * @example
     * // Update one Challenge_lock
     * const challenge_lock = await prisma.challenge_lock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends challenge_lockUpdateArgs>(args: SelectSubset<T, challenge_lockUpdateArgs<ExtArgs>>): Prisma__challenge_lockClient<$Result.GetResult<Prisma.$challenge_lockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Challenge_locks.
     * @param {challenge_lockDeleteManyArgs} args - Arguments to filter Challenge_locks to delete.
     * @example
     * // Delete a few Challenge_locks
     * const { count } = await prisma.challenge_lock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends challenge_lockDeleteManyArgs>(args?: SelectSubset<T, challenge_lockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Challenge_locks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {challenge_lockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Challenge_locks
     * const challenge_lock = await prisma.challenge_lock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends challenge_lockUpdateManyArgs>(args: SelectSubset<T, challenge_lockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Challenge_locks and returns the data updated in the database.
     * @param {challenge_lockUpdateManyAndReturnArgs} args - Arguments to update many Challenge_locks.
     * @example
     * // Update many Challenge_locks
     * const challenge_lock = await prisma.challenge_lock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Challenge_locks and only return the `id`
     * const challenge_lockWithIdOnly = await prisma.challenge_lock.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends challenge_lockUpdateManyAndReturnArgs>(args: SelectSubset<T, challenge_lockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$challenge_lockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Challenge_lock.
     * @param {challenge_lockUpsertArgs} args - Arguments to update or create a Challenge_lock.
     * @example
     * // Update or create a Challenge_lock
     * const challenge_lock = await prisma.challenge_lock.upsert({
     *   create: {
     *     // ... data to create a Challenge_lock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Challenge_lock we want to update
     *   }
     * })
     */
    upsert<T extends challenge_lockUpsertArgs>(args: SelectSubset<T, challenge_lockUpsertArgs<ExtArgs>>): Prisma__challenge_lockClient<$Result.GetResult<Prisma.$challenge_lockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Challenge_locks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {challenge_lockCountArgs} args - Arguments to filter Challenge_locks to count.
     * @example
     * // Count the number of Challenge_locks
     * const count = await prisma.challenge_lock.count({
     *   where: {
     *     // ... the filter for the Challenge_locks we want to count
     *   }
     * })
    **/
    count<T extends challenge_lockCountArgs>(
      args?: Subset<T, challenge_lockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Challenge_lockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Challenge_lock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Challenge_lockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Challenge_lockAggregateArgs>(args: Subset<T, Challenge_lockAggregateArgs>): Prisma.PrismaPromise<GetChallenge_lockAggregateType<T>>

    /**
     * Group by Challenge_lock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {challenge_lockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends challenge_lockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: challenge_lockGroupByArgs['orderBy'] }
        : { orderBy?: challenge_lockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, challenge_lockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallenge_lockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the challenge_lock model
   */
  readonly fields: challenge_lockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for challenge_lock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__challenge_lockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the challenge_lock model
   */
  interface challenge_lockFieldRefs {
    readonly id: FieldRef<"challenge_lock", 'Int'>
    readonly external_id: FieldRef<"challenge_lock", 'String'>
    readonly lock_time: FieldRef<"challenge_lock", 'DateTime'>
    readonly error: FieldRef<"challenge_lock", 'String'>
  }
    

  // Custom InputTypes
  /**
   * challenge_lock findUnique
   */
  export type challenge_lockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_lock
     */
    select?: challenge_lockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the challenge_lock
     */
    omit?: challenge_lockOmit<ExtArgs> | null
    /**
     * Filter, which challenge_lock to fetch.
     */
    where: challenge_lockWhereUniqueInput
  }

  /**
   * challenge_lock findUniqueOrThrow
   */
  export type challenge_lockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_lock
     */
    select?: challenge_lockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the challenge_lock
     */
    omit?: challenge_lockOmit<ExtArgs> | null
    /**
     * Filter, which challenge_lock to fetch.
     */
    where: challenge_lockWhereUniqueInput
  }

  /**
   * challenge_lock findFirst
   */
  export type challenge_lockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_lock
     */
    select?: challenge_lockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the challenge_lock
     */
    omit?: challenge_lockOmit<ExtArgs> | null
    /**
     * Filter, which challenge_lock to fetch.
     */
    where?: challenge_lockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of challenge_locks to fetch.
     */
    orderBy?: challenge_lockOrderByWithRelationInput | challenge_lockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for challenge_locks.
     */
    cursor?: challenge_lockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` challenge_locks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` challenge_locks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of challenge_locks.
     */
    distinct?: Challenge_lockScalarFieldEnum | Challenge_lockScalarFieldEnum[]
  }

  /**
   * challenge_lock findFirstOrThrow
   */
  export type challenge_lockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_lock
     */
    select?: challenge_lockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the challenge_lock
     */
    omit?: challenge_lockOmit<ExtArgs> | null
    /**
     * Filter, which challenge_lock to fetch.
     */
    where?: challenge_lockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of challenge_locks to fetch.
     */
    orderBy?: challenge_lockOrderByWithRelationInput | challenge_lockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for challenge_locks.
     */
    cursor?: challenge_lockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` challenge_locks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` challenge_locks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of challenge_locks.
     */
    distinct?: Challenge_lockScalarFieldEnum | Challenge_lockScalarFieldEnum[]
  }

  /**
   * challenge_lock findMany
   */
  export type challenge_lockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_lock
     */
    select?: challenge_lockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the challenge_lock
     */
    omit?: challenge_lockOmit<ExtArgs> | null
    /**
     * Filter, which challenge_locks to fetch.
     */
    where?: challenge_lockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of challenge_locks to fetch.
     */
    orderBy?: challenge_lockOrderByWithRelationInput | challenge_lockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing challenge_locks.
     */
    cursor?: challenge_lockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` challenge_locks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` challenge_locks.
     */
    skip?: number
    distinct?: Challenge_lockScalarFieldEnum | Challenge_lockScalarFieldEnum[]
  }

  /**
   * challenge_lock create
   */
  export type challenge_lockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_lock
     */
    select?: challenge_lockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the challenge_lock
     */
    omit?: challenge_lockOmit<ExtArgs> | null
    /**
     * The data needed to create a challenge_lock.
     */
    data: XOR<challenge_lockCreateInput, challenge_lockUncheckedCreateInput>
  }

  /**
   * challenge_lock createMany
   */
  export type challenge_lockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many challenge_locks.
     */
    data: challenge_lockCreateManyInput | challenge_lockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * challenge_lock createManyAndReturn
   */
  export type challenge_lockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_lock
     */
    select?: challenge_lockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the challenge_lock
     */
    omit?: challenge_lockOmit<ExtArgs> | null
    /**
     * The data used to create many challenge_locks.
     */
    data: challenge_lockCreateManyInput | challenge_lockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * challenge_lock update
   */
  export type challenge_lockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_lock
     */
    select?: challenge_lockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the challenge_lock
     */
    omit?: challenge_lockOmit<ExtArgs> | null
    /**
     * The data needed to update a challenge_lock.
     */
    data: XOR<challenge_lockUpdateInput, challenge_lockUncheckedUpdateInput>
    /**
     * Choose, which challenge_lock to update.
     */
    where: challenge_lockWhereUniqueInput
  }

  /**
   * challenge_lock updateMany
   */
  export type challenge_lockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update challenge_locks.
     */
    data: XOR<challenge_lockUpdateManyMutationInput, challenge_lockUncheckedUpdateManyInput>
    /**
     * Filter which challenge_locks to update
     */
    where?: challenge_lockWhereInput
    /**
     * Limit how many challenge_locks to update.
     */
    limit?: number
  }

  /**
   * challenge_lock updateManyAndReturn
   */
  export type challenge_lockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_lock
     */
    select?: challenge_lockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the challenge_lock
     */
    omit?: challenge_lockOmit<ExtArgs> | null
    /**
     * The data used to update challenge_locks.
     */
    data: XOR<challenge_lockUpdateManyMutationInput, challenge_lockUncheckedUpdateManyInput>
    /**
     * Filter which challenge_locks to update
     */
    where?: challenge_lockWhereInput
    /**
     * Limit how many challenge_locks to update.
     */
    limit?: number
  }

  /**
   * challenge_lock upsert
   */
  export type challenge_lockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_lock
     */
    select?: challenge_lockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the challenge_lock
     */
    omit?: challenge_lockOmit<ExtArgs> | null
    /**
     * The filter to search for the challenge_lock to update in case it exists.
     */
    where: challenge_lockWhereUniqueInput
    /**
     * In case the challenge_lock found by the `where` argument doesn't exist, create a new challenge_lock with this data.
     */
    create: XOR<challenge_lockCreateInput, challenge_lockUncheckedCreateInput>
    /**
     * In case the challenge_lock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<challenge_lockUpdateInput, challenge_lockUncheckedUpdateInput>
  }

  /**
   * challenge_lock delete
   */
  export type challenge_lockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_lock
     */
    select?: challenge_lockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the challenge_lock
     */
    omit?: challenge_lockOmit<ExtArgs> | null
    /**
     * Filter which challenge_lock to delete.
     */
    where: challenge_lockWhereUniqueInput
  }

  /**
   * challenge_lock deleteMany
   */
  export type challenge_lockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which challenge_locks to delete
     */
    where?: challenge_lockWhereInput
    /**
     * Limit how many challenge_locks to delete.
     */
    limit?: number
  }

  /**
   * challenge_lock without action
   */
  export type challenge_lockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_lock
     */
    select?: challenge_lockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the challenge_lock
     */
    omit?: challenge_lockOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AuditScalarFieldEnum: {
    id: 'id',
    winnings_id: 'winnings_id',
    user_id: 'user_id',
    action: 'action',
    note: 'note',
    created_at: 'created_at'
  };

  export type AuditScalarFieldEnum = (typeof AuditScalarFieldEnum)[keyof typeof AuditScalarFieldEnum]


  export const OriginScalarFieldEnum: {
    origin_id: 'origin_id',
    origin_name: 'origin_name'
  };

  export type OriginScalarFieldEnum = (typeof OriginScalarFieldEnum)[keyof typeof OriginScalarFieldEnum]


  export const OtpScalarFieldEnum: {
    id: 'id',
    email: 'email',
    otp_hash: 'otp_hash',
    expiration_time: 'expiration_time',
    action_type: 'action_type',
    created_at: 'created_at',
    updated_at: 'updated_at',
    verified_at: 'verified_at'
  };

  export type OtpScalarFieldEnum = (typeof OtpScalarFieldEnum)[keyof typeof OtpScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    payment_id: 'payment_id',
    winnings_id: 'winnings_id',
    net_amount: 'net_amount',
    gross_amount: 'gross_amount',
    total_amount: 'total_amount',
    installment_number: 'installment_number',
    date_paid: 'date_paid',
    payment_method_id: 'payment_method_id',
    currency: 'currency',
    created_by: 'created_by',
    updated_by: 'updated_by',
    created_at: 'created_at',
    updated_at: 'updated_at',
    version: 'version',
    release_date: 'release_date',
    payment_status: 'payment_status',
    billing_account: 'billing_account',
    challenge_markup: 'challenge_markup',
    challenge_fee: 'challenge_fee'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const Payment_methodScalarFieldEnum: {
    payment_method_id: 'payment_method_id',
    payment_method_type: 'payment_method_type',
    name: 'name',
    description: 'description'
  };

  export type Payment_methodScalarFieldEnum = (typeof Payment_methodScalarFieldEnum)[keyof typeof Payment_methodScalarFieldEnum]


  export const Payment_release_associationsScalarFieldEnum: {
    payment_release_id: 'payment_release_id',
    payment_id: 'payment_id'
  };

  export type Payment_release_associationsScalarFieldEnum = (typeof Payment_release_associationsScalarFieldEnum)[keyof typeof Payment_release_associationsScalarFieldEnum]


  export const Payment_releasesScalarFieldEnum: {
    payment_release_id: 'payment_release_id',
    user_id: 'user_id',
    total_net_amount: 'total_net_amount',
    payment_method_id: 'payment_method_id',
    status: 'status',
    external_transaction_id: 'external_transaction_id',
    metadata: 'metadata',
    created_at: 'created_at',
    payee_id: 'payee_id',
    release_date: 'release_date',
    batch_id: 'batch_id'
  };

  export type Payment_releasesScalarFieldEnum = (typeof Payment_releasesScalarFieldEnum)[keyof typeof Payment_releasesScalarFieldEnum]


  export const User_payment_methodsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    payment_method_id: 'payment_method_id',
    status: 'status'
  };

  export type User_payment_methodsScalarFieldEnum = (typeof User_payment_methodsScalarFieldEnum)[keyof typeof User_payment_methodsScalarFieldEnum]


  export const User_tax_form_associationsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    tax_form_id: 'tax_form_id',
    date_filed: 'date_filed',
    tax_form_status: 'tax_form_status'
  };

  export type User_tax_form_associationsScalarFieldEnum = (typeof User_tax_form_associationsScalarFieldEnum)[keyof typeof User_tax_form_associationsScalarFieldEnum]


  export const WinningsScalarFieldEnum: {
    winning_id: 'winning_id',
    winner_id: 'winner_id',
    type: 'type',
    origin_id: 'origin_id',
    category: 'category',
    title: 'title',
    description: 'description',
    external_id: 'external_id',
    attributes: 'attributes',
    created_by: 'created_by',
    updated_by: 'updated_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type WinningsScalarFieldEnum = (typeof WinningsScalarFieldEnum)[keyof typeof WinningsScalarFieldEnum]


  export const Trolley_recipientScalarFieldEnum: {
    id: 'id',
    user_payment_method_id: 'user_payment_method_id',
    user_id: 'user_id',
    trolley_id: 'trolley_id'
  };

  export type Trolley_recipientScalarFieldEnum = (typeof Trolley_recipientScalarFieldEnum)[keyof typeof Trolley_recipientScalarFieldEnum]


  export const Trolley_webhook_logScalarFieldEnum: {
    id: 'id',
    event_id: 'event_id',
    event_time: 'event_time',
    event_payload: 'event_payload',
    event_model: 'event_model',
    event_action: 'event_action',
    status: 'status',
    error_message: 'error_message',
    created_at: 'created_at'
  };

  export type Trolley_webhook_logScalarFieldEnum = (typeof Trolley_webhook_logScalarFieldEnum)[keyof typeof Trolley_webhook_logScalarFieldEnum]


  export const User_identity_verification_associationsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    verification_id: 'verification_id',
    date_filed: 'date_filed',
    verification_status: 'verification_status'
  };

  export type User_identity_verification_associationsScalarFieldEnum = (typeof User_identity_verification_associationsScalarFieldEnum)[keyof typeof User_identity_verification_associationsScalarFieldEnum]


  export const Trolley_recipient_payment_methodScalarFieldEnum: {
    id: 'id',
    trolley_recipient_id: 'trolley_recipient_id',
    recipient_account_id: 'recipient_account_id'
  };

  export type Trolley_recipient_payment_methodScalarFieldEnum = (typeof Trolley_recipient_payment_methodScalarFieldEnum)[keyof typeof Trolley_recipient_payment_methodScalarFieldEnum]


  export const Challenge_lockScalarFieldEnum: {
    id: 'id',
    external_id: 'external_id',
    lock_time: 'lock_time',
    error: 'error'
  };

  export type Challenge_lockScalarFieldEnum = (typeof Challenge_lockScalarFieldEnum)[keyof typeof Challenge_lockScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'reference_type'
   */
  export type Enumreference_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'reference_type'>
    


  /**
   * Reference to a field of type 'reference_type[]'
   */
  export type ListEnumreference_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'reference_type[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'payment_status'
   */
  export type Enumpayment_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'payment_status'>
    


  /**
   * Reference to a field of type 'payment_status[]'
   */
  export type ListEnumpayment_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'payment_status[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'payment_method_status'
   */
  export type Enumpayment_method_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'payment_method_status'>
    


  /**
   * Reference to a field of type 'payment_method_status[]'
   */
  export type ListEnumpayment_method_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'payment_method_status[]'>
    


  /**
   * Reference to a field of type 'tax_form_status'
   */
  export type Enumtax_form_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'tax_form_status'>
    


  /**
   * Reference to a field of type 'tax_form_status[]'
   */
  export type ListEnumtax_form_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'tax_form_status[]'>
    


  /**
   * Reference to a field of type 'winnings_type'
   */
  export type Enumwinnings_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'winnings_type'>
    


  /**
   * Reference to a field of type 'winnings_type[]'
   */
  export type ListEnumwinnings_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'winnings_type[]'>
    


  /**
   * Reference to a field of type 'winnings_category'
   */
  export type Enumwinnings_categoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'winnings_category'>
    


  /**
   * Reference to a field of type 'winnings_category[]'
   */
  export type ListEnumwinnings_categoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'winnings_category[]'>
    


  /**
   * Reference to a field of type 'webhook_status'
   */
  export type Enumwebhook_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'webhook_status'>
    


  /**
   * Reference to a field of type 'webhook_status[]'
   */
  export type ListEnumwebhook_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'webhook_status[]'>
    


  /**
   * Reference to a field of type 'verification_status'
   */
  export type Enumverification_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'verification_status'>
    


  /**
   * Reference to a field of type 'verification_status[]'
   */
  export type ListEnumverification_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'verification_status[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type auditWhereInput = {
    AND?: auditWhereInput | auditWhereInput[]
    OR?: auditWhereInput[]
    NOT?: auditWhereInput | auditWhereInput[]
    id?: UuidFilter<"audit"> | string
    winnings_id?: UuidFilter<"audit"> | string
    user_id?: StringFilter<"audit"> | string
    action?: StringFilter<"audit"> | string
    note?: StringNullableFilter<"audit"> | string | null
    created_at?: DateTimeFilter<"audit"> | Date | string
    winnings?: XOR<WinningsScalarRelationFilter, winningsWhereInput>
  }

  export type auditOrderByWithRelationInput = {
    id?: SortOrder
    winnings_id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    note?: SortOrderInput | SortOrder
    created_at?: SortOrder
    winnings?: winningsOrderByWithRelationInput
  }

  export type auditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: auditWhereInput | auditWhereInput[]
    OR?: auditWhereInput[]
    NOT?: auditWhereInput | auditWhereInput[]
    winnings_id?: UuidFilter<"audit"> | string
    user_id?: StringFilter<"audit"> | string
    action?: StringFilter<"audit"> | string
    note?: StringNullableFilter<"audit"> | string | null
    created_at?: DateTimeFilter<"audit"> | Date | string
    winnings?: XOR<WinningsScalarRelationFilter, winningsWhereInput>
  }, "id">

  export type auditOrderByWithAggregationInput = {
    id?: SortOrder
    winnings_id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    note?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: auditCountOrderByAggregateInput
    _max?: auditMaxOrderByAggregateInput
    _min?: auditMinOrderByAggregateInput
  }

  export type auditScalarWhereWithAggregatesInput = {
    AND?: auditScalarWhereWithAggregatesInput | auditScalarWhereWithAggregatesInput[]
    OR?: auditScalarWhereWithAggregatesInput[]
    NOT?: auditScalarWhereWithAggregatesInput | auditScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"audit"> | string
    winnings_id?: UuidWithAggregatesFilter<"audit"> | string
    user_id?: StringWithAggregatesFilter<"audit"> | string
    action?: StringWithAggregatesFilter<"audit"> | string
    note?: StringNullableWithAggregatesFilter<"audit"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"audit"> | Date | string
  }

  export type originWhereInput = {
    AND?: originWhereInput | originWhereInput[]
    OR?: originWhereInput[]
    NOT?: originWhereInput | originWhereInput[]
    origin_id?: IntFilter<"origin"> | number
    origin_name?: StringFilter<"origin"> | string
    winnings?: WinningsListRelationFilter
  }

  export type originOrderByWithRelationInput = {
    origin_id?: SortOrder
    origin_name?: SortOrder
    winnings?: winningsOrderByRelationAggregateInput
  }

  export type originWhereUniqueInput = Prisma.AtLeast<{
    origin_id?: number
    AND?: originWhereInput | originWhereInput[]
    OR?: originWhereInput[]
    NOT?: originWhereInput | originWhereInput[]
    origin_name?: StringFilter<"origin"> | string
    winnings?: WinningsListRelationFilter
  }, "origin_id">

  export type originOrderByWithAggregationInput = {
    origin_id?: SortOrder
    origin_name?: SortOrder
    _count?: originCountOrderByAggregateInput
    _avg?: originAvgOrderByAggregateInput
    _max?: originMaxOrderByAggregateInput
    _min?: originMinOrderByAggregateInput
    _sum?: originSumOrderByAggregateInput
  }

  export type originScalarWhereWithAggregatesInput = {
    AND?: originScalarWhereWithAggregatesInput | originScalarWhereWithAggregatesInput[]
    OR?: originScalarWhereWithAggregatesInput[]
    NOT?: originScalarWhereWithAggregatesInput | originScalarWhereWithAggregatesInput[]
    origin_id?: IntWithAggregatesFilter<"origin"> | number
    origin_name?: StringWithAggregatesFilter<"origin"> | string
  }

  export type otpWhereInput = {
    AND?: otpWhereInput | otpWhereInput[]
    OR?: otpWhereInput[]
    NOT?: otpWhereInput | otpWhereInput[]
    id?: UuidFilter<"otp"> | string
    email?: StringFilter<"otp"> | string
    otp_hash?: StringFilter<"otp"> | string
    expiration_time?: DateTimeFilter<"otp"> | Date | string
    action_type?: Enumreference_typeFilter<"otp"> | $Enums.reference_type
    created_at?: DateTimeNullableFilter<"otp"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"otp"> | Date | string | null
    verified_at?: DateTimeNullableFilter<"otp"> | Date | string | null
  }

  export type otpOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    otp_hash?: SortOrder
    expiration_time?: SortOrder
    action_type?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    verified_at?: SortOrderInput | SortOrder
  }

  export type otpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: otpWhereInput | otpWhereInput[]
    OR?: otpWhereInput[]
    NOT?: otpWhereInput | otpWhereInput[]
    email?: StringFilter<"otp"> | string
    otp_hash?: StringFilter<"otp"> | string
    expiration_time?: DateTimeFilter<"otp"> | Date | string
    action_type?: Enumreference_typeFilter<"otp"> | $Enums.reference_type
    created_at?: DateTimeNullableFilter<"otp"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"otp"> | Date | string | null
    verified_at?: DateTimeNullableFilter<"otp"> | Date | string | null
  }, "id">

  export type otpOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    otp_hash?: SortOrder
    expiration_time?: SortOrder
    action_type?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    verified_at?: SortOrderInput | SortOrder
    _count?: otpCountOrderByAggregateInput
    _max?: otpMaxOrderByAggregateInput
    _min?: otpMinOrderByAggregateInput
  }

  export type otpScalarWhereWithAggregatesInput = {
    AND?: otpScalarWhereWithAggregatesInput | otpScalarWhereWithAggregatesInput[]
    OR?: otpScalarWhereWithAggregatesInput[]
    NOT?: otpScalarWhereWithAggregatesInput | otpScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"otp"> | string
    email?: StringWithAggregatesFilter<"otp"> | string
    otp_hash?: StringWithAggregatesFilter<"otp"> | string
    expiration_time?: DateTimeWithAggregatesFilter<"otp"> | Date | string
    action_type?: Enumreference_typeWithAggregatesFilter<"otp"> | $Enums.reference_type
    created_at?: DateTimeNullableWithAggregatesFilter<"otp"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"otp"> | Date | string | null
    verified_at?: DateTimeNullableWithAggregatesFilter<"otp"> | Date | string | null
  }

  export type paymentWhereInput = {
    AND?: paymentWhereInput | paymentWhereInput[]
    OR?: paymentWhereInput[]
    NOT?: paymentWhereInput | paymentWhereInput[]
    payment_id?: UuidFilter<"payment"> | string
    winnings_id?: UuidFilter<"payment"> | string
    net_amount?: DecimalNullableFilter<"payment"> | Decimal | DecimalJsLike | number | string | null
    gross_amount?: DecimalNullableFilter<"payment"> | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalNullableFilter<"payment"> | Decimal | DecimalJsLike | number | string | null
    installment_number?: IntNullableFilter<"payment"> | number | null
    date_paid?: DateTimeNullableFilter<"payment"> | Date | string | null
    payment_method_id?: IntNullableFilter<"payment"> | number | null
    currency?: StringNullableFilter<"payment"> | string | null
    created_by?: StringFilter<"payment"> | string
    updated_by?: StringNullableFilter<"payment"> | string | null
    created_at?: DateTimeNullableFilter<"payment"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"payment"> | Date | string | null
    version?: IntNullableFilter<"payment"> | number | null
    release_date?: DateTimeNullableFilter<"payment"> | Date | string | null
    payment_status?: Enumpayment_statusNullableFilter<"payment"> | $Enums.payment_status | null
    billing_account?: StringFilter<"payment"> | string
    challenge_markup?: DecimalNullableFilter<"payment"> | Decimal | DecimalJsLike | number | string | null
    challenge_fee?: DecimalNullableFilter<"payment"> | Decimal | DecimalJsLike | number | string | null
    payment_method?: XOR<Payment_methodNullableScalarRelationFilter, payment_methodWhereInput> | null
    winnings?: XOR<WinningsScalarRelationFilter, winningsWhereInput>
    payment_release_associations?: Payment_release_associationsListRelationFilter
  }

  export type paymentOrderByWithRelationInput = {
    payment_id?: SortOrder
    winnings_id?: SortOrder
    net_amount?: SortOrderInput | SortOrder
    gross_amount?: SortOrderInput | SortOrder
    total_amount?: SortOrderInput | SortOrder
    installment_number?: SortOrderInput | SortOrder
    date_paid?: SortOrderInput | SortOrder
    payment_method_id?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    release_date?: SortOrderInput | SortOrder
    payment_status?: SortOrderInput | SortOrder
    billing_account?: SortOrder
    challenge_markup?: SortOrderInput | SortOrder
    challenge_fee?: SortOrderInput | SortOrder
    payment_method?: payment_methodOrderByWithRelationInput
    winnings?: winningsOrderByWithRelationInput
    payment_release_associations?: payment_release_associationsOrderByRelationAggregateInput
  }

  export type paymentWhereUniqueInput = Prisma.AtLeast<{
    payment_id?: string
    AND?: paymentWhereInput | paymentWhereInput[]
    OR?: paymentWhereInput[]
    NOT?: paymentWhereInput | paymentWhereInput[]
    winnings_id?: UuidFilter<"payment"> | string
    net_amount?: DecimalNullableFilter<"payment"> | Decimal | DecimalJsLike | number | string | null
    gross_amount?: DecimalNullableFilter<"payment"> | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalNullableFilter<"payment"> | Decimal | DecimalJsLike | number | string | null
    installment_number?: IntNullableFilter<"payment"> | number | null
    date_paid?: DateTimeNullableFilter<"payment"> | Date | string | null
    payment_method_id?: IntNullableFilter<"payment"> | number | null
    currency?: StringNullableFilter<"payment"> | string | null
    created_by?: StringFilter<"payment"> | string
    updated_by?: StringNullableFilter<"payment"> | string | null
    created_at?: DateTimeNullableFilter<"payment"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"payment"> | Date | string | null
    version?: IntNullableFilter<"payment"> | number | null
    release_date?: DateTimeNullableFilter<"payment"> | Date | string | null
    payment_status?: Enumpayment_statusNullableFilter<"payment"> | $Enums.payment_status | null
    billing_account?: StringFilter<"payment"> | string
    challenge_markup?: DecimalNullableFilter<"payment"> | Decimal | DecimalJsLike | number | string | null
    challenge_fee?: DecimalNullableFilter<"payment"> | Decimal | DecimalJsLike | number | string | null
    payment_method?: XOR<Payment_methodNullableScalarRelationFilter, payment_methodWhereInput> | null
    winnings?: XOR<WinningsScalarRelationFilter, winningsWhereInput>
    payment_release_associations?: Payment_release_associationsListRelationFilter
  }, "payment_id">

  export type paymentOrderByWithAggregationInput = {
    payment_id?: SortOrder
    winnings_id?: SortOrder
    net_amount?: SortOrderInput | SortOrder
    gross_amount?: SortOrderInput | SortOrder
    total_amount?: SortOrderInput | SortOrder
    installment_number?: SortOrderInput | SortOrder
    date_paid?: SortOrderInput | SortOrder
    payment_method_id?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    release_date?: SortOrderInput | SortOrder
    payment_status?: SortOrderInput | SortOrder
    billing_account?: SortOrder
    challenge_markup?: SortOrderInput | SortOrder
    challenge_fee?: SortOrderInput | SortOrder
    _count?: paymentCountOrderByAggregateInput
    _avg?: paymentAvgOrderByAggregateInput
    _max?: paymentMaxOrderByAggregateInput
    _min?: paymentMinOrderByAggregateInput
    _sum?: paymentSumOrderByAggregateInput
  }

  export type paymentScalarWhereWithAggregatesInput = {
    AND?: paymentScalarWhereWithAggregatesInput | paymentScalarWhereWithAggregatesInput[]
    OR?: paymentScalarWhereWithAggregatesInput[]
    NOT?: paymentScalarWhereWithAggregatesInput | paymentScalarWhereWithAggregatesInput[]
    payment_id?: UuidWithAggregatesFilter<"payment"> | string
    winnings_id?: UuidWithAggregatesFilter<"payment"> | string
    net_amount?: DecimalNullableWithAggregatesFilter<"payment"> | Decimal | DecimalJsLike | number | string | null
    gross_amount?: DecimalNullableWithAggregatesFilter<"payment"> | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalNullableWithAggregatesFilter<"payment"> | Decimal | DecimalJsLike | number | string | null
    installment_number?: IntNullableWithAggregatesFilter<"payment"> | number | null
    date_paid?: DateTimeNullableWithAggregatesFilter<"payment"> | Date | string | null
    payment_method_id?: IntNullableWithAggregatesFilter<"payment"> | number | null
    currency?: StringNullableWithAggregatesFilter<"payment"> | string | null
    created_by?: StringWithAggregatesFilter<"payment"> | string
    updated_by?: StringNullableWithAggregatesFilter<"payment"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"payment"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"payment"> | Date | string | null
    version?: IntNullableWithAggregatesFilter<"payment"> | number | null
    release_date?: DateTimeNullableWithAggregatesFilter<"payment"> | Date | string | null
    payment_status?: Enumpayment_statusNullableWithAggregatesFilter<"payment"> | $Enums.payment_status | null
    billing_account?: StringWithAggregatesFilter<"payment"> | string
    challenge_markup?: DecimalNullableWithAggregatesFilter<"payment"> | Decimal | DecimalJsLike | number | string | null
    challenge_fee?: DecimalNullableWithAggregatesFilter<"payment"> | Decimal | DecimalJsLike | number | string | null
  }

  export type payment_methodWhereInput = {
    AND?: payment_methodWhereInput | payment_methodWhereInput[]
    OR?: payment_methodWhereInput[]
    NOT?: payment_methodWhereInput | payment_methodWhereInput[]
    payment_method_id?: IntFilter<"payment_method"> | number
    payment_method_type?: StringFilter<"payment_method"> | string
    name?: StringFilter<"payment_method"> | string
    description?: StringNullableFilter<"payment_method"> | string | null
    payment?: PaymentListRelationFilter
    payment_releases?: Payment_releasesListRelationFilter
    user_payment_methods?: User_payment_methodsListRelationFilter
  }

  export type payment_methodOrderByWithRelationInput = {
    payment_method_id?: SortOrder
    payment_method_type?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    payment?: paymentOrderByRelationAggregateInput
    payment_releases?: payment_releasesOrderByRelationAggregateInput
    user_payment_methods?: user_payment_methodsOrderByRelationAggregateInput
  }

  export type payment_methodWhereUniqueInput = Prisma.AtLeast<{
    payment_method_id?: number
    payment_method_type?: string
    AND?: payment_methodWhereInput | payment_methodWhereInput[]
    OR?: payment_methodWhereInput[]
    NOT?: payment_methodWhereInput | payment_methodWhereInput[]
    name?: StringFilter<"payment_method"> | string
    description?: StringNullableFilter<"payment_method"> | string | null
    payment?: PaymentListRelationFilter
    payment_releases?: Payment_releasesListRelationFilter
    user_payment_methods?: User_payment_methodsListRelationFilter
  }, "payment_method_id" | "payment_method_type">

  export type payment_methodOrderByWithAggregationInput = {
    payment_method_id?: SortOrder
    payment_method_type?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: payment_methodCountOrderByAggregateInput
    _avg?: payment_methodAvgOrderByAggregateInput
    _max?: payment_methodMaxOrderByAggregateInput
    _min?: payment_methodMinOrderByAggregateInput
    _sum?: payment_methodSumOrderByAggregateInput
  }

  export type payment_methodScalarWhereWithAggregatesInput = {
    AND?: payment_methodScalarWhereWithAggregatesInput | payment_methodScalarWhereWithAggregatesInput[]
    OR?: payment_methodScalarWhereWithAggregatesInput[]
    NOT?: payment_methodScalarWhereWithAggregatesInput | payment_methodScalarWhereWithAggregatesInput[]
    payment_method_id?: IntWithAggregatesFilter<"payment_method"> | number
    payment_method_type?: StringWithAggregatesFilter<"payment_method"> | string
    name?: StringWithAggregatesFilter<"payment_method"> | string
    description?: StringNullableWithAggregatesFilter<"payment_method"> | string | null
  }

  export type payment_release_associationsWhereInput = {
    AND?: payment_release_associationsWhereInput | payment_release_associationsWhereInput[]
    OR?: payment_release_associationsWhereInput[]
    NOT?: payment_release_associationsWhereInput | payment_release_associationsWhereInput[]
    payment_release_id?: UuidFilter<"payment_release_associations"> | string
    payment_id?: UuidFilter<"payment_release_associations"> | string
    payment?: XOR<PaymentScalarRelationFilter, paymentWhereInput>
    payment_releases?: XOR<Payment_releasesScalarRelationFilter, payment_releasesWhereInput>
  }

  export type payment_release_associationsOrderByWithRelationInput = {
    payment_release_id?: SortOrder
    payment_id?: SortOrder
    payment?: paymentOrderByWithRelationInput
    payment_releases?: payment_releasesOrderByWithRelationInput
  }

  export type payment_release_associationsWhereUniqueInput = Prisma.AtLeast<{
    payment_release_id_payment_id?: payment_release_associationsPayment_release_idPayment_idCompoundUniqueInput
    AND?: payment_release_associationsWhereInput | payment_release_associationsWhereInput[]
    OR?: payment_release_associationsWhereInput[]
    NOT?: payment_release_associationsWhereInput | payment_release_associationsWhereInput[]
    payment_release_id?: UuidFilter<"payment_release_associations"> | string
    payment_id?: UuidFilter<"payment_release_associations"> | string
    payment?: XOR<PaymentScalarRelationFilter, paymentWhereInput>
    payment_releases?: XOR<Payment_releasesScalarRelationFilter, payment_releasesWhereInput>
  }, "payment_release_id_payment_id">

  export type payment_release_associationsOrderByWithAggregationInput = {
    payment_release_id?: SortOrder
    payment_id?: SortOrder
    _count?: payment_release_associationsCountOrderByAggregateInput
    _max?: payment_release_associationsMaxOrderByAggregateInput
    _min?: payment_release_associationsMinOrderByAggregateInput
  }

  export type payment_release_associationsScalarWhereWithAggregatesInput = {
    AND?: payment_release_associationsScalarWhereWithAggregatesInput | payment_release_associationsScalarWhereWithAggregatesInput[]
    OR?: payment_release_associationsScalarWhereWithAggregatesInput[]
    NOT?: payment_release_associationsScalarWhereWithAggregatesInput | payment_release_associationsScalarWhereWithAggregatesInput[]
    payment_release_id?: UuidWithAggregatesFilter<"payment_release_associations"> | string
    payment_id?: UuidWithAggregatesFilter<"payment_release_associations"> | string
  }

  export type payment_releasesWhereInput = {
    AND?: payment_releasesWhereInput | payment_releasesWhereInput[]
    OR?: payment_releasesWhereInput[]
    NOT?: payment_releasesWhereInput | payment_releasesWhereInput[]
    payment_release_id?: UuidFilter<"payment_releases"> | string
    user_id?: StringFilter<"payment_releases"> | string
    total_net_amount?: DecimalFilter<"payment_releases"> | Decimal | DecimalJsLike | number | string
    payment_method_id?: IntFilter<"payment_releases"> | number
    status?: StringNullableFilter<"payment_releases"> | string | null
    external_transaction_id?: StringNullableFilter<"payment_releases"> | string | null
    metadata?: JsonNullableFilter<"payment_releases">
    created_at?: DateTimeNullableFilter<"payment_releases"> | Date | string | null
    payee_id?: StringNullableFilter<"payment_releases"> | string | null
    release_date?: DateTimeNullableFilter<"payment_releases"> | Date | string | null
    batch_id?: UuidNullableFilter<"payment_releases"> | string | null
    payment_release_associations?: Payment_release_associationsListRelationFilter
    payment_method?: XOR<Payment_methodScalarRelationFilter, payment_methodWhereInput>
  }

  export type payment_releasesOrderByWithRelationInput = {
    payment_release_id?: SortOrder
    user_id?: SortOrder
    total_net_amount?: SortOrder
    payment_method_id?: SortOrder
    status?: SortOrderInput | SortOrder
    external_transaction_id?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    payee_id?: SortOrderInput | SortOrder
    release_date?: SortOrderInput | SortOrder
    batch_id?: SortOrderInput | SortOrder
    payment_release_associations?: payment_release_associationsOrderByRelationAggregateInput
    payment_method?: payment_methodOrderByWithRelationInput
  }

  export type payment_releasesWhereUniqueInput = Prisma.AtLeast<{
    payment_release_id?: string
    AND?: payment_releasesWhereInput | payment_releasesWhereInput[]
    OR?: payment_releasesWhereInput[]
    NOT?: payment_releasesWhereInput | payment_releasesWhereInput[]
    user_id?: StringFilter<"payment_releases"> | string
    total_net_amount?: DecimalFilter<"payment_releases"> | Decimal | DecimalJsLike | number | string
    payment_method_id?: IntFilter<"payment_releases"> | number
    status?: StringNullableFilter<"payment_releases"> | string | null
    external_transaction_id?: StringNullableFilter<"payment_releases"> | string | null
    metadata?: JsonNullableFilter<"payment_releases">
    created_at?: DateTimeNullableFilter<"payment_releases"> | Date | string | null
    payee_id?: StringNullableFilter<"payment_releases"> | string | null
    release_date?: DateTimeNullableFilter<"payment_releases"> | Date | string | null
    batch_id?: UuidNullableFilter<"payment_releases"> | string | null
    payment_release_associations?: Payment_release_associationsListRelationFilter
    payment_method?: XOR<Payment_methodScalarRelationFilter, payment_methodWhereInput>
  }, "payment_release_id">

  export type payment_releasesOrderByWithAggregationInput = {
    payment_release_id?: SortOrder
    user_id?: SortOrder
    total_net_amount?: SortOrder
    payment_method_id?: SortOrder
    status?: SortOrderInput | SortOrder
    external_transaction_id?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    payee_id?: SortOrderInput | SortOrder
    release_date?: SortOrderInput | SortOrder
    batch_id?: SortOrderInput | SortOrder
    _count?: payment_releasesCountOrderByAggregateInput
    _avg?: payment_releasesAvgOrderByAggregateInput
    _max?: payment_releasesMaxOrderByAggregateInput
    _min?: payment_releasesMinOrderByAggregateInput
    _sum?: payment_releasesSumOrderByAggregateInput
  }

  export type payment_releasesScalarWhereWithAggregatesInput = {
    AND?: payment_releasesScalarWhereWithAggregatesInput | payment_releasesScalarWhereWithAggregatesInput[]
    OR?: payment_releasesScalarWhereWithAggregatesInput[]
    NOT?: payment_releasesScalarWhereWithAggregatesInput | payment_releasesScalarWhereWithAggregatesInput[]
    payment_release_id?: UuidWithAggregatesFilter<"payment_releases"> | string
    user_id?: StringWithAggregatesFilter<"payment_releases"> | string
    total_net_amount?: DecimalWithAggregatesFilter<"payment_releases"> | Decimal | DecimalJsLike | number | string
    payment_method_id?: IntWithAggregatesFilter<"payment_releases"> | number
    status?: StringNullableWithAggregatesFilter<"payment_releases"> | string | null
    external_transaction_id?: StringNullableWithAggregatesFilter<"payment_releases"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"payment_releases">
    created_at?: DateTimeNullableWithAggregatesFilter<"payment_releases"> | Date | string | null
    payee_id?: StringNullableWithAggregatesFilter<"payment_releases"> | string | null
    release_date?: DateTimeNullableWithAggregatesFilter<"payment_releases"> | Date | string | null
    batch_id?: UuidNullableWithAggregatesFilter<"payment_releases"> | string | null
  }

  export type user_payment_methodsWhereInput = {
    AND?: user_payment_methodsWhereInput | user_payment_methodsWhereInput[]
    OR?: user_payment_methodsWhereInput[]
    NOT?: user_payment_methodsWhereInput | user_payment_methodsWhereInput[]
    id?: UuidFilter<"user_payment_methods"> | string
    user_id?: StringFilter<"user_payment_methods"> | string
    payment_method_id?: IntFilter<"user_payment_methods"> | number
    status?: Enumpayment_method_statusNullableFilter<"user_payment_methods"> | $Enums.payment_method_status | null
    trolley_payment_method?: Trolley_recipientListRelationFilter
    payment_method?: XOR<Payment_methodScalarRelationFilter, payment_methodWhereInput>
  }

  export type user_payment_methodsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    payment_method_id?: SortOrder
    status?: SortOrderInput | SortOrder
    trolley_payment_method?: trolley_recipientOrderByRelationAggregateInput
    payment_method?: payment_methodOrderByWithRelationInput
  }

  export type user_payment_methodsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id_payment_method_id?: user_payment_methodsUser_idPayment_method_idCompoundUniqueInput
    AND?: user_payment_methodsWhereInput | user_payment_methodsWhereInput[]
    OR?: user_payment_methodsWhereInput[]
    NOT?: user_payment_methodsWhereInput | user_payment_methodsWhereInput[]
    user_id?: StringFilter<"user_payment_methods"> | string
    payment_method_id?: IntFilter<"user_payment_methods"> | number
    status?: Enumpayment_method_statusNullableFilter<"user_payment_methods"> | $Enums.payment_method_status | null
    trolley_payment_method?: Trolley_recipientListRelationFilter
    payment_method?: XOR<Payment_methodScalarRelationFilter, payment_methodWhereInput>
  }, "id" | "user_id_payment_method_id">

  export type user_payment_methodsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    payment_method_id?: SortOrder
    status?: SortOrderInput | SortOrder
    _count?: user_payment_methodsCountOrderByAggregateInput
    _avg?: user_payment_methodsAvgOrderByAggregateInput
    _max?: user_payment_methodsMaxOrderByAggregateInput
    _min?: user_payment_methodsMinOrderByAggregateInput
    _sum?: user_payment_methodsSumOrderByAggregateInput
  }

  export type user_payment_methodsScalarWhereWithAggregatesInput = {
    AND?: user_payment_methodsScalarWhereWithAggregatesInput | user_payment_methodsScalarWhereWithAggregatesInput[]
    OR?: user_payment_methodsScalarWhereWithAggregatesInput[]
    NOT?: user_payment_methodsScalarWhereWithAggregatesInput | user_payment_methodsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"user_payment_methods"> | string
    user_id?: StringWithAggregatesFilter<"user_payment_methods"> | string
    payment_method_id?: IntWithAggregatesFilter<"user_payment_methods"> | number
    status?: Enumpayment_method_statusNullableWithAggregatesFilter<"user_payment_methods"> | $Enums.payment_method_status | null
  }

  export type user_tax_form_associationsWhereInput = {
    AND?: user_tax_form_associationsWhereInput | user_tax_form_associationsWhereInput[]
    OR?: user_tax_form_associationsWhereInput[]
    NOT?: user_tax_form_associationsWhereInput | user_tax_form_associationsWhereInput[]
    id?: UuidFilter<"user_tax_form_associations"> | string
    user_id?: StringFilter<"user_tax_form_associations"> | string
    tax_form_id?: StringFilter<"user_tax_form_associations"> | string
    date_filed?: DateTimeFilter<"user_tax_form_associations"> | Date | string
    tax_form_status?: Enumtax_form_statusFilter<"user_tax_form_associations"> | $Enums.tax_form_status
  }

  export type user_tax_form_associationsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    tax_form_id?: SortOrder
    date_filed?: SortOrder
    tax_form_status?: SortOrder
  }

  export type user_tax_form_associationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: user_tax_form_associationsWhereInput | user_tax_form_associationsWhereInput[]
    OR?: user_tax_form_associationsWhereInput[]
    NOT?: user_tax_form_associationsWhereInput | user_tax_form_associationsWhereInput[]
    user_id?: StringFilter<"user_tax_form_associations"> | string
    tax_form_id?: StringFilter<"user_tax_form_associations"> | string
    date_filed?: DateTimeFilter<"user_tax_form_associations"> | Date | string
    tax_form_status?: Enumtax_form_statusFilter<"user_tax_form_associations"> | $Enums.tax_form_status
  }, "id">

  export type user_tax_form_associationsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    tax_form_id?: SortOrder
    date_filed?: SortOrder
    tax_form_status?: SortOrder
    _count?: user_tax_form_associationsCountOrderByAggregateInput
    _max?: user_tax_form_associationsMaxOrderByAggregateInput
    _min?: user_tax_form_associationsMinOrderByAggregateInput
  }

  export type user_tax_form_associationsScalarWhereWithAggregatesInput = {
    AND?: user_tax_form_associationsScalarWhereWithAggregatesInput | user_tax_form_associationsScalarWhereWithAggregatesInput[]
    OR?: user_tax_form_associationsScalarWhereWithAggregatesInput[]
    NOT?: user_tax_form_associationsScalarWhereWithAggregatesInput | user_tax_form_associationsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"user_tax_form_associations"> | string
    user_id?: StringWithAggregatesFilter<"user_tax_form_associations"> | string
    tax_form_id?: StringWithAggregatesFilter<"user_tax_form_associations"> | string
    date_filed?: DateTimeWithAggregatesFilter<"user_tax_form_associations"> | Date | string
    tax_form_status?: Enumtax_form_statusWithAggregatesFilter<"user_tax_form_associations"> | $Enums.tax_form_status
  }

  export type winningsWhereInput = {
    AND?: winningsWhereInput | winningsWhereInput[]
    OR?: winningsWhereInput[]
    NOT?: winningsWhereInput | winningsWhereInput[]
    winning_id?: UuidFilter<"winnings"> | string
    winner_id?: StringFilter<"winnings"> | string
    type?: Enumwinnings_typeFilter<"winnings"> | $Enums.winnings_type
    origin_id?: IntNullableFilter<"winnings"> | number | null
    category?: Enumwinnings_categoryNullableFilter<"winnings"> | $Enums.winnings_category | null
    title?: StringNullableFilter<"winnings"> | string | null
    description?: StringNullableFilter<"winnings"> | string | null
    external_id?: StringNullableFilter<"winnings"> | string | null
    attributes?: JsonNullableFilter<"winnings">
    created_by?: StringFilter<"winnings"> | string
    updated_by?: StringNullableFilter<"winnings"> | string | null
    created_at?: DateTimeNullableFilter<"winnings"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"winnings"> | Date | string | null
    audit?: AuditListRelationFilter
    payment?: PaymentListRelationFilter
    origin?: XOR<OriginNullableScalarRelationFilter, originWhereInput> | null
  }

  export type winningsOrderByWithRelationInput = {
    winning_id?: SortOrder
    winner_id?: SortOrder
    type?: SortOrder
    origin_id?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    external_id?: SortOrderInput | SortOrder
    attributes?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    audit?: auditOrderByRelationAggregateInput
    payment?: paymentOrderByRelationAggregateInput
    origin?: originOrderByWithRelationInput
  }

  export type winningsWhereUniqueInput = Prisma.AtLeast<{
    winning_id?: string
    AND?: winningsWhereInput | winningsWhereInput[]
    OR?: winningsWhereInput[]
    NOT?: winningsWhereInput | winningsWhereInput[]
    winner_id?: StringFilter<"winnings"> | string
    type?: Enumwinnings_typeFilter<"winnings"> | $Enums.winnings_type
    origin_id?: IntNullableFilter<"winnings"> | number | null
    category?: Enumwinnings_categoryNullableFilter<"winnings"> | $Enums.winnings_category | null
    title?: StringNullableFilter<"winnings"> | string | null
    description?: StringNullableFilter<"winnings"> | string | null
    external_id?: StringNullableFilter<"winnings"> | string | null
    attributes?: JsonNullableFilter<"winnings">
    created_by?: StringFilter<"winnings"> | string
    updated_by?: StringNullableFilter<"winnings"> | string | null
    created_at?: DateTimeNullableFilter<"winnings"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"winnings"> | Date | string | null
    audit?: AuditListRelationFilter
    payment?: PaymentListRelationFilter
    origin?: XOR<OriginNullableScalarRelationFilter, originWhereInput> | null
  }, "winning_id">

  export type winningsOrderByWithAggregationInput = {
    winning_id?: SortOrder
    winner_id?: SortOrder
    type?: SortOrder
    origin_id?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    external_id?: SortOrderInput | SortOrder
    attributes?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: winningsCountOrderByAggregateInput
    _avg?: winningsAvgOrderByAggregateInput
    _max?: winningsMaxOrderByAggregateInput
    _min?: winningsMinOrderByAggregateInput
    _sum?: winningsSumOrderByAggregateInput
  }

  export type winningsScalarWhereWithAggregatesInput = {
    AND?: winningsScalarWhereWithAggregatesInput | winningsScalarWhereWithAggregatesInput[]
    OR?: winningsScalarWhereWithAggregatesInput[]
    NOT?: winningsScalarWhereWithAggregatesInput | winningsScalarWhereWithAggregatesInput[]
    winning_id?: UuidWithAggregatesFilter<"winnings"> | string
    winner_id?: StringWithAggregatesFilter<"winnings"> | string
    type?: Enumwinnings_typeWithAggregatesFilter<"winnings"> | $Enums.winnings_type
    origin_id?: IntNullableWithAggregatesFilter<"winnings"> | number | null
    category?: Enumwinnings_categoryNullableWithAggregatesFilter<"winnings"> | $Enums.winnings_category | null
    title?: StringNullableWithAggregatesFilter<"winnings"> | string | null
    description?: StringNullableWithAggregatesFilter<"winnings"> | string | null
    external_id?: StringNullableWithAggregatesFilter<"winnings"> | string | null
    attributes?: JsonNullableWithAggregatesFilter<"winnings">
    created_by?: StringWithAggregatesFilter<"winnings"> | string
    updated_by?: StringNullableWithAggregatesFilter<"winnings"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"winnings"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"winnings"> | Date | string | null
  }

  export type trolley_recipientWhereInput = {
    AND?: trolley_recipientWhereInput | trolley_recipientWhereInput[]
    OR?: trolley_recipientWhereInput[]
    NOT?: trolley_recipientWhereInput | trolley_recipientWhereInput[]
    id?: IntFilter<"trolley_recipient"> | number
    user_payment_method_id?: UuidFilter<"trolley_recipient"> | string
    user_id?: StringFilter<"trolley_recipient"> | string
    trolley_id?: StringFilter<"trolley_recipient"> | string
    trolley_recipient_payment_methods?: Trolley_recipient_payment_methodListRelationFilter
    user_payment_methods?: XOR<User_payment_methodsScalarRelationFilter, user_payment_methodsWhereInput>
  }

  export type trolley_recipientOrderByWithRelationInput = {
    id?: SortOrder
    user_payment_method_id?: SortOrder
    user_id?: SortOrder
    trolley_id?: SortOrder
    trolley_recipient_payment_methods?: trolley_recipient_payment_methodOrderByRelationAggregateInput
    user_payment_methods?: user_payment_methodsOrderByWithRelationInput
  }

  export type trolley_recipientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id?: string
    trolley_id?: string
    AND?: trolley_recipientWhereInput | trolley_recipientWhereInput[]
    OR?: trolley_recipientWhereInput[]
    NOT?: trolley_recipientWhereInput | trolley_recipientWhereInput[]
    user_payment_method_id?: UuidFilter<"trolley_recipient"> | string
    trolley_recipient_payment_methods?: Trolley_recipient_payment_methodListRelationFilter
    user_payment_methods?: XOR<User_payment_methodsScalarRelationFilter, user_payment_methodsWhereInput>
  }, "id" | "user_id" | "trolley_id">

  export type trolley_recipientOrderByWithAggregationInput = {
    id?: SortOrder
    user_payment_method_id?: SortOrder
    user_id?: SortOrder
    trolley_id?: SortOrder
    _count?: trolley_recipientCountOrderByAggregateInput
    _avg?: trolley_recipientAvgOrderByAggregateInput
    _max?: trolley_recipientMaxOrderByAggregateInput
    _min?: trolley_recipientMinOrderByAggregateInput
    _sum?: trolley_recipientSumOrderByAggregateInput
  }

  export type trolley_recipientScalarWhereWithAggregatesInput = {
    AND?: trolley_recipientScalarWhereWithAggregatesInput | trolley_recipientScalarWhereWithAggregatesInput[]
    OR?: trolley_recipientScalarWhereWithAggregatesInput[]
    NOT?: trolley_recipientScalarWhereWithAggregatesInput | trolley_recipientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"trolley_recipient"> | number
    user_payment_method_id?: UuidWithAggregatesFilter<"trolley_recipient"> | string
    user_id?: StringWithAggregatesFilter<"trolley_recipient"> | string
    trolley_id?: StringWithAggregatesFilter<"trolley_recipient"> | string
  }

  export type trolley_webhook_logWhereInput = {
    AND?: trolley_webhook_logWhereInput | trolley_webhook_logWhereInput[]
    OR?: trolley_webhook_logWhereInput[]
    NOT?: trolley_webhook_logWhereInput | trolley_webhook_logWhereInput[]
    id?: UuidFilter<"trolley_webhook_log"> | string
    event_id?: StringFilter<"trolley_webhook_log"> | string
    event_time?: DateTimeFilter<"trolley_webhook_log"> | Date | string
    event_payload?: JsonFilter<"trolley_webhook_log">
    event_model?: StringNullableFilter<"trolley_webhook_log"> | string | null
    event_action?: StringNullableFilter<"trolley_webhook_log"> | string | null
    status?: Enumwebhook_statusFilter<"trolley_webhook_log"> | $Enums.webhook_status
    error_message?: StringNullableFilter<"trolley_webhook_log"> | string | null
    created_at?: DateTimeNullableFilter<"trolley_webhook_log"> | Date | string | null
  }

  export type trolley_webhook_logOrderByWithRelationInput = {
    id?: SortOrder
    event_id?: SortOrder
    event_time?: SortOrder
    event_payload?: SortOrder
    event_model?: SortOrderInput | SortOrder
    event_action?: SortOrderInput | SortOrder
    status?: SortOrder
    error_message?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
  }

  export type trolley_webhook_logWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    event_id?: string
    AND?: trolley_webhook_logWhereInput | trolley_webhook_logWhereInput[]
    OR?: trolley_webhook_logWhereInput[]
    NOT?: trolley_webhook_logWhereInput | trolley_webhook_logWhereInput[]
    event_time?: DateTimeFilter<"trolley_webhook_log"> | Date | string
    event_payload?: JsonFilter<"trolley_webhook_log">
    event_model?: StringNullableFilter<"trolley_webhook_log"> | string | null
    event_action?: StringNullableFilter<"trolley_webhook_log"> | string | null
    status?: Enumwebhook_statusFilter<"trolley_webhook_log"> | $Enums.webhook_status
    error_message?: StringNullableFilter<"trolley_webhook_log"> | string | null
    created_at?: DateTimeNullableFilter<"trolley_webhook_log"> | Date | string | null
  }, "id" | "event_id">

  export type trolley_webhook_logOrderByWithAggregationInput = {
    id?: SortOrder
    event_id?: SortOrder
    event_time?: SortOrder
    event_payload?: SortOrder
    event_model?: SortOrderInput | SortOrder
    event_action?: SortOrderInput | SortOrder
    status?: SortOrder
    error_message?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: trolley_webhook_logCountOrderByAggregateInput
    _max?: trolley_webhook_logMaxOrderByAggregateInput
    _min?: trolley_webhook_logMinOrderByAggregateInput
  }

  export type trolley_webhook_logScalarWhereWithAggregatesInput = {
    AND?: trolley_webhook_logScalarWhereWithAggregatesInput | trolley_webhook_logScalarWhereWithAggregatesInput[]
    OR?: trolley_webhook_logScalarWhereWithAggregatesInput[]
    NOT?: trolley_webhook_logScalarWhereWithAggregatesInput | trolley_webhook_logScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"trolley_webhook_log"> | string
    event_id?: StringWithAggregatesFilter<"trolley_webhook_log"> | string
    event_time?: DateTimeWithAggregatesFilter<"trolley_webhook_log"> | Date | string
    event_payload?: JsonWithAggregatesFilter<"trolley_webhook_log">
    event_model?: StringNullableWithAggregatesFilter<"trolley_webhook_log"> | string | null
    event_action?: StringNullableWithAggregatesFilter<"trolley_webhook_log"> | string | null
    status?: Enumwebhook_statusWithAggregatesFilter<"trolley_webhook_log"> | $Enums.webhook_status
    error_message?: StringNullableWithAggregatesFilter<"trolley_webhook_log"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"trolley_webhook_log"> | Date | string | null
  }

  export type user_identity_verification_associationsWhereInput = {
    AND?: user_identity_verification_associationsWhereInput | user_identity_verification_associationsWhereInput[]
    OR?: user_identity_verification_associationsWhereInput[]
    NOT?: user_identity_verification_associationsWhereInput | user_identity_verification_associationsWhereInput[]
    id?: UuidFilter<"user_identity_verification_associations"> | string
    user_id?: StringFilter<"user_identity_verification_associations"> | string
    verification_id?: StringFilter<"user_identity_verification_associations"> | string
    date_filed?: DateTimeFilter<"user_identity_verification_associations"> | Date | string
    verification_status?: Enumverification_statusFilter<"user_identity_verification_associations"> | $Enums.verification_status
  }

  export type user_identity_verification_associationsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    verification_id?: SortOrder
    date_filed?: SortOrder
    verification_status?: SortOrder
  }

  export type user_identity_verification_associationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: user_identity_verification_associationsWhereInput | user_identity_verification_associationsWhereInput[]
    OR?: user_identity_verification_associationsWhereInput[]
    NOT?: user_identity_verification_associationsWhereInput | user_identity_verification_associationsWhereInput[]
    user_id?: StringFilter<"user_identity_verification_associations"> | string
    verification_id?: StringFilter<"user_identity_verification_associations"> | string
    date_filed?: DateTimeFilter<"user_identity_verification_associations"> | Date | string
    verification_status?: Enumverification_statusFilter<"user_identity_verification_associations"> | $Enums.verification_status
  }, "id">

  export type user_identity_verification_associationsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    verification_id?: SortOrder
    date_filed?: SortOrder
    verification_status?: SortOrder
    _count?: user_identity_verification_associationsCountOrderByAggregateInput
    _max?: user_identity_verification_associationsMaxOrderByAggregateInput
    _min?: user_identity_verification_associationsMinOrderByAggregateInput
  }

  export type user_identity_verification_associationsScalarWhereWithAggregatesInput = {
    AND?: user_identity_verification_associationsScalarWhereWithAggregatesInput | user_identity_verification_associationsScalarWhereWithAggregatesInput[]
    OR?: user_identity_verification_associationsScalarWhereWithAggregatesInput[]
    NOT?: user_identity_verification_associationsScalarWhereWithAggregatesInput | user_identity_verification_associationsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"user_identity_verification_associations"> | string
    user_id?: StringWithAggregatesFilter<"user_identity_verification_associations"> | string
    verification_id?: StringWithAggregatesFilter<"user_identity_verification_associations"> | string
    date_filed?: DateTimeWithAggregatesFilter<"user_identity_verification_associations"> | Date | string
    verification_status?: Enumverification_statusWithAggregatesFilter<"user_identity_verification_associations"> | $Enums.verification_status
  }

  export type trolley_recipient_payment_methodWhereInput = {
    AND?: trolley_recipient_payment_methodWhereInput | trolley_recipient_payment_methodWhereInput[]
    OR?: trolley_recipient_payment_methodWhereInput[]
    NOT?: trolley_recipient_payment_methodWhereInput | trolley_recipient_payment_methodWhereInput[]
    id?: UuidFilter<"trolley_recipient_payment_method"> | string
    trolley_recipient_id?: IntFilter<"trolley_recipient_payment_method"> | number
    recipient_account_id?: StringFilter<"trolley_recipient_payment_method"> | string
    trolley_recipient?: XOR<Trolley_recipientScalarRelationFilter, trolley_recipientWhereInput>
  }

  export type trolley_recipient_payment_methodOrderByWithRelationInput = {
    id?: SortOrder
    trolley_recipient_id?: SortOrder
    recipient_account_id?: SortOrder
    trolley_recipient?: trolley_recipientOrderByWithRelationInput
  }

  export type trolley_recipient_payment_methodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    recipient_account_id?: string
    AND?: trolley_recipient_payment_methodWhereInput | trolley_recipient_payment_methodWhereInput[]
    OR?: trolley_recipient_payment_methodWhereInput[]
    NOT?: trolley_recipient_payment_methodWhereInput | trolley_recipient_payment_methodWhereInput[]
    trolley_recipient_id?: IntFilter<"trolley_recipient_payment_method"> | number
    trolley_recipient?: XOR<Trolley_recipientScalarRelationFilter, trolley_recipientWhereInput>
  }, "id" | "recipient_account_id">

  export type trolley_recipient_payment_methodOrderByWithAggregationInput = {
    id?: SortOrder
    trolley_recipient_id?: SortOrder
    recipient_account_id?: SortOrder
    _count?: trolley_recipient_payment_methodCountOrderByAggregateInput
    _avg?: trolley_recipient_payment_methodAvgOrderByAggregateInput
    _max?: trolley_recipient_payment_methodMaxOrderByAggregateInput
    _min?: trolley_recipient_payment_methodMinOrderByAggregateInput
    _sum?: trolley_recipient_payment_methodSumOrderByAggregateInput
  }

  export type trolley_recipient_payment_methodScalarWhereWithAggregatesInput = {
    AND?: trolley_recipient_payment_methodScalarWhereWithAggregatesInput | trolley_recipient_payment_methodScalarWhereWithAggregatesInput[]
    OR?: trolley_recipient_payment_methodScalarWhereWithAggregatesInput[]
    NOT?: trolley_recipient_payment_methodScalarWhereWithAggregatesInput | trolley_recipient_payment_methodScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"trolley_recipient_payment_method"> | string
    trolley_recipient_id?: IntWithAggregatesFilter<"trolley_recipient_payment_method"> | number
    recipient_account_id?: StringWithAggregatesFilter<"trolley_recipient_payment_method"> | string
  }

  export type challenge_lockWhereInput = {
    AND?: challenge_lockWhereInput | challenge_lockWhereInput[]
    OR?: challenge_lockWhereInput[]
    NOT?: challenge_lockWhereInput | challenge_lockWhereInput[]
    id?: IntFilter<"challenge_lock"> | number
    external_id?: StringFilter<"challenge_lock"> | string
    lock_time?: DateTimeFilter<"challenge_lock"> | Date | string
    error?: StringNullableFilter<"challenge_lock"> | string | null
  }

  export type challenge_lockOrderByWithRelationInput = {
    id?: SortOrder
    external_id?: SortOrder
    lock_time?: SortOrder
    error?: SortOrderInput | SortOrder
  }

  export type challenge_lockWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    external_id?: string
    AND?: challenge_lockWhereInput | challenge_lockWhereInput[]
    OR?: challenge_lockWhereInput[]
    NOT?: challenge_lockWhereInput | challenge_lockWhereInput[]
    lock_time?: DateTimeFilter<"challenge_lock"> | Date | string
    error?: StringNullableFilter<"challenge_lock"> | string | null
  }, "id" | "external_id">

  export type challenge_lockOrderByWithAggregationInput = {
    id?: SortOrder
    external_id?: SortOrder
    lock_time?: SortOrder
    error?: SortOrderInput | SortOrder
    _count?: challenge_lockCountOrderByAggregateInput
    _avg?: challenge_lockAvgOrderByAggregateInput
    _max?: challenge_lockMaxOrderByAggregateInput
    _min?: challenge_lockMinOrderByAggregateInput
    _sum?: challenge_lockSumOrderByAggregateInput
  }

  export type challenge_lockScalarWhereWithAggregatesInput = {
    AND?: challenge_lockScalarWhereWithAggregatesInput | challenge_lockScalarWhereWithAggregatesInput[]
    OR?: challenge_lockScalarWhereWithAggregatesInput[]
    NOT?: challenge_lockScalarWhereWithAggregatesInput | challenge_lockScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"challenge_lock"> | number
    external_id?: StringWithAggregatesFilter<"challenge_lock"> | string
    lock_time?: DateTimeWithAggregatesFilter<"challenge_lock"> | Date | string
    error?: StringNullableWithAggregatesFilter<"challenge_lock"> | string | null
  }

  export type auditCreateInput = {
    id?: string
    user_id: string
    action: string
    note?: string | null
    created_at?: Date | string
    winnings: winningsCreateNestedOneWithoutAuditInput
  }

  export type auditUncheckedCreateInput = {
    id?: string
    winnings_id: string
    user_id: string
    action: string
    note?: string | null
    created_at?: Date | string
  }

  export type auditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    winnings?: winningsUpdateOneRequiredWithoutAuditNestedInput
  }

  export type auditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    winnings_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auditCreateManyInput = {
    id?: string
    winnings_id: string
    user_id: string
    action: string
    note?: string | null
    created_at?: Date | string
  }

  export type auditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    winnings_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type originCreateInput = {
    origin_name: string
    winnings?: winningsCreateNestedManyWithoutOriginInput
  }

  export type originUncheckedCreateInput = {
    origin_id?: number
    origin_name: string
    winnings?: winningsUncheckedCreateNestedManyWithoutOriginInput
  }

  export type originUpdateInput = {
    origin_name?: StringFieldUpdateOperationsInput | string
    winnings?: winningsUpdateManyWithoutOriginNestedInput
  }

  export type originUncheckedUpdateInput = {
    origin_id?: IntFieldUpdateOperationsInput | number
    origin_name?: StringFieldUpdateOperationsInput | string
    winnings?: winningsUncheckedUpdateManyWithoutOriginNestedInput
  }

  export type originCreateManyInput = {
    origin_id?: number
    origin_name: string
  }

  export type originUpdateManyMutationInput = {
    origin_name?: StringFieldUpdateOperationsInput | string
  }

  export type originUncheckedUpdateManyInput = {
    origin_id?: IntFieldUpdateOperationsInput | number
    origin_name?: StringFieldUpdateOperationsInput | string
  }

  export type otpCreateInput = {
    id?: string
    email: string
    otp_hash: string
    expiration_time?: Date | string
    action_type: $Enums.reference_type
    created_at?: Date | string | null
    updated_at?: Date | string | null
    verified_at?: Date | string | null
  }

  export type otpUncheckedCreateInput = {
    id?: string
    email: string
    otp_hash: string
    expiration_time?: Date | string
    action_type: $Enums.reference_type
    created_at?: Date | string | null
    updated_at?: Date | string | null
    verified_at?: Date | string | null
  }

  export type otpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp_hash?: StringFieldUpdateOperationsInput | string
    expiration_time?: DateTimeFieldUpdateOperationsInput | Date | string
    action_type?: Enumreference_typeFieldUpdateOperationsInput | $Enums.reference_type
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type otpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp_hash?: StringFieldUpdateOperationsInput | string
    expiration_time?: DateTimeFieldUpdateOperationsInput | Date | string
    action_type?: Enumreference_typeFieldUpdateOperationsInput | $Enums.reference_type
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type otpCreateManyInput = {
    id?: string
    email: string
    otp_hash: string
    expiration_time?: Date | string
    action_type: $Enums.reference_type
    created_at?: Date | string | null
    updated_at?: Date | string | null
    verified_at?: Date | string | null
  }

  export type otpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp_hash?: StringFieldUpdateOperationsInput | string
    expiration_time?: DateTimeFieldUpdateOperationsInput | Date | string
    action_type?: Enumreference_typeFieldUpdateOperationsInput | $Enums.reference_type
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type otpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp_hash?: StringFieldUpdateOperationsInput | string
    expiration_time?: DateTimeFieldUpdateOperationsInput | Date | string
    action_type?: Enumreference_typeFieldUpdateOperationsInput | $Enums.reference_type
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentCreateInput = {
    payment_id?: string
    net_amount?: Decimal | DecimalJsLike | number | string | null
    gross_amount?: Decimal | DecimalJsLike | number | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    installment_number?: number | null
    date_paid?: Date | string | null
    currency?: string | null
    created_by: string
    updated_by?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    version?: number | null
    release_date?: Date | string | null
    payment_status?: $Enums.payment_status | null
    billing_account: string
    challenge_markup?: Decimal | DecimalJsLike | number | string | null
    challenge_fee?: Decimal | DecimalJsLike | number | string | null
    payment_method?: payment_methodCreateNestedOneWithoutPaymentInput
    winnings: winningsCreateNestedOneWithoutPaymentInput
    payment_release_associations?: payment_release_associationsCreateNestedManyWithoutPaymentInput
  }

  export type paymentUncheckedCreateInput = {
    payment_id?: string
    winnings_id: string
    net_amount?: Decimal | DecimalJsLike | number | string | null
    gross_amount?: Decimal | DecimalJsLike | number | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    installment_number?: number | null
    date_paid?: Date | string | null
    payment_method_id?: number | null
    currency?: string | null
    created_by: string
    updated_by?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    version?: number | null
    release_date?: Date | string | null
    payment_status?: $Enums.payment_status | null
    billing_account: string
    challenge_markup?: Decimal | DecimalJsLike | number | string | null
    challenge_fee?: Decimal | DecimalJsLike | number | string | null
    payment_release_associations?: payment_release_associationsUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type paymentUpdateInput = {
    payment_id?: StringFieldUpdateOperationsInput | string
    net_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gross_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    installment_number?: NullableIntFieldUpdateOperationsInput | number | null
    date_paid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    billing_account?: StringFieldUpdateOperationsInput | string
    challenge_markup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    challenge_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_method?: payment_methodUpdateOneWithoutPaymentNestedInput
    winnings?: winningsUpdateOneRequiredWithoutPaymentNestedInput
    payment_release_associations?: payment_release_associationsUpdateManyWithoutPaymentNestedInput
  }

  export type paymentUncheckedUpdateInput = {
    payment_id?: StringFieldUpdateOperationsInput | string
    winnings_id?: StringFieldUpdateOperationsInput | string
    net_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gross_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    installment_number?: NullableIntFieldUpdateOperationsInput | number | null
    date_paid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_method_id?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    billing_account?: StringFieldUpdateOperationsInput | string
    challenge_markup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    challenge_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_release_associations?: payment_release_associationsUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type paymentCreateManyInput = {
    payment_id?: string
    winnings_id: string
    net_amount?: Decimal | DecimalJsLike | number | string | null
    gross_amount?: Decimal | DecimalJsLike | number | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    installment_number?: number | null
    date_paid?: Date | string | null
    payment_method_id?: number | null
    currency?: string | null
    created_by: string
    updated_by?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    version?: number | null
    release_date?: Date | string | null
    payment_status?: $Enums.payment_status | null
    billing_account: string
    challenge_markup?: Decimal | DecimalJsLike | number | string | null
    challenge_fee?: Decimal | DecimalJsLike | number | string | null
  }

  export type paymentUpdateManyMutationInput = {
    payment_id?: StringFieldUpdateOperationsInput | string
    net_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gross_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    installment_number?: NullableIntFieldUpdateOperationsInput | number | null
    date_paid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    billing_account?: StringFieldUpdateOperationsInput | string
    challenge_markup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    challenge_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type paymentUncheckedUpdateManyInput = {
    payment_id?: StringFieldUpdateOperationsInput | string
    winnings_id?: StringFieldUpdateOperationsInput | string
    net_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gross_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    installment_number?: NullableIntFieldUpdateOperationsInput | number | null
    date_paid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_method_id?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    billing_account?: StringFieldUpdateOperationsInput | string
    challenge_markup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    challenge_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type payment_methodCreateInput = {
    payment_method_type: string
    name: string
    description?: string | null
    payment?: paymentCreateNestedManyWithoutPayment_methodInput
    payment_releases?: payment_releasesCreateNestedManyWithoutPayment_methodInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutPayment_methodInput
  }

  export type payment_methodUncheckedCreateInput = {
    payment_method_id?: number
    payment_method_type: string
    name: string
    description?: string | null
    payment?: paymentUncheckedCreateNestedManyWithoutPayment_methodInput
    payment_releases?: payment_releasesUncheckedCreateNestedManyWithoutPayment_methodInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutPayment_methodInput
  }

  export type payment_methodUpdateInput = {
    payment_method_type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: paymentUpdateManyWithoutPayment_methodNestedInput
    payment_releases?: payment_releasesUpdateManyWithoutPayment_methodNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutPayment_methodNestedInput
  }

  export type payment_methodUncheckedUpdateInput = {
    payment_method_id?: IntFieldUpdateOperationsInput | number
    payment_method_type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: paymentUncheckedUpdateManyWithoutPayment_methodNestedInput
    payment_releases?: payment_releasesUncheckedUpdateManyWithoutPayment_methodNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutPayment_methodNestedInput
  }

  export type payment_methodCreateManyInput = {
    payment_method_id?: number
    payment_method_type: string
    name: string
    description?: string | null
  }

  export type payment_methodUpdateManyMutationInput = {
    payment_method_type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type payment_methodUncheckedUpdateManyInput = {
    payment_method_id?: IntFieldUpdateOperationsInput | number
    payment_method_type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type payment_release_associationsCreateInput = {
    payment: paymentCreateNestedOneWithoutPayment_release_associationsInput
    payment_releases: payment_releasesCreateNestedOneWithoutPayment_release_associationsInput
  }

  export type payment_release_associationsUncheckedCreateInput = {
    payment_release_id: string
    payment_id: string
  }

  export type payment_release_associationsUpdateInput = {
    payment?: paymentUpdateOneRequiredWithoutPayment_release_associationsNestedInput
    payment_releases?: payment_releasesUpdateOneRequiredWithoutPayment_release_associationsNestedInput
  }

  export type payment_release_associationsUncheckedUpdateInput = {
    payment_release_id?: StringFieldUpdateOperationsInput | string
    payment_id?: StringFieldUpdateOperationsInput | string
  }

  export type payment_release_associationsCreateManyInput = {
    payment_release_id: string
    payment_id: string
  }

  export type payment_release_associationsUpdateManyMutationInput = {

  }

  export type payment_release_associationsUncheckedUpdateManyInput = {
    payment_release_id?: StringFieldUpdateOperationsInput | string
    payment_id?: StringFieldUpdateOperationsInput | string
  }

  export type payment_releasesCreateInput = {
    payment_release_id?: string
    user_id: string
    total_net_amount: Decimal | DecimalJsLike | number | string
    status?: string | null
    external_transaction_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    payee_id?: string | null
    release_date?: Date | string | null
    batch_id?: string | null
    payment_release_associations?: payment_release_associationsCreateNestedManyWithoutPayment_releasesInput
    payment_method: payment_methodCreateNestedOneWithoutPayment_releasesInput
  }

  export type payment_releasesUncheckedCreateInput = {
    payment_release_id?: string
    user_id: string
    total_net_amount: Decimal | DecimalJsLike | number | string
    payment_method_id: number
    status?: string | null
    external_transaction_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    payee_id?: string | null
    release_date?: Date | string | null
    batch_id?: string | null
    payment_release_associations?: payment_release_associationsUncheckedCreateNestedManyWithoutPayment_releasesInput
  }

  export type payment_releasesUpdateInput = {
    payment_release_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    total_net_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    external_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payee_id?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_release_associations?: payment_release_associationsUpdateManyWithoutPayment_releasesNestedInput
    payment_method?: payment_methodUpdateOneRequiredWithoutPayment_releasesNestedInput
  }

  export type payment_releasesUncheckedUpdateInput = {
    payment_release_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    total_net_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    external_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payee_id?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_release_associations?: payment_release_associationsUncheckedUpdateManyWithoutPayment_releasesNestedInput
  }

  export type payment_releasesCreateManyInput = {
    payment_release_id?: string
    user_id: string
    total_net_amount: Decimal | DecimalJsLike | number | string
    payment_method_id: number
    status?: string | null
    external_transaction_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    payee_id?: string | null
    release_date?: Date | string | null
    batch_id?: string | null
  }

  export type payment_releasesUpdateManyMutationInput = {
    payment_release_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    total_net_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    external_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payee_id?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batch_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type payment_releasesUncheckedUpdateManyInput = {
    payment_release_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    total_net_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    external_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payee_id?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batch_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_payment_methodsCreateInput = {
    id?: string
    user_id: string
    status?: $Enums.payment_method_status | null
    trolley_payment_method?: trolley_recipientCreateNestedManyWithoutUser_payment_methodsInput
    payment_method: payment_methodCreateNestedOneWithoutUser_payment_methodsInput
  }

  export type user_payment_methodsUncheckedCreateInput = {
    id?: string
    user_id: string
    payment_method_id: number
    status?: $Enums.payment_method_status | null
    trolley_payment_method?: trolley_recipientUncheckedCreateNestedManyWithoutUser_payment_methodsInput
  }

  export type user_payment_methodsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumpayment_method_statusFieldUpdateOperationsInput | $Enums.payment_method_status | null
    trolley_payment_method?: trolley_recipientUpdateManyWithoutUser_payment_methodsNestedInput
    payment_method?: payment_methodUpdateOneRequiredWithoutUser_payment_methodsNestedInput
  }

  export type user_payment_methodsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    payment_method_id?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumpayment_method_statusFieldUpdateOperationsInput | $Enums.payment_method_status | null
    trolley_payment_method?: trolley_recipientUncheckedUpdateManyWithoutUser_payment_methodsNestedInput
  }

  export type user_payment_methodsCreateManyInput = {
    id?: string
    user_id: string
    payment_method_id: number
    status?: $Enums.payment_method_status | null
  }

  export type user_payment_methodsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumpayment_method_statusFieldUpdateOperationsInput | $Enums.payment_method_status | null
  }

  export type user_payment_methodsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    payment_method_id?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumpayment_method_statusFieldUpdateOperationsInput | $Enums.payment_method_status | null
  }

  export type user_tax_form_associationsCreateInput = {
    id?: string
    user_id: string
    tax_form_id: string
    date_filed: Date | string
    tax_form_status: $Enums.tax_form_status
  }

  export type user_tax_form_associationsUncheckedCreateInput = {
    id?: string
    user_id: string
    tax_form_id: string
    date_filed: Date | string
    tax_form_status: $Enums.tax_form_status
  }

  export type user_tax_form_associationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    tax_form_id?: StringFieldUpdateOperationsInput | string
    date_filed?: DateTimeFieldUpdateOperationsInput | Date | string
    tax_form_status?: Enumtax_form_statusFieldUpdateOperationsInput | $Enums.tax_form_status
  }

  export type user_tax_form_associationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    tax_form_id?: StringFieldUpdateOperationsInput | string
    date_filed?: DateTimeFieldUpdateOperationsInput | Date | string
    tax_form_status?: Enumtax_form_statusFieldUpdateOperationsInput | $Enums.tax_form_status
  }

  export type user_tax_form_associationsCreateManyInput = {
    id?: string
    user_id: string
    tax_form_id: string
    date_filed: Date | string
    tax_form_status: $Enums.tax_form_status
  }

  export type user_tax_form_associationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    tax_form_id?: StringFieldUpdateOperationsInput | string
    date_filed?: DateTimeFieldUpdateOperationsInput | Date | string
    tax_form_status?: Enumtax_form_statusFieldUpdateOperationsInput | $Enums.tax_form_status
  }

  export type user_tax_form_associationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    tax_form_id?: StringFieldUpdateOperationsInput | string
    date_filed?: DateTimeFieldUpdateOperationsInput | Date | string
    tax_form_status?: Enumtax_form_statusFieldUpdateOperationsInput | $Enums.tax_form_status
  }

  export type winningsCreateInput = {
    winning_id?: string
    winner_id: string
    type: $Enums.winnings_type
    category?: $Enums.winnings_category | null
    title?: string | null
    description?: string | null
    external_id?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    created_by: string
    updated_by?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    audit?: auditCreateNestedManyWithoutWinningsInput
    payment?: paymentCreateNestedManyWithoutWinningsInput
    origin?: originCreateNestedOneWithoutWinningsInput
  }

  export type winningsUncheckedCreateInput = {
    winning_id?: string
    winner_id: string
    type: $Enums.winnings_type
    origin_id?: number | null
    category?: $Enums.winnings_category | null
    title?: string | null
    description?: string | null
    external_id?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    created_by: string
    updated_by?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    audit?: auditUncheckedCreateNestedManyWithoutWinningsInput
    payment?: paymentUncheckedCreateNestedManyWithoutWinningsInput
  }

  export type winningsUpdateInput = {
    winning_id?: StringFieldUpdateOperationsInput | string
    winner_id?: StringFieldUpdateOperationsInput | string
    type?: Enumwinnings_typeFieldUpdateOperationsInput | $Enums.winnings_type
    category?: NullableEnumwinnings_categoryFieldUpdateOperationsInput | $Enums.winnings_category | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audit?: auditUpdateManyWithoutWinningsNestedInput
    payment?: paymentUpdateManyWithoutWinningsNestedInput
    origin?: originUpdateOneWithoutWinningsNestedInput
  }

  export type winningsUncheckedUpdateInput = {
    winning_id?: StringFieldUpdateOperationsInput | string
    winner_id?: StringFieldUpdateOperationsInput | string
    type?: Enumwinnings_typeFieldUpdateOperationsInput | $Enums.winnings_type
    origin_id?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumwinnings_categoryFieldUpdateOperationsInput | $Enums.winnings_category | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audit?: auditUncheckedUpdateManyWithoutWinningsNestedInput
    payment?: paymentUncheckedUpdateManyWithoutWinningsNestedInput
  }

  export type winningsCreateManyInput = {
    winning_id?: string
    winner_id: string
    type: $Enums.winnings_type
    origin_id?: number | null
    category?: $Enums.winnings_category | null
    title?: string | null
    description?: string | null
    external_id?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    created_by: string
    updated_by?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type winningsUpdateManyMutationInput = {
    winning_id?: StringFieldUpdateOperationsInput | string
    winner_id?: StringFieldUpdateOperationsInput | string
    type?: Enumwinnings_typeFieldUpdateOperationsInput | $Enums.winnings_type
    category?: NullableEnumwinnings_categoryFieldUpdateOperationsInput | $Enums.winnings_category | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type winningsUncheckedUpdateManyInput = {
    winning_id?: StringFieldUpdateOperationsInput | string
    winner_id?: StringFieldUpdateOperationsInput | string
    type?: Enumwinnings_typeFieldUpdateOperationsInput | $Enums.winnings_type
    origin_id?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumwinnings_categoryFieldUpdateOperationsInput | $Enums.winnings_category | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type trolley_recipientCreateInput = {
    user_id: string
    trolley_id: string
    trolley_recipient_payment_methods?: trolley_recipient_payment_methodCreateNestedManyWithoutTrolley_recipientInput
    user_payment_methods: user_payment_methodsCreateNestedOneWithoutTrolley_payment_methodInput
  }

  export type trolley_recipientUncheckedCreateInput = {
    id?: number
    user_payment_method_id: string
    user_id: string
    trolley_id: string
    trolley_recipient_payment_methods?: trolley_recipient_payment_methodUncheckedCreateNestedManyWithoutTrolley_recipientInput
  }

  export type trolley_recipientUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    trolley_id?: StringFieldUpdateOperationsInput | string
    trolley_recipient_payment_methods?: trolley_recipient_payment_methodUpdateManyWithoutTrolley_recipientNestedInput
    user_payment_methods?: user_payment_methodsUpdateOneRequiredWithoutTrolley_payment_methodNestedInput
  }

  export type trolley_recipientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_payment_method_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    trolley_id?: StringFieldUpdateOperationsInput | string
    trolley_recipient_payment_methods?: trolley_recipient_payment_methodUncheckedUpdateManyWithoutTrolley_recipientNestedInput
  }

  export type trolley_recipientCreateManyInput = {
    id?: number
    user_payment_method_id: string
    user_id: string
    trolley_id: string
  }

  export type trolley_recipientUpdateManyMutationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    trolley_id?: StringFieldUpdateOperationsInput | string
  }

  export type trolley_recipientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_payment_method_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    trolley_id?: StringFieldUpdateOperationsInput | string
  }

  export type trolley_webhook_logCreateInput = {
    id?: string
    event_id: string
    event_time?: Date | string
    event_payload: JsonNullValueInput | InputJsonValue
    event_model?: string | null
    event_action?: string | null
    status: $Enums.webhook_status
    error_message?: string | null
    created_at?: Date | string | null
  }

  export type trolley_webhook_logUncheckedCreateInput = {
    id?: string
    event_id: string
    event_time?: Date | string
    event_payload: JsonNullValueInput | InputJsonValue
    event_model?: string | null
    event_action?: string | null
    status: $Enums.webhook_status
    error_message?: string | null
    created_at?: Date | string | null
  }

  export type trolley_webhook_logUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    event_id?: StringFieldUpdateOperationsInput | string
    event_time?: DateTimeFieldUpdateOperationsInput | Date | string
    event_payload?: JsonNullValueInput | InputJsonValue
    event_model?: NullableStringFieldUpdateOperationsInput | string | null
    event_action?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumwebhook_statusFieldUpdateOperationsInput | $Enums.webhook_status
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type trolley_webhook_logUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    event_id?: StringFieldUpdateOperationsInput | string
    event_time?: DateTimeFieldUpdateOperationsInput | Date | string
    event_payload?: JsonNullValueInput | InputJsonValue
    event_model?: NullableStringFieldUpdateOperationsInput | string | null
    event_action?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumwebhook_statusFieldUpdateOperationsInput | $Enums.webhook_status
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type trolley_webhook_logCreateManyInput = {
    id?: string
    event_id: string
    event_time?: Date | string
    event_payload: JsonNullValueInput | InputJsonValue
    event_model?: string | null
    event_action?: string | null
    status: $Enums.webhook_status
    error_message?: string | null
    created_at?: Date | string | null
  }

  export type trolley_webhook_logUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    event_id?: StringFieldUpdateOperationsInput | string
    event_time?: DateTimeFieldUpdateOperationsInput | Date | string
    event_payload?: JsonNullValueInput | InputJsonValue
    event_model?: NullableStringFieldUpdateOperationsInput | string | null
    event_action?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumwebhook_statusFieldUpdateOperationsInput | $Enums.webhook_status
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type trolley_webhook_logUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    event_id?: StringFieldUpdateOperationsInput | string
    event_time?: DateTimeFieldUpdateOperationsInput | Date | string
    event_payload?: JsonNullValueInput | InputJsonValue
    event_model?: NullableStringFieldUpdateOperationsInput | string | null
    event_action?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumwebhook_statusFieldUpdateOperationsInput | $Enums.webhook_status
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_identity_verification_associationsCreateInput = {
    id?: string
    user_id: string
    verification_id: string
    date_filed: Date | string
    verification_status: $Enums.verification_status
  }

  export type user_identity_verification_associationsUncheckedCreateInput = {
    id?: string
    user_id: string
    verification_id: string
    date_filed: Date | string
    verification_status: $Enums.verification_status
  }

  export type user_identity_verification_associationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    verification_id?: StringFieldUpdateOperationsInput | string
    date_filed?: DateTimeFieldUpdateOperationsInput | Date | string
    verification_status?: Enumverification_statusFieldUpdateOperationsInput | $Enums.verification_status
  }

  export type user_identity_verification_associationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    verification_id?: StringFieldUpdateOperationsInput | string
    date_filed?: DateTimeFieldUpdateOperationsInput | Date | string
    verification_status?: Enumverification_statusFieldUpdateOperationsInput | $Enums.verification_status
  }

  export type user_identity_verification_associationsCreateManyInput = {
    id?: string
    user_id: string
    verification_id: string
    date_filed: Date | string
    verification_status: $Enums.verification_status
  }

  export type user_identity_verification_associationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    verification_id?: StringFieldUpdateOperationsInput | string
    date_filed?: DateTimeFieldUpdateOperationsInput | Date | string
    verification_status?: Enumverification_statusFieldUpdateOperationsInput | $Enums.verification_status
  }

  export type user_identity_verification_associationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    verification_id?: StringFieldUpdateOperationsInput | string
    date_filed?: DateTimeFieldUpdateOperationsInput | Date | string
    verification_status?: Enumverification_statusFieldUpdateOperationsInput | $Enums.verification_status
  }

  export type trolley_recipient_payment_methodCreateInput = {
    id?: string
    recipient_account_id: string
    trolley_recipient: trolley_recipientCreateNestedOneWithoutTrolley_recipient_payment_methodsInput
  }

  export type trolley_recipient_payment_methodUncheckedCreateInput = {
    id?: string
    trolley_recipient_id: number
    recipient_account_id: string
  }

  export type trolley_recipient_payment_methodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient_account_id?: StringFieldUpdateOperationsInput | string
    trolley_recipient?: trolley_recipientUpdateOneRequiredWithoutTrolley_recipient_payment_methodsNestedInput
  }

  export type trolley_recipient_payment_methodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trolley_recipient_id?: IntFieldUpdateOperationsInput | number
    recipient_account_id?: StringFieldUpdateOperationsInput | string
  }

  export type trolley_recipient_payment_methodCreateManyInput = {
    id?: string
    trolley_recipient_id: number
    recipient_account_id: string
  }

  export type trolley_recipient_payment_methodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient_account_id?: StringFieldUpdateOperationsInput | string
  }

  export type trolley_recipient_payment_methodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trolley_recipient_id?: IntFieldUpdateOperationsInput | number
    recipient_account_id?: StringFieldUpdateOperationsInput | string
  }

  export type challenge_lockCreateInput = {
    external_id: string
    lock_time?: Date | string
    error?: string | null
  }

  export type challenge_lockUncheckedCreateInput = {
    id?: number
    external_id: string
    lock_time?: Date | string
    error?: string | null
  }

  export type challenge_lockUpdateInput = {
    external_id?: StringFieldUpdateOperationsInput | string
    lock_time?: DateTimeFieldUpdateOperationsInput | Date | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type challenge_lockUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    external_id?: StringFieldUpdateOperationsInput | string
    lock_time?: DateTimeFieldUpdateOperationsInput | Date | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type challenge_lockCreateManyInput = {
    id?: number
    external_id: string
    lock_time?: Date | string
    error?: string | null
  }

  export type challenge_lockUpdateManyMutationInput = {
    external_id?: StringFieldUpdateOperationsInput | string
    lock_time?: DateTimeFieldUpdateOperationsInput | Date | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type challenge_lockUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    external_id?: StringFieldUpdateOperationsInput | string
    lock_time?: DateTimeFieldUpdateOperationsInput | Date | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type WinningsScalarRelationFilter = {
    is?: winningsWhereInput
    isNot?: winningsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type auditCountOrderByAggregateInput = {
    id?: SortOrder
    winnings_id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    note?: SortOrder
    created_at?: SortOrder
  }

  export type auditMaxOrderByAggregateInput = {
    id?: SortOrder
    winnings_id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    note?: SortOrder
    created_at?: SortOrder
  }

  export type auditMinOrderByAggregateInput = {
    id?: SortOrder
    winnings_id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    note?: SortOrder
    created_at?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type WinningsListRelationFilter = {
    every?: winningsWhereInput
    some?: winningsWhereInput
    none?: winningsWhereInput
  }

  export type winningsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type originCountOrderByAggregateInput = {
    origin_id?: SortOrder
    origin_name?: SortOrder
  }

  export type originAvgOrderByAggregateInput = {
    origin_id?: SortOrder
  }

  export type originMaxOrderByAggregateInput = {
    origin_id?: SortOrder
    origin_name?: SortOrder
  }

  export type originMinOrderByAggregateInput = {
    origin_id?: SortOrder
    origin_name?: SortOrder
  }

  export type originSumOrderByAggregateInput = {
    origin_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type Enumreference_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.reference_type | Enumreference_typeFieldRefInput<$PrismaModel>
    in?: $Enums.reference_type[] | ListEnumreference_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.reference_type[] | ListEnumreference_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumreference_typeFilter<$PrismaModel> | $Enums.reference_type
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type otpCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp_hash?: SortOrder
    expiration_time?: SortOrder
    action_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    verified_at?: SortOrder
  }

  export type otpMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp_hash?: SortOrder
    expiration_time?: SortOrder
    action_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    verified_at?: SortOrder
  }

  export type otpMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp_hash?: SortOrder
    expiration_time?: SortOrder
    action_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    verified_at?: SortOrder
  }

  export type Enumreference_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.reference_type | Enumreference_typeFieldRefInput<$PrismaModel>
    in?: $Enums.reference_type[] | ListEnumreference_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.reference_type[] | ListEnumreference_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumreference_typeWithAggregatesFilter<$PrismaModel> | $Enums.reference_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumreference_typeFilter<$PrismaModel>
    _max?: NestedEnumreference_typeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type Enumpayment_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_status | Enumpayment_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.payment_status[] | ListEnumpayment_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.payment_status[] | ListEnumpayment_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumpayment_statusNullableFilter<$PrismaModel> | $Enums.payment_status | null
  }

  export type Payment_methodNullableScalarRelationFilter = {
    is?: payment_methodWhereInput | null
    isNot?: payment_methodWhereInput | null
  }

  export type Payment_release_associationsListRelationFilter = {
    every?: payment_release_associationsWhereInput
    some?: payment_release_associationsWhereInput
    none?: payment_release_associationsWhereInput
  }

  export type payment_release_associationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type paymentCountOrderByAggregateInput = {
    payment_id?: SortOrder
    winnings_id?: SortOrder
    net_amount?: SortOrder
    gross_amount?: SortOrder
    total_amount?: SortOrder
    installment_number?: SortOrder
    date_paid?: SortOrder
    payment_method_id?: SortOrder
    currency?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    version?: SortOrder
    release_date?: SortOrder
    payment_status?: SortOrder
    billing_account?: SortOrder
    challenge_markup?: SortOrder
    challenge_fee?: SortOrder
  }

  export type paymentAvgOrderByAggregateInput = {
    net_amount?: SortOrder
    gross_amount?: SortOrder
    total_amount?: SortOrder
    installment_number?: SortOrder
    payment_method_id?: SortOrder
    version?: SortOrder
    challenge_markup?: SortOrder
    challenge_fee?: SortOrder
  }

  export type paymentMaxOrderByAggregateInput = {
    payment_id?: SortOrder
    winnings_id?: SortOrder
    net_amount?: SortOrder
    gross_amount?: SortOrder
    total_amount?: SortOrder
    installment_number?: SortOrder
    date_paid?: SortOrder
    payment_method_id?: SortOrder
    currency?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    version?: SortOrder
    release_date?: SortOrder
    payment_status?: SortOrder
    billing_account?: SortOrder
    challenge_markup?: SortOrder
    challenge_fee?: SortOrder
  }

  export type paymentMinOrderByAggregateInput = {
    payment_id?: SortOrder
    winnings_id?: SortOrder
    net_amount?: SortOrder
    gross_amount?: SortOrder
    total_amount?: SortOrder
    installment_number?: SortOrder
    date_paid?: SortOrder
    payment_method_id?: SortOrder
    currency?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    version?: SortOrder
    release_date?: SortOrder
    payment_status?: SortOrder
    billing_account?: SortOrder
    challenge_markup?: SortOrder
    challenge_fee?: SortOrder
  }

  export type paymentSumOrderByAggregateInput = {
    net_amount?: SortOrder
    gross_amount?: SortOrder
    total_amount?: SortOrder
    installment_number?: SortOrder
    payment_method_id?: SortOrder
    version?: SortOrder
    challenge_markup?: SortOrder
    challenge_fee?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type Enumpayment_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_status | Enumpayment_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.payment_status[] | ListEnumpayment_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.payment_status[] | ListEnumpayment_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumpayment_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.payment_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumpayment_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumpayment_statusNullableFilter<$PrismaModel>
  }

  export type PaymentListRelationFilter = {
    every?: paymentWhereInput
    some?: paymentWhereInput
    none?: paymentWhereInput
  }

  export type Payment_releasesListRelationFilter = {
    every?: payment_releasesWhereInput
    some?: payment_releasesWhereInput
    none?: payment_releasesWhereInput
  }

  export type User_payment_methodsListRelationFilter = {
    every?: user_payment_methodsWhereInput
    some?: user_payment_methodsWhereInput
    none?: user_payment_methodsWhereInput
  }

  export type paymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type payment_releasesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_payment_methodsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type payment_methodCountOrderByAggregateInput = {
    payment_method_id?: SortOrder
    payment_method_type?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type payment_methodAvgOrderByAggregateInput = {
    payment_method_id?: SortOrder
  }

  export type payment_methodMaxOrderByAggregateInput = {
    payment_method_id?: SortOrder
    payment_method_type?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type payment_methodMinOrderByAggregateInput = {
    payment_method_id?: SortOrder
    payment_method_type?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type payment_methodSumOrderByAggregateInput = {
    payment_method_id?: SortOrder
  }

  export type PaymentScalarRelationFilter = {
    is?: paymentWhereInput
    isNot?: paymentWhereInput
  }

  export type Payment_releasesScalarRelationFilter = {
    is?: payment_releasesWhereInput
    isNot?: payment_releasesWhereInput
  }

  export type payment_release_associationsPayment_release_idPayment_idCompoundUniqueInput = {
    payment_release_id: string
    payment_id: string
  }

  export type payment_release_associationsCountOrderByAggregateInput = {
    payment_release_id?: SortOrder
    payment_id?: SortOrder
  }

  export type payment_release_associationsMaxOrderByAggregateInput = {
    payment_release_id?: SortOrder
    payment_id?: SortOrder
  }

  export type payment_release_associationsMinOrderByAggregateInput = {
    payment_release_id?: SortOrder
    payment_id?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type Payment_methodScalarRelationFilter = {
    is?: payment_methodWhereInput
    isNot?: payment_methodWhereInput
  }

  export type payment_releasesCountOrderByAggregateInput = {
    payment_release_id?: SortOrder
    user_id?: SortOrder
    total_net_amount?: SortOrder
    payment_method_id?: SortOrder
    status?: SortOrder
    external_transaction_id?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
    payee_id?: SortOrder
    release_date?: SortOrder
    batch_id?: SortOrder
  }

  export type payment_releasesAvgOrderByAggregateInput = {
    total_net_amount?: SortOrder
    payment_method_id?: SortOrder
  }

  export type payment_releasesMaxOrderByAggregateInput = {
    payment_release_id?: SortOrder
    user_id?: SortOrder
    total_net_amount?: SortOrder
    payment_method_id?: SortOrder
    status?: SortOrder
    external_transaction_id?: SortOrder
    created_at?: SortOrder
    payee_id?: SortOrder
    release_date?: SortOrder
    batch_id?: SortOrder
  }

  export type payment_releasesMinOrderByAggregateInput = {
    payment_release_id?: SortOrder
    user_id?: SortOrder
    total_net_amount?: SortOrder
    payment_method_id?: SortOrder
    status?: SortOrder
    external_transaction_id?: SortOrder
    created_at?: SortOrder
    payee_id?: SortOrder
    release_date?: SortOrder
    batch_id?: SortOrder
  }

  export type payment_releasesSumOrderByAggregateInput = {
    total_net_amount?: SortOrder
    payment_method_id?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type Enumpayment_method_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_method_status | Enumpayment_method_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.payment_method_status[] | ListEnumpayment_method_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.payment_method_status[] | ListEnumpayment_method_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumpayment_method_statusNullableFilter<$PrismaModel> | $Enums.payment_method_status | null
  }

  export type Trolley_recipientListRelationFilter = {
    every?: trolley_recipientWhereInput
    some?: trolley_recipientWhereInput
    none?: trolley_recipientWhereInput
  }

  export type trolley_recipientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_payment_methodsUser_idPayment_method_idCompoundUniqueInput = {
    user_id: string
    payment_method_id: number
  }

  export type user_payment_methodsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    payment_method_id?: SortOrder
    status?: SortOrder
  }

  export type user_payment_methodsAvgOrderByAggregateInput = {
    payment_method_id?: SortOrder
  }

  export type user_payment_methodsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    payment_method_id?: SortOrder
    status?: SortOrder
  }

  export type user_payment_methodsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    payment_method_id?: SortOrder
    status?: SortOrder
  }

  export type user_payment_methodsSumOrderByAggregateInput = {
    payment_method_id?: SortOrder
  }

  export type Enumpayment_method_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_method_status | Enumpayment_method_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.payment_method_status[] | ListEnumpayment_method_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.payment_method_status[] | ListEnumpayment_method_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumpayment_method_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.payment_method_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumpayment_method_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumpayment_method_statusNullableFilter<$PrismaModel>
  }

  export type Enumtax_form_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.tax_form_status | Enumtax_form_statusFieldRefInput<$PrismaModel>
    in?: $Enums.tax_form_status[] | ListEnumtax_form_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.tax_form_status[] | ListEnumtax_form_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumtax_form_statusFilter<$PrismaModel> | $Enums.tax_form_status
  }

  export type user_tax_form_associationsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    tax_form_id?: SortOrder
    date_filed?: SortOrder
    tax_form_status?: SortOrder
  }

  export type user_tax_form_associationsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    tax_form_id?: SortOrder
    date_filed?: SortOrder
    tax_form_status?: SortOrder
  }

  export type user_tax_form_associationsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    tax_form_id?: SortOrder
    date_filed?: SortOrder
    tax_form_status?: SortOrder
  }

  export type Enumtax_form_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.tax_form_status | Enumtax_form_statusFieldRefInput<$PrismaModel>
    in?: $Enums.tax_form_status[] | ListEnumtax_form_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.tax_form_status[] | ListEnumtax_form_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumtax_form_statusWithAggregatesFilter<$PrismaModel> | $Enums.tax_form_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtax_form_statusFilter<$PrismaModel>
    _max?: NestedEnumtax_form_statusFilter<$PrismaModel>
  }

  export type Enumwinnings_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.winnings_type | Enumwinnings_typeFieldRefInput<$PrismaModel>
    in?: $Enums.winnings_type[] | ListEnumwinnings_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.winnings_type[] | ListEnumwinnings_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumwinnings_typeFilter<$PrismaModel> | $Enums.winnings_type
  }

  export type Enumwinnings_categoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.winnings_category | Enumwinnings_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.winnings_category[] | ListEnumwinnings_categoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.winnings_category[] | ListEnumwinnings_categoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumwinnings_categoryNullableFilter<$PrismaModel> | $Enums.winnings_category | null
  }

  export type AuditListRelationFilter = {
    every?: auditWhereInput
    some?: auditWhereInput
    none?: auditWhereInput
  }

  export type OriginNullableScalarRelationFilter = {
    is?: originWhereInput | null
    isNot?: originWhereInput | null
  }

  export type auditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type winningsCountOrderByAggregateInput = {
    winning_id?: SortOrder
    winner_id?: SortOrder
    type?: SortOrder
    origin_id?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    external_id?: SortOrder
    attributes?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type winningsAvgOrderByAggregateInput = {
    origin_id?: SortOrder
  }

  export type winningsMaxOrderByAggregateInput = {
    winning_id?: SortOrder
    winner_id?: SortOrder
    type?: SortOrder
    origin_id?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    external_id?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type winningsMinOrderByAggregateInput = {
    winning_id?: SortOrder
    winner_id?: SortOrder
    type?: SortOrder
    origin_id?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    external_id?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type winningsSumOrderByAggregateInput = {
    origin_id?: SortOrder
  }

  export type Enumwinnings_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.winnings_type | Enumwinnings_typeFieldRefInput<$PrismaModel>
    in?: $Enums.winnings_type[] | ListEnumwinnings_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.winnings_type[] | ListEnumwinnings_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumwinnings_typeWithAggregatesFilter<$PrismaModel> | $Enums.winnings_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumwinnings_typeFilter<$PrismaModel>
    _max?: NestedEnumwinnings_typeFilter<$PrismaModel>
  }

  export type Enumwinnings_categoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.winnings_category | Enumwinnings_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.winnings_category[] | ListEnumwinnings_categoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.winnings_category[] | ListEnumwinnings_categoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumwinnings_categoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.winnings_category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumwinnings_categoryNullableFilter<$PrismaModel>
    _max?: NestedEnumwinnings_categoryNullableFilter<$PrismaModel>
  }

  export type Trolley_recipient_payment_methodListRelationFilter = {
    every?: trolley_recipient_payment_methodWhereInput
    some?: trolley_recipient_payment_methodWhereInput
    none?: trolley_recipient_payment_methodWhereInput
  }

  export type User_payment_methodsScalarRelationFilter = {
    is?: user_payment_methodsWhereInput
    isNot?: user_payment_methodsWhereInput
  }

  export type trolley_recipient_payment_methodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type trolley_recipientCountOrderByAggregateInput = {
    id?: SortOrder
    user_payment_method_id?: SortOrder
    user_id?: SortOrder
    trolley_id?: SortOrder
  }

  export type trolley_recipientAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type trolley_recipientMaxOrderByAggregateInput = {
    id?: SortOrder
    user_payment_method_id?: SortOrder
    user_id?: SortOrder
    trolley_id?: SortOrder
  }

  export type trolley_recipientMinOrderByAggregateInput = {
    id?: SortOrder
    user_payment_method_id?: SortOrder
    user_id?: SortOrder
    trolley_id?: SortOrder
  }

  export type trolley_recipientSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type Enumwebhook_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.webhook_status | Enumwebhook_statusFieldRefInput<$PrismaModel>
    in?: $Enums.webhook_status[] | ListEnumwebhook_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.webhook_status[] | ListEnumwebhook_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumwebhook_statusFilter<$PrismaModel> | $Enums.webhook_status
  }

  export type trolley_webhook_logCountOrderByAggregateInput = {
    id?: SortOrder
    event_id?: SortOrder
    event_time?: SortOrder
    event_payload?: SortOrder
    event_model?: SortOrder
    event_action?: SortOrder
    status?: SortOrder
    error_message?: SortOrder
    created_at?: SortOrder
  }

  export type trolley_webhook_logMaxOrderByAggregateInput = {
    id?: SortOrder
    event_id?: SortOrder
    event_time?: SortOrder
    event_model?: SortOrder
    event_action?: SortOrder
    status?: SortOrder
    error_message?: SortOrder
    created_at?: SortOrder
  }

  export type trolley_webhook_logMinOrderByAggregateInput = {
    id?: SortOrder
    event_id?: SortOrder
    event_time?: SortOrder
    event_model?: SortOrder
    event_action?: SortOrder
    status?: SortOrder
    error_message?: SortOrder
    created_at?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type Enumwebhook_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.webhook_status | Enumwebhook_statusFieldRefInput<$PrismaModel>
    in?: $Enums.webhook_status[] | ListEnumwebhook_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.webhook_status[] | ListEnumwebhook_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumwebhook_statusWithAggregatesFilter<$PrismaModel> | $Enums.webhook_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumwebhook_statusFilter<$PrismaModel>
    _max?: NestedEnumwebhook_statusFilter<$PrismaModel>
  }

  export type Enumverification_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.verification_status | Enumverification_statusFieldRefInput<$PrismaModel>
    in?: $Enums.verification_status[] | ListEnumverification_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.verification_status[] | ListEnumverification_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumverification_statusFilter<$PrismaModel> | $Enums.verification_status
  }

  export type user_identity_verification_associationsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    verification_id?: SortOrder
    date_filed?: SortOrder
    verification_status?: SortOrder
  }

  export type user_identity_verification_associationsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    verification_id?: SortOrder
    date_filed?: SortOrder
    verification_status?: SortOrder
  }

  export type user_identity_verification_associationsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    verification_id?: SortOrder
    date_filed?: SortOrder
    verification_status?: SortOrder
  }

  export type Enumverification_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.verification_status | Enumverification_statusFieldRefInput<$PrismaModel>
    in?: $Enums.verification_status[] | ListEnumverification_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.verification_status[] | ListEnumverification_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumverification_statusWithAggregatesFilter<$PrismaModel> | $Enums.verification_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumverification_statusFilter<$PrismaModel>
    _max?: NestedEnumverification_statusFilter<$PrismaModel>
  }

  export type Trolley_recipientScalarRelationFilter = {
    is?: trolley_recipientWhereInput
    isNot?: trolley_recipientWhereInput
  }

  export type trolley_recipient_payment_methodCountOrderByAggregateInput = {
    id?: SortOrder
    trolley_recipient_id?: SortOrder
    recipient_account_id?: SortOrder
  }

  export type trolley_recipient_payment_methodAvgOrderByAggregateInput = {
    trolley_recipient_id?: SortOrder
  }

  export type trolley_recipient_payment_methodMaxOrderByAggregateInput = {
    id?: SortOrder
    trolley_recipient_id?: SortOrder
    recipient_account_id?: SortOrder
  }

  export type trolley_recipient_payment_methodMinOrderByAggregateInput = {
    id?: SortOrder
    trolley_recipient_id?: SortOrder
    recipient_account_id?: SortOrder
  }

  export type trolley_recipient_payment_methodSumOrderByAggregateInput = {
    trolley_recipient_id?: SortOrder
  }

  export type challenge_lockCountOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    lock_time?: SortOrder
    error?: SortOrder
  }

  export type challenge_lockAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type challenge_lockMaxOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    lock_time?: SortOrder
    error?: SortOrder
  }

  export type challenge_lockMinOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    lock_time?: SortOrder
    error?: SortOrder
  }

  export type challenge_lockSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type winningsCreateNestedOneWithoutAuditInput = {
    create?: XOR<winningsCreateWithoutAuditInput, winningsUncheckedCreateWithoutAuditInput>
    connectOrCreate?: winningsCreateOrConnectWithoutAuditInput
    connect?: winningsWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type winningsUpdateOneRequiredWithoutAuditNestedInput = {
    create?: XOR<winningsCreateWithoutAuditInput, winningsUncheckedCreateWithoutAuditInput>
    connectOrCreate?: winningsCreateOrConnectWithoutAuditInput
    upsert?: winningsUpsertWithoutAuditInput
    connect?: winningsWhereUniqueInput
    update?: XOR<XOR<winningsUpdateToOneWithWhereWithoutAuditInput, winningsUpdateWithoutAuditInput>, winningsUncheckedUpdateWithoutAuditInput>
  }

  export type winningsCreateNestedManyWithoutOriginInput = {
    create?: XOR<winningsCreateWithoutOriginInput, winningsUncheckedCreateWithoutOriginInput> | winningsCreateWithoutOriginInput[] | winningsUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: winningsCreateOrConnectWithoutOriginInput | winningsCreateOrConnectWithoutOriginInput[]
    createMany?: winningsCreateManyOriginInputEnvelope
    connect?: winningsWhereUniqueInput | winningsWhereUniqueInput[]
  }

  export type winningsUncheckedCreateNestedManyWithoutOriginInput = {
    create?: XOR<winningsCreateWithoutOriginInput, winningsUncheckedCreateWithoutOriginInput> | winningsCreateWithoutOriginInput[] | winningsUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: winningsCreateOrConnectWithoutOriginInput | winningsCreateOrConnectWithoutOriginInput[]
    createMany?: winningsCreateManyOriginInputEnvelope
    connect?: winningsWhereUniqueInput | winningsWhereUniqueInput[]
  }

  export type winningsUpdateManyWithoutOriginNestedInput = {
    create?: XOR<winningsCreateWithoutOriginInput, winningsUncheckedCreateWithoutOriginInput> | winningsCreateWithoutOriginInput[] | winningsUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: winningsCreateOrConnectWithoutOriginInput | winningsCreateOrConnectWithoutOriginInput[]
    upsert?: winningsUpsertWithWhereUniqueWithoutOriginInput | winningsUpsertWithWhereUniqueWithoutOriginInput[]
    createMany?: winningsCreateManyOriginInputEnvelope
    set?: winningsWhereUniqueInput | winningsWhereUniqueInput[]
    disconnect?: winningsWhereUniqueInput | winningsWhereUniqueInput[]
    delete?: winningsWhereUniqueInput | winningsWhereUniqueInput[]
    connect?: winningsWhereUniqueInput | winningsWhereUniqueInput[]
    update?: winningsUpdateWithWhereUniqueWithoutOriginInput | winningsUpdateWithWhereUniqueWithoutOriginInput[]
    updateMany?: winningsUpdateManyWithWhereWithoutOriginInput | winningsUpdateManyWithWhereWithoutOriginInput[]
    deleteMany?: winningsScalarWhereInput | winningsScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type winningsUncheckedUpdateManyWithoutOriginNestedInput = {
    create?: XOR<winningsCreateWithoutOriginInput, winningsUncheckedCreateWithoutOriginInput> | winningsCreateWithoutOriginInput[] | winningsUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: winningsCreateOrConnectWithoutOriginInput | winningsCreateOrConnectWithoutOriginInput[]
    upsert?: winningsUpsertWithWhereUniqueWithoutOriginInput | winningsUpsertWithWhereUniqueWithoutOriginInput[]
    createMany?: winningsCreateManyOriginInputEnvelope
    set?: winningsWhereUniqueInput | winningsWhereUniqueInput[]
    disconnect?: winningsWhereUniqueInput | winningsWhereUniqueInput[]
    delete?: winningsWhereUniqueInput | winningsWhereUniqueInput[]
    connect?: winningsWhereUniqueInput | winningsWhereUniqueInput[]
    update?: winningsUpdateWithWhereUniqueWithoutOriginInput | winningsUpdateWithWhereUniqueWithoutOriginInput[]
    updateMany?: winningsUpdateManyWithWhereWithoutOriginInput | winningsUpdateManyWithWhereWithoutOriginInput[]
    deleteMany?: winningsScalarWhereInput | winningsScalarWhereInput[]
  }

  export type Enumreference_typeFieldUpdateOperationsInput = {
    set?: $Enums.reference_type
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type payment_methodCreateNestedOneWithoutPaymentInput = {
    create?: XOR<payment_methodCreateWithoutPaymentInput, payment_methodUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: payment_methodCreateOrConnectWithoutPaymentInput
    connect?: payment_methodWhereUniqueInput
  }

  export type winningsCreateNestedOneWithoutPaymentInput = {
    create?: XOR<winningsCreateWithoutPaymentInput, winningsUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: winningsCreateOrConnectWithoutPaymentInput
    connect?: winningsWhereUniqueInput
  }

  export type payment_release_associationsCreateNestedManyWithoutPaymentInput = {
    create?: XOR<payment_release_associationsCreateWithoutPaymentInput, payment_release_associationsUncheckedCreateWithoutPaymentInput> | payment_release_associationsCreateWithoutPaymentInput[] | payment_release_associationsUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: payment_release_associationsCreateOrConnectWithoutPaymentInput | payment_release_associationsCreateOrConnectWithoutPaymentInput[]
    createMany?: payment_release_associationsCreateManyPaymentInputEnvelope
    connect?: payment_release_associationsWhereUniqueInput | payment_release_associationsWhereUniqueInput[]
  }

  export type payment_release_associationsUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<payment_release_associationsCreateWithoutPaymentInput, payment_release_associationsUncheckedCreateWithoutPaymentInput> | payment_release_associationsCreateWithoutPaymentInput[] | payment_release_associationsUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: payment_release_associationsCreateOrConnectWithoutPaymentInput | payment_release_associationsCreateOrConnectWithoutPaymentInput[]
    createMany?: payment_release_associationsCreateManyPaymentInputEnvelope
    connect?: payment_release_associationsWhereUniqueInput | payment_release_associationsWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumpayment_statusFieldUpdateOperationsInput = {
    set?: $Enums.payment_status | null
  }

  export type payment_methodUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<payment_methodCreateWithoutPaymentInput, payment_methodUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: payment_methodCreateOrConnectWithoutPaymentInput
    upsert?: payment_methodUpsertWithoutPaymentInput
    disconnect?: payment_methodWhereInput | boolean
    delete?: payment_methodWhereInput | boolean
    connect?: payment_methodWhereUniqueInput
    update?: XOR<XOR<payment_methodUpdateToOneWithWhereWithoutPaymentInput, payment_methodUpdateWithoutPaymentInput>, payment_methodUncheckedUpdateWithoutPaymentInput>
  }

  export type winningsUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<winningsCreateWithoutPaymentInput, winningsUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: winningsCreateOrConnectWithoutPaymentInput
    upsert?: winningsUpsertWithoutPaymentInput
    connect?: winningsWhereUniqueInput
    update?: XOR<XOR<winningsUpdateToOneWithWhereWithoutPaymentInput, winningsUpdateWithoutPaymentInput>, winningsUncheckedUpdateWithoutPaymentInput>
  }

  export type payment_release_associationsUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<payment_release_associationsCreateWithoutPaymentInput, payment_release_associationsUncheckedCreateWithoutPaymentInput> | payment_release_associationsCreateWithoutPaymentInput[] | payment_release_associationsUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: payment_release_associationsCreateOrConnectWithoutPaymentInput | payment_release_associationsCreateOrConnectWithoutPaymentInput[]
    upsert?: payment_release_associationsUpsertWithWhereUniqueWithoutPaymentInput | payment_release_associationsUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: payment_release_associationsCreateManyPaymentInputEnvelope
    set?: payment_release_associationsWhereUniqueInput | payment_release_associationsWhereUniqueInput[]
    disconnect?: payment_release_associationsWhereUniqueInput | payment_release_associationsWhereUniqueInput[]
    delete?: payment_release_associationsWhereUniqueInput | payment_release_associationsWhereUniqueInput[]
    connect?: payment_release_associationsWhereUniqueInput | payment_release_associationsWhereUniqueInput[]
    update?: payment_release_associationsUpdateWithWhereUniqueWithoutPaymentInput | payment_release_associationsUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: payment_release_associationsUpdateManyWithWhereWithoutPaymentInput | payment_release_associationsUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: payment_release_associationsScalarWhereInput | payment_release_associationsScalarWhereInput[]
  }

  export type payment_release_associationsUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<payment_release_associationsCreateWithoutPaymentInput, payment_release_associationsUncheckedCreateWithoutPaymentInput> | payment_release_associationsCreateWithoutPaymentInput[] | payment_release_associationsUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: payment_release_associationsCreateOrConnectWithoutPaymentInput | payment_release_associationsCreateOrConnectWithoutPaymentInput[]
    upsert?: payment_release_associationsUpsertWithWhereUniqueWithoutPaymentInput | payment_release_associationsUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: payment_release_associationsCreateManyPaymentInputEnvelope
    set?: payment_release_associationsWhereUniqueInput | payment_release_associationsWhereUniqueInput[]
    disconnect?: payment_release_associationsWhereUniqueInput | payment_release_associationsWhereUniqueInput[]
    delete?: payment_release_associationsWhereUniqueInput | payment_release_associationsWhereUniqueInput[]
    connect?: payment_release_associationsWhereUniqueInput | payment_release_associationsWhereUniqueInput[]
    update?: payment_release_associationsUpdateWithWhereUniqueWithoutPaymentInput | payment_release_associationsUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: payment_release_associationsUpdateManyWithWhereWithoutPaymentInput | payment_release_associationsUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: payment_release_associationsScalarWhereInput | payment_release_associationsScalarWhereInput[]
  }

  export type paymentCreateNestedManyWithoutPayment_methodInput = {
    create?: XOR<paymentCreateWithoutPayment_methodInput, paymentUncheckedCreateWithoutPayment_methodInput> | paymentCreateWithoutPayment_methodInput[] | paymentUncheckedCreateWithoutPayment_methodInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutPayment_methodInput | paymentCreateOrConnectWithoutPayment_methodInput[]
    createMany?: paymentCreateManyPayment_methodInputEnvelope
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
  }

  export type payment_releasesCreateNestedManyWithoutPayment_methodInput = {
    create?: XOR<payment_releasesCreateWithoutPayment_methodInput, payment_releasesUncheckedCreateWithoutPayment_methodInput> | payment_releasesCreateWithoutPayment_methodInput[] | payment_releasesUncheckedCreateWithoutPayment_methodInput[]
    connectOrCreate?: payment_releasesCreateOrConnectWithoutPayment_methodInput | payment_releasesCreateOrConnectWithoutPayment_methodInput[]
    createMany?: payment_releasesCreateManyPayment_methodInputEnvelope
    connect?: payment_releasesWhereUniqueInput | payment_releasesWhereUniqueInput[]
  }

  export type user_payment_methodsCreateNestedManyWithoutPayment_methodInput = {
    create?: XOR<user_payment_methodsCreateWithoutPayment_methodInput, user_payment_methodsUncheckedCreateWithoutPayment_methodInput> | user_payment_methodsCreateWithoutPayment_methodInput[] | user_payment_methodsUncheckedCreateWithoutPayment_methodInput[]
    connectOrCreate?: user_payment_methodsCreateOrConnectWithoutPayment_methodInput | user_payment_methodsCreateOrConnectWithoutPayment_methodInput[]
    createMany?: user_payment_methodsCreateManyPayment_methodInputEnvelope
    connect?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
  }

  export type paymentUncheckedCreateNestedManyWithoutPayment_methodInput = {
    create?: XOR<paymentCreateWithoutPayment_methodInput, paymentUncheckedCreateWithoutPayment_methodInput> | paymentCreateWithoutPayment_methodInput[] | paymentUncheckedCreateWithoutPayment_methodInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutPayment_methodInput | paymentCreateOrConnectWithoutPayment_methodInput[]
    createMany?: paymentCreateManyPayment_methodInputEnvelope
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
  }

  export type payment_releasesUncheckedCreateNestedManyWithoutPayment_methodInput = {
    create?: XOR<payment_releasesCreateWithoutPayment_methodInput, payment_releasesUncheckedCreateWithoutPayment_methodInput> | payment_releasesCreateWithoutPayment_methodInput[] | payment_releasesUncheckedCreateWithoutPayment_methodInput[]
    connectOrCreate?: payment_releasesCreateOrConnectWithoutPayment_methodInput | payment_releasesCreateOrConnectWithoutPayment_methodInput[]
    createMany?: payment_releasesCreateManyPayment_methodInputEnvelope
    connect?: payment_releasesWhereUniqueInput | payment_releasesWhereUniqueInput[]
  }

  export type user_payment_methodsUncheckedCreateNestedManyWithoutPayment_methodInput = {
    create?: XOR<user_payment_methodsCreateWithoutPayment_methodInput, user_payment_methodsUncheckedCreateWithoutPayment_methodInput> | user_payment_methodsCreateWithoutPayment_methodInput[] | user_payment_methodsUncheckedCreateWithoutPayment_methodInput[]
    connectOrCreate?: user_payment_methodsCreateOrConnectWithoutPayment_methodInput | user_payment_methodsCreateOrConnectWithoutPayment_methodInput[]
    createMany?: user_payment_methodsCreateManyPayment_methodInputEnvelope
    connect?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
  }

  export type paymentUpdateManyWithoutPayment_methodNestedInput = {
    create?: XOR<paymentCreateWithoutPayment_methodInput, paymentUncheckedCreateWithoutPayment_methodInput> | paymentCreateWithoutPayment_methodInput[] | paymentUncheckedCreateWithoutPayment_methodInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutPayment_methodInput | paymentCreateOrConnectWithoutPayment_methodInput[]
    upsert?: paymentUpsertWithWhereUniqueWithoutPayment_methodInput | paymentUpsertWithWhereUniqueWithoutPayment_methodInput[]
    createMany?: paymentCreateManyPayment_methodInputEnvelope
    set?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    disconnect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    delete?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    update?: paymentUpdateWithWhereUniqueWithoutPayment_methodInput | paymentUpdateWithWhereUniqueWithoutPayment_methodInput[]
    updateMany?: paymentUpdateManyWithWhereWithoutPayment_methodInput | paymentUpdateManyWithWhereWithoutPayment_methodInput[]
    deleteMany?: paymentScalarWhereInput | paymentScalarWhereInput[]
  }

  export type payment_releasesUpdateManyWithoutPayment_methodNestedInput = {
    create?: XOR<payment_releasesCreateWithoutPayment_methodInput, payment_releasesUncheckedCreateWithoutPayment_methodInput> | payment_releasesCreateWithoutPayment_methodInput[] | payment_releasesUncheckedCreateWithoutPayment_methodInput[]
    connectOrCreate?: payment_releasesCreateOrConnectWithoutPayment_methodInput | payment_releasesCreateOrConnectWithoutPayment_methodInput[]
    upsert?: payment_releasesUpsertWithWhereUniqueWithoutPayment_methodInput | payment_releasesUpsertWithWhereUniqueWithoutPayment_methodInput[]
    createMany?: payment_releasesCreateManyPayment_methodInputEnvelope
    set?: payment_releasesWhereUniqueInput | payment_releasesWhereUniqueInput[]
    disconnect?: payment_releasesWhereUniqueInput | payment_releasesWhereUniqueInput[]
    delete?: payment_releasesWhereUniqueInput | payment_releasesWhereUniqueInput[]
    connect?: payment_releasesWhereUniqueInput | payment_releasesWhereUniqueInput[]
    update?: payment_releasesUpdateWithWhereUniqueWithoutPayment_methodInput | payment_releasesUpdateWithWhereUniqueWithoutPayment_methodInput[]
    updateMany?: payment_releasesUpdateManyWithWhereWithoutPayment_methodInput | payment_releasesUpdateManyWithWhereWithoutPayment_methodInput[]
    deleteMany?: payment_releasesScalarWhereInput | payment_releasesScalarWhereInput[]
  }

  export type user_payment_methodsUpdateManyWithoutPayment_methodNestedInput = {
    create?: XOR<user_payment_methodsCreateWithoutPayment_methodInput, user_payment_methodsUncheckedCreateWithoutPayment_methodInput> | user_payment_methodsCreateWithoutPayment_methodInput[] | user_payment_methodsUncheckedCreateWithoutPayment_methodInput[]
    connectOrCreate?: user_payment_methodsCreateOrConnectWithoutPayment_methodInput | user_payment_methodsCreateOrConnectWithoutPayment_methodInput[]
    upsert?: user_payment_methodsUpsertWithWhereUniqueWithoutPayment_methodInput | user_payment_methodsUpsertWithWhereUniqueWithoutPayment_methodInput[]
    createMany?: user_payment_methodsCreateManyPayment_methodInputEnvelope
    set?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
    disconnect?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
    delete?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
    connect?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
    update?: user_payment_methodsUpdateWithWhereUniqueWithoutPayment_methodInput | user_payment_methodsUpdateWithWhereUniqueWithoutPayment_methodInput[]
    updateMany?: user_payment_methodsUpdateManyWithWhereWithoutPayment_methodInput | user_payment_methodsUpdateManyWithWhereWithoutPayment_methodInput[]
    deleteMany?: user_payment_methodsScalarWhereInput | user_payment_methodsScalarWhereInput[]
  }

  export type paymentUncheckedUpdateManyWithoutPayment_methodNestedInput = {
    create?: XOR<paymentCreateWithoutPayment_methodInput, paymentUncheckedCreateWithoutPayment_methodInput> | paymentCreateWithoutPayment_methodInput[] | paymentUncheckedCreateWithoutPayment_methodInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutPayment_methodInput | paymentCreateOrConnectWithoutPayment_methodInput[]
    upsert?: paymentUpsertWithWhereUniqueWithoutPayment_methodInput | paymentUpsertWithWhereUniqueWithoutPayment_methodInput[]
    createMany?: paymentCreateManyPayment_methodInputEnvelope
    set?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    disconnect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    delete?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    update?: paymentUpdateWithWhereUniqueWithoutPayment_methodInput | paymentUpdateWithWhereUniqueWithoutPayment_methodInput[]
    updateMany?: paymentUpdateManyWithWhereWithoutPayment_methodInput | paymentUpdateManyWithWhereWithoutPayment_methodInput[]
    deleteMany?: paymentScalarWhereInput | paymentScalarWhereInput[]
  }

  export type payment_releasesUncheckedUpdateManyWithoutPayment_methodNestedInput = {
    create?: XOR<payment_releasesCreateWithoutPayment_methodInput, payment_releasesUncheckedCreateWithoutPayment_methodInput> | payment_releasesCreateWithoutPayment_methodInput[] | payment_releasesUncheckedCreateWithoutPayment_methodInput[]
    connectOrCreate?: payment_releasesCreateOrConnectWithoutPayment_methodInput | payment_releasesCreateOrConnectWithoutPayment_methodInput[]
    upsert?: payment_releasesUpsertWithWhereUniqueWithoutPayment_methodInput | payment_releasesUpsertWithWhereUniqueWithoutPayment_methodInput[]
    createMany?: payment_releasesCreateManyPayment_methodInputEnvelope
    set?: payment_releasesWhereUniqueInput | payment_releasesWhereUniqueInput[]
    disconnect?: payment_releasesWhereUniqueInput | payment_releasesWhereUniqueInput[]
    delete?: payment_releasesWhereUniqueInput | payment_releasesWhereUniqueInput[]
    connect?: payment_releasesWhereUniqueInput | payment_releasesWhereUniqueInput[]
    update?: payment_releasesUpdateWithWhereUniqueWithoutPayment_methodInput | payment_releasesUpdateWithWhereUniqueWithoutPayment_methodInput[]
    updateMany?: payment_releasesUpdateManyWithWhereWithoutPayment_methodInput | payment_releasesUpdateManyWithWhereWithoutPayment_methodInput[]
    deleteMany?: payment_releasesScalarWhereInput | payment_releasesScalarWhereInput[]
  }

  export type user_payment_methodsUncheckedUpdateManyWithoutPayment_methodNestedInput = {
    create?: XOR<user_payment_methodsCreateWithoutPayment_methodInput, user_payment_methodsUncheckedCreateWithoutPayment_methodInput> | user_payment_methodsCreateWithoutPayment_methodInput[] | user_payment_methodsUncheckedCreateWithoutPayment_methodInput[]
    connectOrCreate?: user_payment_methodsCreateOrConnectWithoutPayment_methodInput | user_payment_methodsCreateOrConnectWithoutPayment_methodInput[]
    upsert?: user_payment_methodsUpsertWithWhereUniqueWithoutPayment_methodInput | user_payment_methodsUpsertWithWhereUniqueWithoutPayment_methodInput[]
    createMany?: user_payment_methodsCreateManyPayment_methodInputEnvelope
    set?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
    disconnect?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
    delete?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
    connect?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
    update?: user_payment_methodsUpdateWithWhereUniqueWithoutPayment_methodInput | user_payment_methodsUpdateWithWhereUniqueWithoutPayment_methodInput[]
    updateMany?: user_payment_methodsUpdateManyWithWhereWithoutPayment_methodInput | user_payment_methodsUpdateManyWithWhereWithoutPayment_methodInput[]
    deleteMany?: user_payment_methodsScalarWhereInput | user_payment_methodsScalarWhereInput[]
  }

  export type paymentCreateNestedOneWithoutPayment_release_associationsInput = {
    create?: XOR<paymentCreateWithoutPayment_release_associationsInput, paymentUncheckedCreateWithoutPayment_release_associationsInput>
    connectOrCreate?: paymentCreateOrConnectWithoutPayment_release_associationsInput
    connect?: paymentWhereUniqueInput
  }

  export type payment_releasesCreateNestedOneWithoutPayment_release_associationsInput = {
    create?: XOR<payment_releasesCreateWithoutPayment_release_associationsInput, payment_releasesUncheckedCreateWithoutPayment_release_associationsInput>
    connectOrCreate?: payment_releasesCreateOrConnectWithoutPayment_release_associationsInput
    connect?: payment_releasesWhereUniqueInput
  }

  export type paymentUpdateOneRequiredWithoutPayment_release_associationsNestedInput = {
    create?: XOR<paymentCreateWithoutPayment_release_associationsInput, paymentUncheckedCreateWithoutPayment_release_associationsInput>
    connectOrCreate?: paymentCreateOrConnectWithoutPayment_release_associationsInput
    upsert?: paymentUpsertWithoutPayment_release_associationsInput
    connect?: paymentWhereUniqueInput
    update?: XOR<XOR<paymentUpdateToOneWithWhereWithoutPayment_release_associationsInput, paymentUpdateWithoutPayment_release_associationsInput>, paymentUncheckedUpdateWithoutPayment_release_associationsInput>
  }

  export type payment_releasesUpdateOneRequiredWithoutPayment_release_associationsNestedInput = {
    create?: XOR<payment_releasesCreateWithoutPayment_release_associationsInput, payment_releasesUncheckedCreateWithoutPayment_release_associationsInput>
    connectOrCreate?: payment_releasesCreateOrConnectWithoutPayment_release_associationsInput
    upsert?: payment_releasesUpsertWithoutPayment_release_associationsInput
    connect?: payment_releasesWhereUniqueInput
    update?: XOR<XOR<payment_releasesUpdateToOneWithWhereWithoutPayment_release_associationsInput, payment_releasesUpdateWithoutPayment_release_associationsInput>, payment_releasesUncheckedUpdateWithoutPayment_release_associationsInput>
  }

  export type payment_release_associationsCreateNestedManyWithoutPayment_releasesInput = {
    create?: XOR<payment_release_associationsCreateWithoutPayment_releasesInput, payment_release_associationsUncheckedCreateWithoutPayment_releasesInput> | payment_release_associationsCreateWithoutPayment_releasesInput[] | payment_release_associationsUncheckedCreateWithoutPayment_releasesInput[]
    connectOrCreate?: payment_release_associationsCreateOrConnectWithoutPayment_releasesInput | payment_release_associationsCreateOrConnectWithoutPayment_releasesInput[]
    createMany?: payment_release_associationsCreateManyPayment_releasesInputEnvelope
    connect?: payment_release_associationsWhereUniqueInput | payment_release_associationsWhereUniqueInput[]
  }

  export type payment_methodCreateNestedOneWithoutPayment_releasesInput = {
    create?: XOR<payment_methodCreateWithoutPayment_releasesInput, payment_methodUncheckedCreateWithoutPayment_releasesInput>
    connectOrCreate?: payment_methodCreateOrConnectWithoutPayment_releasesInput
    connect?: payment_methodWhereUniqueInput
  }

  export type payment_release_associationsUncheckedCreateNestedManyWithoutPayment_releasesInput = {
    create?: XOR<payment_release_associationsCreateWithoutPayment_releasesInput, payment_release_associationsUncheckedCreateWithoutPayment_releasesInput> | payment_release_associationsCreateWithoutPayment_releasesInput[] | payment_release_associationsUncheckedCreateWithoutPayment_releasesInput[]
    connectOrCreate?: payment_release_associationsCreateOrConnectWithoutPayment_releasesInput | payment_release_associationsCreateOrConnectWithoutPayment_releasesInput[]
    createMany?: payment_release_associationsCreateManyPayment_releasesInputEnvelope
    connect?: payment_release_associationsWhereUniqueInput | payment_release_associationsWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type payment_release_associationsUpdateManyWithoutPayment_releasesNestedInput = {
    create?: XOR<payment_release_associationsCreateWithoutPayment_releasesInput, payment_release_associationsUncheckedCreateWithoutPayment_releasesInput> | payment_release_associationsCreateWithoutPayment_releasesInput[] | payment_release_associationsUncheckedCreateWithoutPayment_releasesInput[]
    connectOrCreate?: payment_release_associationsCreateOrConnectWithoutPayment_releasesInput | payment_release_associationsCreateOrConnectWithoutPayment_releasesInput[]
    upsert?: payment_release_associationsUpsertWithWhereUniqueWithoutPayment_releasesInput | payment_release_associationsUpsertWithWhereUniqueWithoutPayment_releasesInput[]
    createMany?: payment_release_associationsCreateManyPayment_releasesInputEnvelope
    set?: payment_release_associationsWhereUniqueInput | payment_release_associationsWhereUniqueInput[]
    disconnect?: payment_release_associationsWhereUniqueInput | payment_release_associationsWhereUniqueInput[]
    delete?: payment_release_associationsWhereUniqueInput | payment_release_associationsWhereUniqueInput[]
    connect?: payment_release_associationsWhereUniqueInput | payment_release_associationsWhereUniqueInput[]
    update?: payment_release_associationsUpdateWithWhereUniqueWithoutPayment_releasesInput | payment_release_associationsUpdateWithWhereUniqueWithoutPayment_releasesInput[]
    updateMany?: payment_release_associationsUpdateManyWithWhereWithoutPayment_releasesInput | payment_release_associationsUpdateManyWithWhereWithoutPayment_releasesInput[]
    deleteMany?: payment_release_associationsScalarWhereInput | payment_release_associationsScalarWhereInput[]
  }

  export type payment_methodUpdateOneRequiredWithoutPayment_releasesNestedInput = {
    create?: XOR<payment_methodCreateWithoutPayment_releasesInput, payment_methodUncheckedCreateWithoutPayment_releasesInput>
    connectOrCreate?: payment_methodCreateOrConnectWithoutPayment_releasesInput
    upsert?: payment_methodUpsertWithoutPayment_releasesInput
    connect?: payment_methodWhereUniqueInput
    update?: XOR<XOR<payment_methodUpdateToOneWithWhereWithoutPayment_releasesInput, payment_methodUpdateWithoutPayment_releasesInput>, payment_methodUncheckedUpdateWithoutPayment_releasesInput>
  }

  export type payment_release_associationsUncheckedUpdateManyWithoutPayment_releasesNestedInput = {
    create?: XOR<payment_release_associationsCreateWithoutPayment_releasesInput, payment_release_associationsUncheckedCreateWithoutPayment_releasesInput> | payment_release_associationsCreateWithoutPayment_releasesInput[] | payment_release_associationsUncheckedCreateWithoutPayment_releasesInput[]
    connectOrCreate?: payment_release_associationsCreateOrConnectWithoutPayment_releasesInput | payment_release_associationsCreateOrConnectWithoutPayment_releasesInput[]
    upsert?: payment_release_associationsUpsertWithWhereUniqueWithoutPayment_releasesInput | payment_release_associationsUpsertWithWhereUniqueWithoutPayment_releasesInput[]
    createMany?: payment_release_associationsCreateManyPayment_releasesInputEnvelope
    set?: payment_release_associationsWhereUniqueInput | payment_release_associationsWhereUniqueInput[]
    disconnect?: payment_release_associationsWhereUniqueInput | payment_release_associationsWhereUniqueInput[]
    delete?: payment_release_associationsWhereUniqueInput | payment_release_associationsWhereUniqueInput[]
    connect?: payment_release_associationsWhereUniqueInput | payment_release_associationsWhereUniqueInput[]
    update?: payment_release_associationsUpdateWithWhereUniqueWithoutPayment_releasesInput | payment_release_associationsUpdateWithWhereUniqueWithoutPayment_releasesInput[]
    updateMany?: payment_release_associationsUpdateManyWithWhereWithoutPayment_releasesInput | payment_release_associationsUpdateManyWithWhereWithoutPayment_releasesInput[]
    deleteMany?: payment_release_associationsScalarWhereInput | payment_release_associationsScalarWhereInput[]
  }

  export type trolley_recipientCreateNestedManyWithoutUser_payment_methodsInput = {
    create?: XOR<trolley_recipientCreateWithoutUser_payment_methodsInput, trolley_recipientUncheckedCreateWithoutUser_payment_methodsInput> | trolley_recipientCreateWithoutUser_payment_methodsInput[] | trolley_recipientUncheckedCreateWithoutUser_payment_methodsInput[]
    connectOrCreate?: trolley_recipientCreateOrConnectWithoutUser_payment_methodsInput | trolley_recipientCreateOrConnectWithoutUser_payment_methodsInput[]
    createMany?: trolley_recipientCreateManyUser_payment_methodsInputEnvelope
    connect?: trolley_recipientWhereUniqueInput | trolley_recipientWhereUniqueInput[]
  }

  export type payment_methodCreateNestedOneWithoutUser_payment_methodsInput = {
    create?: XOR<payment_methodCreateWithoutUser_payment_methodsInput, payment_methodUncheckedCreateWithoutUser_payment_methodsInput>
    connectOrCreate?: payment_methodCreateOrConnectWithoutUser_payment_methodsInput
    connect?: payment_methodWhereUniqueInput
  }

  export type trolley_recipientUncheckedCreateNestedManyWithoutUser_payment_methodsInput = {
    create?: XOR<trolley_recipientCreateWithoutUser_payment_methodsInput, trolley_recipientUncheckedCreateWithoutUser_payment_methodsInput> | trolley_recipientCreateWithoutUser_payment_methodsInput[] | trolley_recipientUncheckedCreateWithoutUser_payment_methodsInput[]
    connectOrCreate?: trolley_recipientCreateOrConnectWithoutUser_payment_methodsInput | trolley_recipientCreateOrConnectWithoutUser_payment_methodsInput[]
    createMany?: trolley_recipientCreateManyUser_payment_methodsInputEnvelope
    connect?: trolley_recipientWhereUniqueInput | trolley_recipientWhereUniqueInput[]
  }

  export type NullableEnumpayment_method_statusFieldUpdateOperationsInput = {
    set?: $Enums.payment_method_status | null
  }

  export type trolley_recipientUpdateManyWithoutUser_payment_methodsNestedInput = {
    create?: XOR<trolley_recipientCreateWithoutUser_payment_methodsInput, trolley_recipientUncheckedCreateWithoutUser_payment_methodsInput> | trolley_recipientCreateWithoutUser_payment_methodsInput[] | trolley_recipientUncheckedCreateWithoutUser_payment_methodsInput[]
    connectOrCreate?: trolley_recipientCreateOrConnectWithoutUser_payment_methodsInput | trolley_recipientCreateOrConnectWithoutUser_payment_methodsInput[]
    upsert?: trolley_recipientUpsertWithWhereUniqueWithoutUser_payment_methodsInput | trolley_recipientUpsertWithWhereUniqueWithoutUser_payment_methodsInput[]
    createMany?: trolley_recipientCreateManyUser_payment_methodsInputEnvelope
    set?: trolley_recipientWhereUniqueInput | trolley_recipientWhereUniqueInput[]
    disconnect?: trolley_recipientWhereUniqueInput | trolley_recipientWhereUniqueInput[]
    delete?: trolley_recipientWhereUniqueInput | trolley_recipientWhereUniqueInput[]
    connect?: trolley_recipientWhereUniqueInput | trolley_recipientWhereUniqueInput[]
    update?: trolley_recipientUpdateWithWhereUniqueWithoutUser_payment_methodsInput | trolley_recipientUpdateWithWhereUniqueWithoutUser_payment_methodsInput[]
    updateMany?: trolley_recipientUpdateManyWithWhereWithoutUser_payment_methodsInput | trolley_recipientUpdateManyWithWhereWithoutUser_payment_methodsInput[]
    deleteMany?: trolley_recipientScalarWhereInput | trolley_recipientScalarWhereInput[]
  }

  export type payment_methodUpdateOneRequiredWithoutUser_payment_methodsNestedInput = {
    create?: XOR<payment_methodCreateWithoutUser_payment_methodsInput, payment_methodUncheckedCreateWithoutUser_payment_methodsInput>
    connectOrCreate?: payment_methodCreateOrConnectWithoutUser_payment_methodsInput
    upsert?: payment_methodUpsertWithoutUser_payment_methodsInput
    connect?: payment_methodWhereUniqueInput
    update?: XOR<XOR<payment_methodUpdateToOneWithWhereWithoutUser_payment_methodsInput, payment_methodUpdateWithoutUser_payment_methodsInput>, payment_methodUncheckedUpdateWithoutUser_payment_methodsInput>
  }

  export type trolley_recipientUncheckedUpdateManyWithoutUser_payment_methodsNestedInput = {
    create?: XOR<trolley_recipientCreateWithoutUser_payment_methodsInput, trolley_recipientUncheckedCreateWithoutUser_payment_methodsInput> | trolley_recipientCreateWithoutUser_payment_methodsInput[] | trolley_recipientUncheckedCreateWithoutUser_payment_methodsInput[]
    connectOrCreate?: trolley_recipientCreateOrConnectWithoutUser_payment_methodsInput | trolley_recipientCreateOrConnectWithoutUser_payment_methodsInput[]
    upsert?: trolley_recipientUpsertWithWhereUniqueWithoutUser_payment_methodsInput | trolley_recipientUpsertWithWhereUniqueWithoutUser_payment_methodsInput[]
    createMany?: trolley_recipientCreateManyUser_payment_methodsInputEnvelope
    set?: trolley_recipientWhereUniqueInput | trolley_recipientWhereUniqueInput[]
    disconnect?: trolley_recipientWhereUniqueInput | trolley_recipientWhereUniqueInput[]
    delete?: trolley_recipientWhereUniqueInput | trolley_recipientWhereUniqueInput[]
    connect?: trolley_recipientWhereUniqueInput | trolley_recipientWhereUniqueInput[]
    update?: trolley_recipientUpdateWithWhereUniqueWithoutUser_payment_methodsInput | trolley_recipientUpdateWithWhereUniqueWithoutUser_payment_methodsInput[]
    updateMany?: trolley_recipientUpdateManyWithWhereWithoutUser_payment_methodsInput | trolley_recipientUpdateManyWithWhereWithoutUser_payment_methodsInput[]
    deleteMany?: trolley_recipientScalarWhereInput | trolley_recipientScalarWhereInput[]
  }

  export type Enumtax_form_statusFieldUpdateOperationsInput = {
    set?: $Enums.tax_form_status
  }

  export type auditCreateNestedManyWithoutWinningsInput = {
    create?: XOR<auditCreateWithoutWinningsInput, auditUncheckedCreateWithoutWinningsInput> | auditCreateWithoutWinningsInput[] | auditUncheckedCreateWithoutWinningsInput[]
    connectOrCreate?: auditCreateOrConnectWithoutWinningsInput | auditCreateOrConnectWithoutWinningsInput[]
    createMany?: auditCreateManyWinningsInputEnvelope
    connect?: auditWhereUniqueInput | auditWhereUniqueInput[]
  }

  export type paymentCreateNestedManyWithoutWinningsInput = {
    create?: XOR<paymentCreateWithoutWinningsInput, paymentUncheckedCreateWithoutWinningsInput> | paymentCreateWithoutWinningsInput[] | paymentUncheckedCreateWithoutWinningsInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutWinningsInput | paymentCreateOrConnectWithoutWinningsInput[]
    createMany?: paymentCreateManyWinningsInputEnvelope
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
  }

  export type originCreateNestedOneWithoutWinningsInput = {
    create?: XOR<originCreateWithoutWinningsInput, originUncheckedCreateWithoutWinningsInput>
    connectOrCreate?: originCreateOrConnectWithoutWinningsInput
    connect?: originWhereUniqueInput
  }

  export type auditUncheckedCreateNestedManyWithoutWinningsInput = {
    create?: XOR<auditCreateWithoutWinningsInput, auditUncheckedCreateWithoutWinningsInput> | auditCreateWithoutWinningsInput[] | auditUncheckedCreateWithoutWinningsInput[]
    connectOrCreate?: auditCreateOrConnectWithoutWinningsInput | auditCreateOrConnectWithoutWinningsInput[]
    createMany?: auditCreateManyWinningsInputEnvelope
    connect?: auditWhereUniqueInput | auditWhereUniqueInput[]
  }

  export type paymentUncheckedCreateNestedManyWithoutWinningsInput = {
    create?: XOR<paymentCreateWithoutWinningsInput, paymentUncheckedCreateWithoutWinningsInput> | paymentCreateWithoutWinningsInput[] | paymentUncheckedCreateWithoutWinningsInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutWinningsInput | paymentCreateOrConnectWithoutWinningsInput[]
    createMany?: paymentCreateManyWinningsInputEnvelope
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
  }

  export type Enumwinnings_typeFieldUpdateOperationsInput = {
    set?: $Enums.winnings_type
  }

  export type NullableEnumwinnings_categoryFieldUpdateOperationsInput = {
    set?: $Enums.winnings_category | null
  }

  export type auditUpdateManyWithoutWinningsNestedInput = {
    create?: XOR<auditCreateWithoutWinningsInput, auditUncheckedCreateWithoutWinningsInput> | auditCreateWithoutWinningsInput[] | auditUncheckedCreateWithoutWinningsInput[]
    connectOrCreate?: auditCreateOrConnectWithoutWinningsInput | auditCreateOrConnectWithoutWinningsInput[]
    upsert?: auditUpsertWithWhereUniqueWithoutWinningsInput | auditUpsertWithWhereUniqueWithoutWinningsInput[]
    createMany?: auditCreateManyWinningsInputEnvelope
    set?: auditWhereUniqueInput | auditWhereUniqueInput[]
    disconnect?: auditWhereUniqueInput | auditWhereUniqueInput[]
    delete?: auditWhereUniqueInput | auditWhereUniqueInput[]
    connect?: auditWhereUniqueInput | auditWhereUniqueInput[]
    update?: auditUpdateWithWhereUniqueWithoutWinningsInput | auditUpdateWithWhereUniqueWithoutWinningsInput[]
    updateMany?: auditUpdateManyWithWhereWithoutWinningsInput | auditUpdateManyWithWhereWithoutWinningsInput[]
    deleteMany?: auditScalarWhereInput | auditScalarWhereInput[]
  }

  export type paymentUpdateManyWithoutWinningsNestedInput = {
    create?: XOR<paymentCreateWithoutWinningsInput, paymentUncheckedCreateWithoutWinningsInput> | paymentCreateWithoutWinningsInput[] | paymentUncheckedCreateWithoutWinningsInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutWinningsInput | paymentCreateOrConnectWithoutWinningsInput[]
    upsert?: paymentUpsertWithWhereUniqueWithoutWinningsInput | paymentUpsertWithWhereUniqueWithoutWinningsInput[]
    createMany?: paymentCreateManyWinningsInputEnvelope
    set?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    disconnect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    delete?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    update?: paymentUpdateWithWhereUniqueWithoutWinningsInput | paymentUpdateWithWhereUniqueWithoutWinningsInput[]
    updateMany?: paymentUpdateManyWithWhereWithoutWinningsInput | paymentUpdateManyWithWhereWithoutWinningsInput[]
    deleteMany?: paymentScalarWhereInput | paymentScalarWhereInput[]
  }

  export type originUpdateOneWithoutWinningsNestedInput = {
    create?: XOR<originCreateWithoutWinningsInput, originUncheckedCreateWithoutWinningsInput>
    connectOrCreate?: originCreateOrConnectWithoutWinningsInput
    upsert?: originUpsertWithoutWinningsInput
    disconnect?: originWhereInput | boolean
    delete?: originWhereInput | boolean
    connect?: originWhereUniqueInput
    update?: XOR<XOR<originUpdateToOneWithWhereWithoutWinningsInput, originUpdateWithoutWinningsInput>, originUncheckedUpdateWithoutWinningsInput>
  }

  export type auditUncheckedUpdateManyWithoutWinningsNestedInput = {
    create?: XOR<auditCreateWithoutWinningsInput, auditUncheckedCreateWithoutWinningsInput> | auditCreateWithoutWinningsInput[] | auditUncheckedCreateWithoutWinningsInput[]
    connectOrCreate?: auditCreateOrConnectWithoutWinningsInput | auditCreateOrConnectWithoutWinningsInput[]
    upsert?: auditUpsertWithWhereUniqueWithoutWinningsInput | auditUpsertWithWhereUniqueWithoutWinningsInput[]
    createMany?: auditCreateManyWinningsInputEnvelope
    set?: auditWhereUniqueInput | auditWhereUniqueInput[]
    disconnect?: auditWhereUniqueInput | auditWhereUniqueInput[]
    delete?: auditWhereUniqueInput | auditWhereUniqueInput[]
    connect?: auditWhereUniqueInput | auditWhereUniqueInput[]
    update?: auditUpdateWithWhereUniqueWithoutWinningsInput | auditUpdateWithWhereUniqueWithoutWinningsInput[]
    updateMany?: auditUpdateManyWithWhereWithoutWinningsInput | auditUpdateManyWithWhereWithoutWinningsInput[]
    deleteMany?: auditScalarWhereInput | auditScalarWhereInput[]
  }

  export type paymentUncheckedUpdateManyWithoutWinningsNestedInput = {
    create?: XOR<paymentCreateWithoutWinningsInput, paymentUncheckedCreateWithoutWinningsInput> | paymentCreateWithoutWinningsInput[] | paymentUncheckedCreateWithoutWinningsInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutWinningsInput | paymentCreateOrConnectWithoutWinningsInput[]
    upsert?: paymentUpsertWithWhereUniqueWithoutWinningsInput | paymentUpsertWithWhereUniqueWithoutWinningsInput[]
    createMany?: paymentCreateManyWinningsInputEnvelope
    set?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    disconnect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    delete?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    update?: paymentUpdateWithWhereUniqueWithoutWinningsInput | paymentUpdateWithWhereUniqueWithoutWinningsInput[]
    updateMany?: paymentUpdateManyWithWhereWithoutWinningsInput | paymentUpdateManyWithWhereWithoutWinningsInput[]
    deleteMany?: paymentScalarWhereInput | paymentScalarWhereInput[]
  }

  export type trolley_recipient_payment_methodCreateNestedManyWithoutTrolley_recipientInput = {
    create?: XOR<trolley_recipient_payment_methodCreateWithoutTrolley_recipientInput, trolley_recipient_payment_methodUncheckedCreateWithoutTrolley_recipientInput> | trolley_recipient_payment_methodCreateWithoutTrolley_recipientInput[] | trolley_recipient_payment_methodUncheckedCreateWithoutTrolley_recipientInput[]
    connectOrCreate?: trolley_recipient_payment_methodCreateOrConnectWithoutTrolley_recipientInput | trolley_recipient_payment_methodCreateOrConnectWithoutTrolley_recipientInput[]
    createMany?: trolley_recipient_payment_methodCreateManyTrolley_recipientInputEnvelope
    connect?: trolley_recipient_payment_methodWhereUniqueInput | trolley_recipient_payment_methodWhereUniqueInput[]
  }

  export type user_payment_methodsCreateNestedOneWithoutTrolley_payment_methodInput = {
    create?: XOR<user_payment_methodsCreateWithoutTrolley_payment_methodInput, user_payment_methodsUncheckedCreateWithoutTrolley_payment_methodInput>
    connectOrCreate?: user_payment_methodsCreateOrConnectWithoutTrolley_payment_methodInput
    connect?: user_payment_methodsWhereUniqueInput
  }

  export type trolley_recipient_payment_methodUncheckedCreateNestedManyWithoutTrolley_recipientInput = {
    create?: XOR<trolley_recipient_payment_methodCreateWithoutTrolley_recipientInput, trolley_recipient_payment_methodUncheckedCreateWithoutTrolley_recipientInput> | trolley_recipient_payment_methodCreateWithoutTrolley_recipientInput[] | trolley_recipient_payment_methodUncheckedCreateWithoutTrolley_recipientInput[]
    connectOrCreate?: trolley_recipient_payment_methodCreateOrConnectWithoutTrolley_recipientInput | trolley_recipient_payment_methodCreateOrConnectWithoutTrolley_recipientInput[]
    createMany?: trolley_recipient_payment_methodCreateManyTrolley_recipientInputEnvelope
    connect?: trolley_recipient_payment_methodWhereUniqueInput | trolley_recipient_payment_methodWhereUniqueInput[]
  }

  export type trolley_recipient_payment_methodUpdateManyWithoutTrolley_recipientNestedInput = {
    create?: XOR<trolley_recipient_payment_methodCreateWithoutTrolley_recipientInput, trolley_recipient_payment_methodUncheckedCreateWithoutTrolley_recipientInput> | trolley_recipient_payment_methodCreateWithoutTrolley_recipientInput[] | trolley_recipient_payment_methodUncheckedCreateWithoutTrolley_recipientInput[]
    connectOrCreate?: trolley_recipient_payment_methodCreateOrConnectWithoutTrolley_recipientInput | trolley_recipient_payment_methodCreateOrConnectWithoutTrolley_recipientInput[]
    upsert?: trolley_recipient_payment_methodUpsertWithWhereUniqueWithoutTrolley_recipientInput | trolley_recipient_payment_methodUpsertWithWhereUniqueWithoutTrolley_recipientInput[]
    createMany?: trolley_recipient_payment_methodCreateManyTrolley_recipientInputEnvelope
    set?: trolley_recipient_payment_methodWhereUniqueInput | trolley_recipient_payment_methodWhereUniqueInput[]
    disconnect?: trolley_recipient_payment_methodWhereUniqueInput | trolley_recipient_payment_methodWhereUniqueInput[]
    delete?: trolley_recipient_payment_methodWhereUniqueInput | trolley_recipient_payment_methodWhereUniqueInput[]
    connect?: trolley_recipient_payment_methodWhereUniqueInput | trolley_recipient_payment_methodWhereUniqueInput[]
    update?: trolley_recipient_payment_methodUpdateWithWhereUniqueWithoutTrolley_recipientInput | trolley_recipient_payment_methodUpdateWithWhereUniqueWithoutTrolley_recipientInput[]
    updateMany?: trolley_recipient_payment_methodUpdateManyWithWhereWithoutTrolley_recipientInput | trolley_recipient_payment_methodUpdateManyWithWhereWithoutTrolley_recipientInput[]
    deleteMany?: trolley_recipient_payment_methodScalarWhereInput | trolley_recipient_payment_methodScalarWhereInput[]
  }

  export type user_payment_methodsUpdateOneRequiredWithoutTrolley_payment_methodNestedInput = {
    create?: XOR<user_payment_methodsCreateWithoutTrolley_payment_methodInput, user_payment_methodsUncheckedCreateWithoutTrolley_payment_methodInput>
    connectOrCreate?: user_payment_methodsCreateOrConnectWithoutTrolley_payment_methodInput
    upsert?: user_payment_methodsUpsertWithoutTrolley_payment_methodInput
    connect?: user_payment_methodsWhereUniqueInput
    update?: XOR<XOR<user_payment_methodsUpdateToOneWithWhereWithoutTrolley_payment_methodInput, user_payment_methodsUpdateWithoutTrolley_payment_methodInput>, user_payment_methodsUncheckedUpdateWithoutTrolley_payment_methodInput>
  }

  export type trolley_recipient_payment_methodUncheckedUpdateManyWithoutTrolley_recipientNestedInput = {
    create?: XOR<trolley_recipient_payment_methodCreateWithoutTrolley_recipientInput, trolley_recipient_payment_methodUncheckedCreateWithoutTrolley_recipientInput> | trolley_recipient_payment_methodCreateWithoutTrolley_recipientInput[] | trolley_recipient_payment_methodUncheckedCreateWithoutTrolley_recipientInput[]
    connectOrCreate?: trolley_recipient_payment_methodCreateOrConnectWithoutTrolley_recipientInput | trolley_recipient_payment_methodCreateOrConnectWithoutTrolley_recipientInput[]
    upsert?: trolley_recipient_payment_methodUpsertWithWhereUniqueWithoutTrolley_recipientInput | trolley_recipient_payment_methodUpsertWithWhereUniqueWithoutTrolley_recipientInput[]
    createMany?: trolley_recipient_payment_methodCreateManyTrolley_recipientInputEnvelope
    set?: trolley_recipient_payment_methodWhereUniqueInput | trolley_recipient_payment_methodWhereUniqueInput[]
    disconnect?: trolley_recipient_payment_methodWhereUniqueInput | trolley_recipient_payment_methodWhereUniqueInput[]
    delete?: trolley_recipient_payment_methodWhereUniqueInput | trolley_recipient_payment_methodWhereUniqueInput[]
    connect?: trolley_recipient_payment_methodWhereUniqueInput | trolley_recipient_payment_methodWhereUniqueInput[]
    update?: trolley_recipient_payment_methodUpdateWithWhereUniqueWithoutTrolley_recipientInput | trolley_recipient_payment_methodUpdateWithWhereUniqueWithoutTrolley_recipientInput[]
    updateMany?: trolley_recipient_payment_methodUpdateManyWithWhereWithoutTrolley_recipientInput | trolley_recipient_payment_methodUpdateManyWithWhereWithoutTrolley_recipientInput[]
    deleteMany?: trolley_recipient_payment_methodScalarWhereInput | trolley_recipient_payment_methodScalarWhereInput[]
  }

  export type Enumwebhook_statusFieldUpdateOperationsInput = {
    set?: $Enums.webhook_status
  }

  export type Enumverification_statusFieldUpdateOperationsInput = {
    set?: $Enums.verification_status
  }

  export type trolley_recipientCreateNestedOneWithoutTrolley_recipient_payment_methodsInput = {
    create?: XOR<trolley_recipientCreateWithoutTrolley_recipient_payment_methodsInput, trolley_recipientUncheckedCreateWithoutTrolley_recipient_payment_methodsInput>
    connectOrCreate?: trolley_recipientCreateOrConnectWithoutTrolley_recipient_payment_methodsInput
    connect?: trolley_recipientWhereUniqueInput
  }

  export type trolley_recipientUpdateOneRequiredWithoutTrolley_recipient_payment_methodsNestedInput = {
    create?: XOR<trolley_recipientCreateWithoutTrolley_recipient_payment_methodsInput, trolley_recipientUncheckedCreateWithoutTrolley_recipient_payment_methodsInput>
    connectOrCreate?: trolley_recipientCreateOrConnectWithoutTrolley_recipient_payment_methodsInput
    upsert?: trolley_recipientUpsertWithoutTrolley_recipient_payment_methodsInput
    connect?: trolley_recipientWhereUniqueInput
    update?: XOR<XOR<trolley_recipientUpdateToOneWithWhereWithoutTrolley_recipient_payment_methodsInput, trolley_recipientUpdateWithoutTrolley_recipient_payment_methodsInput>, trolley_recipientUncheckedUpdateWithoutTrolley_recipient_payment_methodsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumreference_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.reference_type | Enumreference_typeFieldRefInput<$PrismaModel>
    in?: $Enums.reference_type[] | ListEnumreference_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.reference_type[] | ListEnumreference_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumreference_typeFilter<$PrismaModel> | $Enums.reference_type
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumreference_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.reference_type | Enumreference_typeFieldRefInput<$PrismaModel>
    in?: $Enums.reference_type[] | ListEnumreference_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.reference_type[] | ListEnumreference_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumreference_typeWithAggregatesFilter<$PrismaModel> | $Enums.reference_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumreference_typeFilter<$PrismaModel>
    _max?: NestedEnumreference_typeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumpayment_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_status | Enumpayment_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.payment_status[] | ListEnumpayment_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.payment_status[] | ListEnumpayment_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumpayment_statusNullableFilter<$PrismaModel> | $Enums.payment_status | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumpayment_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_status | Enumpayment_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.payment_status[] | ListEnumpayment_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.payment_status[] | ListEnumpayment_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumpayment_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.payment_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumpayment_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumpayment_statusNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumpayment_method_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_method_status | Enumpayment_method_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.payment_method_status[] | ListEnumpayment_method_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.payment_method_status[] | ListEnumpayment_method_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumpayment_method_statusNullableFilter<$PrismaModel> | $Enums.payment_method_status | null
  }

  export type NestedEnumpayment_method_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_method_status | Enumpayment_method_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.payment_method_status[] | ListEnumpayment_method_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.payment_method_status[] | ListEnumpayment_method_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumpayment_method_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.payment_method_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumpayment_method_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumpayment_method_statusNullableFilter<$PrismaModel>
  }

  export type NestedEnumtax_form_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.tax_form_status | Enumtax_form_statusFieldRefInput<$PrismaModel>
    in?: $Enums.tax_form_status[] | ListEnumtax_form_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.tax_form_status[] | ListEnumtax_form_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumtax_form_statusFilter<$PrismaModel> | $Enums.tax_form_status
  }

  export type NestedEnumtax_form_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.tax_form_status | Enumtax_form_statusFieldRefInput<$PrismaModel>
    in?: $Enums.tax_form_status[] | ListEnumtax_form_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.tax_form_status[] | ListEnumtax_form_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumtax_form_statusWithAggregatesFilter<$PrismaModel> | $Enums.tax_form_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtax_form_statusFilter<$PrismaModel>
    _max?: NestedEnumtax_form_statusFilter<$PrismaModel>
  }

  export type NestedEnumwinnings_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.winnings_type | Enumwinnings_typeFieldRefInput<$PrismaModel>
    in?: $Enums.winnings_type[] | ListEnumwinnings_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.winnings_type[] | ListEnumwinnings_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumwinnings_typeFilter<$PrismaModel> | $Enums.winnings_type
  }

  export type NestedEnumwinnings_categoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.winnings_category | Enumwinnings_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.winnings_category[] | ListEnumwinnings_categoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.winnings_category[] | ListEnumwinnings_categoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumwinnings_categoryNullableFilter<$PrismaModel> | $Enums.winnings_category | null
  }

  export type NestedEnumwinnings_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.winnings_type | Enumwinnings_typeFieldRefInput<$PrismaModel>
    in?: $Enums.winnings_type[] | ListEnumwinnings_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.winnings_type[] | ListEnumwinnings_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumwinnings_typeWithAggregatesFilter<$PrismaModel> | $Enums.winnings_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumwinnings_typeFilter<$PrismaModel>
    _max?: NestedEnumwinnings_typeFilter<$PrismaModel>
  }

  export type NestedEnumwinnings_categoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.winnings_category | Enumwinnings_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.winnings_category[] | ListEnumwinnings_categoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.winnings_category[] | ListEnumwinnings_categoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumwinnings_categoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.winnings_category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumwinnings_categoryNullableFilter<$PrismaModel>
    _max?: NestedEnumwinnings_categoryNullableFilter<$PrismaModel>
  }

  export type NestedEnumwebhook_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.webhook_status | Enumwebhook_statusFieldRefInput<$PrismaModel>
    in?: $Enums.webhook_status[] | ListEnumwebhook_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.webhook_status[] | ListEnumwebhook_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumwebhook_statusFilter<$PrismaModel> | $Enums.webhook_status
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumwebhook_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.webhook_status | Enumwebhook_statusFieldRefInput<$PrismaModel>
    in?: $Enums.webhook_status[] | ListEnumwebhook_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.webhook_status[] | ListEnumwebhook_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumwebhook_statusWithAggregatesFilter<$PrismaModel> | $Enums.webhook_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumwebhook_statusFilter<$PrismaModel>
    _max?: NestedEnumwebhook_statusFilter<$PrismaModel>
  }

  export type NestedEnumverification_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.verification_status | Enumverification_statusFieldRefInput<$PrismaModel>
    in?: $Enums.verification_status[] | ListEnumverification_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.verification_status[] | ListEnumverification_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumverification_statusFilter<$PrismaModel> | $Enums.verification_status
  }

  export type NestedEnumverification_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.verification_status | Enumverification_statusFieldRefInput<$PrismaModel>
    in?: $Enums.verification_status[] | ListEnumverification_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.verification_status[] | ListEnumverification_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumverification_statusWithAggregatesFilter<$PrismaModel> | $Enums.verification_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumverification_statusFilter<$PrismaModel>
    _max?: NestedEnumverification_statusFilter<$PrismaModel>
  }

  export type winningsCreateWithoutAuditInput = {
    winning_id?: string
    winner_id: string
    type: $Enums.winnings_type
    category?: $Enums.winnings_category | null
    title?: string | null
    description?: string | null
    external_id?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    created_by: string
    updated_by?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    payment?: paymentCreateNestedManyWithoutWinningsInput
    origin?: originCreateNestedOneWithoutWinningsInput
  }

  export type winningsUncheckedCreateWithoutAuditInput = {
    winning_id?: string
    winner_id: string
    type: $Enums.winnings_type
    origin_id?: number | null
    category?: $Enums.winnings_category | null
    title?: string | null
    description?: string | null
    external_id?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    created_by: string
    updated_by?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    payment?: paymentUncheckedCreateNestedManyWithoutWinningsInput
  }

  export type winningsCreateOrConnectWithoutAuditInput = {
    where: winningsWhereUniqueInput
    create: XOR<winningsCreateWithoutAuditInput, winningsUncheckedCreateWithoutAuditInput>
  }

  export type winningsUpsertWithoutAuditInput = {
    update: XOR<winningsUpdateWithoutAuditInput, winningsUncheckedUpdateWithoutAuditInput>
    create: XOR<winningsCreateWithoutAuditInput, winningsUncheckedCreateWithoutAuditInput>
    where?: winningsWhereInput
  }

  export type winningsUpdateToOneWithWhereWithoutAuditInput = {
    where?: winningsWhereInput
    data: XOR<winningsUpdateWithoutAuditInput, winningsUncheckedUpdateWithoutAuditInput>
  }

  export type winningsUpdateWithoutAuditInput = {
    winning_id?: StringFieldUpdateOperationsInput | string
    winner_id?: StringFieldUpdateOperationsInput | string
    type?: Enumwinnings_typeFieldUpdateOperationsInput | $Enums.winnings_type
    category?: NullableEnumwinnings_categoryFieldUpdateOperationsInput | $Enums.winnings_category | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: paymentUpdateManyWithoutWinningsNestedInput
    origin?: originUpdateOneWithoutWinningsNestedInput
  }

  export type winningsUncheckedUpdateWithoutAuditInput = {
    winning_id?: StringFieldUpdateOperationsInput | string
    winner_id?: StringFieldUpdateOperationsInput | string
    type?: Enumwinnings_typeFieldUpdateOperationsInput | $Enums.winnings_type
    origin_id?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumwinnings_categoryFieldUpdateOperationsInput | $Enums.winnings_category | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: paymentUncheckedUpdateManyWithoutWinningsNestedInput
  }

  export type winningsCreateWithoutOriginInput = {
    winning_id?: string
    winner_id: string
    type: $Enums.winnings_type
    category?: $Enums.winnings_category | null
    title?: string | null
    description?: string | null
    external_id?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    created_by: string
    updated_by?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    audit?: auditCreateNestedManyWithoutWinningsInput
    payment?: paymentCreateNestedManyWithoutWinningsInput
  }

  export type winningsUncheckedCreateWithoutOriginInput = {
    winning_id?: string
    winner_id: string
    type: $Enums.winnings_type
    category?: $Enums.winnings_category | null
    title?: string | null
    description?: string | null
    external_id?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    created_by: string
    updated_by?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    audit?: auditUncheckedCreateNestedManyWithoutWinningsInput
    payment?: paymentUncheckedCreateNestedManyWithoutWinningsInput
  }

  export type winningsCreateOrConnectWithoutOriginInput = {
    where: winningsWhereUniqueInput
    create: XOR<winningsCreateWithoutOriginInput, winningsUncheckedCreateWithoutOriginInput>
  }

  export type winningsCreateManyOriginInputEnvelope = {
    data: winningsCreateManyOriginInput | winningsCreateManyOriginInput[]
    skipDuplicates?: boolean
  }

  export type winningsUpsertWithWhereUniqueWithoutOriginInput = {
    where: winningsWhereUniqueInput
    update: XOR<winningsUpdateWithoutOriginInput, winningsUncheckedUpdateWithoutOriginInput>
    create: XOR<winningsCreateWithoutOriginInput, winningsUncheckedCreateWithoutOriginInput>
  }

  export type winningsUpdateWithWhereUniqueWithoutOriginInput = {
    where: winningsWhereUniqueInput
    data: XOR<winningsUpdateWithoutOriginInput, winningsUncheckedUpdateWithoutOriginInput>
  }

  export type winningsUpdateManyWithWhereWithoutOriginInput = {
    where: winningsScalarWhereInput
    data: XOR<winningsUpdateManyMutationInput, winningsUncheckedUpdateManyWithoutOriginInput>
  }

  export type winningsScalarWhereInput = {
    AND?: winningsScalarWhereInput | winningsScalarWhereInput[]
    OR?: winningsScalarWhereInput[]
    NOT?: winningsScalarWhereInput | winningsScalarWhereInput[]
    winning_id?: UuidFilter<"winnings"> | string
    winner_id?: StringFilter<"winnings"> | string
    type?: Enumwinnings_typeFilter<"winnings"> | $Enums.winnings_type
    origin_id?: IntNullableFilter<"winnings"> | number | null
    category?: Enumwinnings_categoryNullableFilter<"winnings"> | $Enums.winnings_category | null
    title?: StringNullableFilter<"winnings"> | string | null
    description?: StringNullableFilter<"winnings"> | string | null
    external_id?: StringNullableFilter<"winnings"> | string | null
    attributes?: JsonNullableFilter<"winnings">
    created_by?: StringFilter<"winnings"> | string
    updated_by?: StringNullableFilter<"winnings"> | string | null
    created_at?: DateTimeNullableFilter<"winnings"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"winnings"> | Date | string | null
  }

  export type payment_methodCreateWithoutPaymentInput = {
    payment_method_type: string
    name: string
    description?: string | null
    payment_releases?: payment_releasesCreateNestedManyWithoutPayment_methodInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutPayment_methodInput
  }

  export type payment_methodUncheckedCreateWithoutPaymentInput = {
    payment_method_id?: number
    payment_method_type: string
    name: string
    description?: string | null
    payment_releases?: payment_releasesUncheckedCreateNestedManyWithoutPayment_methodInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutPayment_methodInput
  }

  export type payment_methodCreateOrConnectWithoutPaymentInput = {
    where: payment_methodWhereUniqueInput
    create: XOR<payment_methodCreateWithoutPaymentInput, payment_methodUncheckedCreateWithoutPaymentInput>
  }

  export type winningsCreateWithoutPaymentInput = {
    winning_id?: string
    winner_id: string
    type: $Enums.winnings_type
    category?: $Enums.winnings_category | null
    title?: string | null
    description?: string | null
    external_id?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    created_by: string
    updated_by?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    audit?: auditCreateNestedManyWithoutWinningsInput
    origin?: originCreateNestedOneWithoutWinningsInput
  }

  export type winningsUncheckedCreateWithoutPaymentInput = {
    winning_id?: string
    winner_id: string
    type: $Enums.winnings_type
    origin_id?: number | null
    category?: $Enums.winnings_category | null
    title?: string | null
    description?: string | null
    external_id?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    created_by: string
    updated_by?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    audit?: auditUncheckedCreateNestedManyWithoutWinningsInput
  }

  export type winningsCreateOrConnectWithoutPaymentInput = {
    where: winningsWhereUniqueInput
    create: XOR<winningsCreateWithoutPaymentInput, winningsUncheckedCreateWithoutPaymentInput>
  }

  export type payment_release_associationsCreateWithoutPaymentInput = {
    payment_releases: payment_releasesCreateNestedOneWithoutPayment_release_associationsInput
  }

  export type payment_release_associationsUncheckedCreateWithoutPaymentInput = {
    payment_release_id: string
  }

  export type payment_release_associationsCreateOrConnectWithoutPaymentInput = {
    where: payment_release_associationsWhereUniqueInput
    create: XOR<payment_release_associationsCreateWithoutPaymentInput, payment_release_associationsUncheckedCreateWithoutPaymentInput>
  }

  export type payment_release_associationsCreateManyPaymentInputEnvelope = {
    data: payment_release_associationsCreateManyPaymentInput | payment_release_associationsCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type payment_methodUpsertWithoutPaymentInput = {
    update: XOR<payment_methodUpdateWithoutPaymentInput, payment_methodUncheckedUpdateWithoutPaymentInput>
    create: XOR<payment_methodCreateWithoutPaymentInput, payment_methodUncheckedCreateWithoutPaymentInput>
    where?: payment_methodWhereInput
  }

  export type payment_methodUpdateToOneWithWhereWithoutPaymentInput = {
    where?: payment_methodWhereInput
    data: XOR<payment_methodUpdateWithoutPaymentInput, payment_methodUncheckedUpdateWithoutPaymentInput>
  }

  export type payment_methodUpdateWithoutPaymentInput = {
    payment_method_type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payment_releases?: payment_releasesUpdateManyWithoutPayment_methodNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutPayment_methodNestedInput
  }

  export type payment_methodUncheckedUpdateWithoutPaymentInput = {
    payment_method_id?: IntFieldUpdateOperationsInput | number
    payment_method_type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payment_releases?: payment_releasesUncheckedUpdateManyWithoutPayment_methodNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutPayment_methodNestedInput
  }

  export type winningsUpsertWithoutPaymentInput = {
    update: XOR<winningsUpdateWithoutPaymentInput, winningsUncheckedUpdateWithoutPaymentInput>
    create: XOR<winningsCreateWithoutPaymentInput, winningsUncheckedCreateWithoutPaymentInput>
    where?: winningsWhereInput
  }

  export type winningsUpdateToOneWithWhereWithoutPaymentInput = {
    where?: winningsWhereInput
    data: XOR<winningsUpdateWithoutPaymentInput, winningsUncheckedUpdateWithoutPaymentInput>
  }

  export type winningsUpdateWithoutPaymentInput = {
    winning_id?: StringFieldUpdateOperationsInput | string
    winner_id?: StringFieldUpdateOperationsInput | string
    type?: Enumwinnings_typeFieldUpdateOperationsInput | $Enums.winnings_type
    category?: NullableEnumwinnings_categoryFieldUpdateOperationsInput | $Enums.winnings_category | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audit?: auditUpdateManyWithoutWinningsNestedInput
    origin?: originUpdateOneWithoutWinningsNestedInput
  }

  export type winningsUncheckedUpdateWithoutPaymentInput = {
    winning_id?: StringFieldUpdateOperationsInput | string
    winner_id?: StringFieldUpdateOperationsInput | string
    type?: Enumwinnings_typeFieldUpdateOperationsInput | $Enums.winnings_type
    origin_id?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumwinnings_categoryFieldUpdateOperationsInput | $Enums.winnings_category | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audit?: auditUncheckedUpdateManyWithoutWinningsNestedInput
  }

  export type payment_release_associationsUpsertWithWhereUniqueWithoutPaymentInput = {
    where: payment_release_associationsWhereUniqueInput
    update: XOR<payment_release_associationsUpdateWithoutPaymentInput, payment_release_associationsUncheckedUpdateWithoutPaymentInput>
    create: XOR<payment_release_associationsCreateWithoutPaymentInput, payment_release_associationsUncheckedCreateWithoutPaymentInput>
  }

  export type payment_release_associationsUpdateWithWhereUniqueWithoutPaymentInput = {
    where: payment_release_associationsWhereUniqueInput
    data: XOR<payment_release_associationsUpdateWithoutPaymentInput, payment_release_associationsUncheckedUpdateWithoutPaymentInput>
  }

  export type payment_release_associationsUpdateManyWithWhereWithoutPaymentInput = {
    where: payment_release_associationsScalarWhereInput
    data: XOR<payment_release_associationsUpdateManyMutationInput, payment_release_associationsUncheckedUpdateManyWithoutPaymentInput>
  }

  export type payment_release_associationsScalarWhereInput = {
    AND?: payment_release_associationsScalarWhereInput | payment_release_associationsScalarWhereInput[]
    OR?: payment_release_associationsScalarWhereInput[]
    NOT?: payment_release_associationsScalarWhereInput | payment_release_associationsScalarWhereInput[]
    payment_release_id?: UuidFilter<"payment_release_associations"> | string
    payment_id?: UuidFilter<"payment_release_associations"> | string
  }

  export type paymentCreateWithoutPayment_methodInput = {
    payment_id?: string
    net_amount?: Decimal | DecimalJsLike | number | string | null
    gross_amount?: Decimal | DecimalJsLike | number | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    installment_number?: number | null
    date_paid?: Date | string | null
    currency?: string | null
    created_by: string
    updated_by?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    version?: number | null
    release_date?: Date | string | null
    payment_status?: $Enums.payment_status | null
    billing_account: string
    challenge_markup?: Decimal | DecimalJsLike | number | string | null
    challenge_fee?: Decimal | DecimalJsLike | number | string | null
    winnings: winningsCreateNestedOneWithoutPaymentInput
    payment_release_associations?: payment_release_associationsCreateNestedManyWithoutPaymentInput
  }

  export type paymentUncheckedCreateWithoutPayment_methodInput = {
    payment_id?: string
    winnings_id: string
    net_amount?: Decimal | DecimalJsLike | number | string | null
    gross_amount?: Decimal | DecimalJsLike | number | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    installment_number?: number | null
    date_paid?: Date | string | null
    currency?: string | null
    created_by: string
    updated_by?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    version?: number | null
    release_date?: Date | string | null
    payment_status?: $Enums.payment_status | null
    billing_account: string
    challenge_markup?: Decimal | DecimalJsLike | number | string | null
    challenge_fee?: Decimal | DecimalJsLike | number | string | null
    payment_release_associations?: payment_release_associationsUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type paymentCreateOrConnectWithoutPayment_methodInput = {
    where: paymentWhereUniqueInput
    create: XOR<paymentCreateWithoutPayment_methodInput, paymentUncheckedCreateWithoutPayment_methodInput>
  }

  export type paymentCreateManyPayment_methodInputEnvelope = {
    data: paymentCreateManyPayment_methodInput | paymentCreateManyPayment_methodInput[]
    skipDuplicates?: boolean
  }

  export type payment_releasesCreateWithoutPayment_methodInput = {
    payment_release_id?: string
    user_id: string
    total_net_amount: Decimal | DecimalJsLike | number | string
    status?: string | null
    external_transaction_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    payee_id?: string | null
    release_date?: Date | string | null
    batch_id?: string | null
    payment_release_associations?: payment_release_associationsCreateNestedManyWithoutPayment_releasesInput
  }

  export type payment_releasesUncheckedCreateWithoutPayment_methodInput = {
    payment_release_id?: string
    user_id: string
    total_net_amount: Decimal | DecimalJsLike | number | string
    status?: string | null
    external_transaction_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    payee_id?: string | null
    release_date?: Date | string | null
    batch_id?: string | null
    payment_release_associations?: payment_release_associationsUncheckedCreateNestedManyWithoutPayment_releasesInput
  }

  export type payment_releasesCreateOrConnectWithoutPayment_methodInput = {
    where: payment_releasesWhereUniqueInput
    create: XOR<payment_releasesCreateWithoutPayment_methodInput, payment_releasesUncheckedCreateWithoutPayment_methodInput>
  }

  export type payment_releasesCreateManyPayment_methodInputEnvelope = {
    data: payment_releasesCreateManyPayment_methodInput | payment_releasesCreateManyPayment_methodInput[]
    skipDuplicates?: boolean
  }

  export type user_payment_methodsCreateWithoutPayment_methodInput = {
    id?: string
    user_id: string
    status?: $Enums.payment_method_status | null
    trolley_payment_method?: trolley_recipientCreateNestedManyWithoutUser_payment_methodsInput
  }

  export type user_payment_methodsUncheckedCreateWithoutPayment_methodInput = {
    id?: string
    user_id: string
    status?: $Enums.payment_method_status | null
    trolley_payment_method?: trolley_recipientUncheckedCreateNestedManyWithoutUser_payment_methodsInput
  }

  export type user_payment_methodsCreateOrConnectWithoutPayment_methodInput = {
    where: user_payment_methodsWhereUniqueInput
    create: XOR<user_payment_methodsCreateWithoutPayment_methodInput, user_payment_methodsUncheckedCreateWithoutPayment_methodInput>
  }

  export type user_payment_methodsCreateManyPayment_methodInputEnvelope = {
    data: user_payment_methodsCreateManyPayment_methodInput | user_payment_methodsCreateManyPayment_methodInput[]
    skipDuplicates?: boolean
  }

  export type paymentUpsertWithWhereUniqueWithoutPayment_methodInput = {
    where: paymentWhereUniqueInput
    update: XOR<paymentUpdateWithoutPayment_methodInput, paymentUncheckedUpdateWithoutPayment_methodInput>
    create: XOR<paymentCreateWithoutPayment_methodInput, paymentUncheckedCreateWithoutPayment_methodInput>
  }

  export type paymentUpdateWithWhereUniqueWithoutPayment_methodInput = {
    where: paymentWhereUniqueInput
    data: XOR<paymentUpdateWithoutPayment_methodInput, paymentUncheckedUpdateWithoutPayment_methodInput>
  }

  export type paymentUpdateManyWithWhereWithoutPayment_methodInput = {
    where: paymentScalarWhereInput
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyWithoutPayment_methodInput>
  }

  export type paymentScalarWhereInput = {
    AND?: paymentScalarWhereInput | paymentScalarWhereInput[]
    OR?: paymentScalarWhereInput[]
    NOT?: paymentScalarWhereInput | paymentScalarWhereInput[]
    payment_id?: UuidFilter<"payment"> | string
    winnings_id?: UuidFilter<"payment"> | string
    net_amount?: DecimalNullableFilter<"payment"> | Decimal | DecimalJsLike | number | string | null
    gross_amount?: DecimalNullableFilter<"payment"> | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalNullableFilter<"payment"> | Decimal | DecimalJsLike | number | string | null
    installment_number?: IntNullableFilter<"payment"> | number | null
    date_paid?: DateTimeNullableFilter<"payment"> | Date | string | null
    payment_method_id?: IntNullableFilter<"payment"> | number | null
    currency?: StringNullableFilter<"payment"> | string | null
    created_by?: StringFilter<"payment"> | string
    updated_by?: StringNullableFilter<"payment"> | string | null
    created_at?: DateTimeNullableFilter<"payment"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"payment"> | Date | string | null
    version?: IntNullableFilter<"payment"> | number | null
    release_date?: DateTimeNullableFilter<"payment"> | Date | string | null
    payment_status?: Enumpayment_statusNullableFilter<"payment"> | $Enums.payment_status | null
    billing_account?: StringFilter<"payment"> | string
    challenge_markup?: DecimalNullableFilter<"payment"> | Decimal | DecimalJsLike | number | string | null
    challenge_fee?: DecimalNullableFilter<"payment"> | Decimal | DecimalJsLike | number | string | null
  }

  export type payment_releasesUpsertWithWhereUniqueWithoutPayment_methodInput = {
    where: payment_releasesWhereUniqueInput
    update: XOR<payment_releasesUpdateWithoutPayment_methodInput, payment_releasesUncheckedUpdateWithoutPayment_methodInput>
    create: XOR<payment_releasesCreateWithoutPayment_methodInput, payment_releasesUncheckedCreateWithoutPayment_methodInput>
  }

  export type payment_releasesUpdateWithWhereUniqueWithoutPayment_methodInput = {
    where: payment_releasesWhereUniqueInput
    data: XOR<payment_releasesUpdateWithoutPayment_methodInput, payment_releasesUncheckedUpdateWithoutPayment_methodInput>
  }

  export type payment_releasesUpdateManyWithWhereWithoutPayment_methodInput = {
    where: payment_releasesScalarWhereInput
    data: XOR<payment_releasesUpdateManyMutationInput, payment_releasesUncheckedUpdateManyWithoutPayment_methodInput>
  }

  export type payment_releasesScalarWhereInput = {
    AND?: payment_releasesScalarWhereInput | payment_releasesScalarWhereInput[]
    OR?: payment_releasesScalarWhereInput[]
    NOT?: payment_releasesScalarWhereInput | payment_releasesScalarWhereInput[]
    payment_release_id?: UuidFilter<"payment_releases"> | string
    user_id?: StringFilter<"payment_releases"> | string
    total_net_amount?: DecimalFilter<"payment_releases"> | Decimal | DecimalJsLike | number | string
    payment_method_id?: IntFilter<"payment_releases"> | number
    status?: StringNullableFilter<"payment_releases"> | string | null
    external_transaction_id?: StringNullableFilter<"payment_releases"> | string | null
    metadata?: JsonNullableFilter<"payment_releases">
    created_at?: DateTimeNullableFilter<"payment_releases"> | Date | string | null
    payee_id?: StringNullableFilter<"payment_releases"> | string | null
    release_date?: DateTimeNullableFilter<"payment_releases"> | Date | string | null
    batch_id?: UuidNullableFilter<"payment_releases"> | string | null
  }

  export type user_payment_methodsUpsertWithWhereUniqueWithoutPayment_methodInput = {
    where: user_payment_methodsWhereUniqueInput
    update: XOR<user_payment_methodsUpdateWithoutPayment_methodInput, user_payment_methodsUncheckedUpdateWithoutPayment_methodInput>
    create: XOR<user_payment_methodsCreateWithoutPayment_methodInput, user_payment_methodsUncheckedCreateWithoutPayment_methodInput>
  }

  export type user_payment_methodsUpdateWithWhereUniqueWithoutPayment_methodInput = {
    where: user_payment_methodsWhereUniqueInput
    data: XOR<user_payment_methodsUpdateWithoutPayment_methodInput, user_payment_methodsUncheckedUpdateWithoutPayment_methodInput>
  }

  export type user_payment_methodsUpdateManyWithWhereWithoutPayment_methodInput = {
    where: user_payment_methodsScalarWhereInput
    data: XOR<user_payment_methodsUpdateManyMutationInput, user_payment_methodsUncheckedUpdateManyWithoutPayment_methodInput>
  }

  export type user_payment_methodsScalarWhereInput = {
    AND?: user_payment_methodsScalarWhereInput | user_payment_methodsScalarWhereInput[]
    OR?: user_payment_methodsScalarWhereInput[]
    NOT?: user_payment_methodsScalarWhereInput | user_payment_methodsScalarWhereInput[]
    id?: UuidFilter<"user_payment_methods"> | string
    user_id?: StringFilter<"user_payment_methods"> | string
    payment_method_id?: IntFilter<"user_payment_methods"> | number
    status?: Enumpayment_method_statusNullableFilter<"user_payment_methods"> | $Enums.payment_method_status | null
  }

  export type paymentCreateWithoutPayment_release_associationsInput = {
    payment_id?: string
    net_amount?: Decimal | DecimalJsLike | number | string | null
    gross_amount?: Decimal | DecimalJsLike | number | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    installment_number?: number | null
    date_paid?: Date | string | null
    currency?: string | null
    created_by: string
    updated_by?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    version?: number | null
    release_date?: Date | string | null
    payment_status?: $Enums.payment_status | null
    billing_account: string
    challenge_markup?: Decimal | DecimalJsLike | number | string | null
    challenge_fee?: Decimal | DecimalJsLike | number | string | null
    payment_method?: payment_methodCreateNestedOneWithoutPaymentInput
    winnings: winningsCreateNestedOneWithoutPaymentInput
  }

  export type paymentUncheckedCreateWithoutPayment_release_associationsInput = {
    payment_id?: string
    winnings_id: string
    net_amount?: Decimal | DecimalJsLike | number | string | null
    gross_amount?: Decimal | DecimalJsLike | number | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    installment_number?: number | null
    date_paid?: Date | string | null
    payment_method_id?: number | null
    currency?: string | null
    created_by: string
    updated_by?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    version?: number | null
    release_date?: Date | string | null
    payment_status?: $Enums.payment_status | null
    billing_account: string
    challenge_markup?: Decimal | DecimalJsLike | number | string | null
    challenge_fee?: Decimal | DecimalJsLike | number | string | null
  }

  export type paymentCreateOrConnectWithoutPayment_release_associationsInput = {
    where: paymentWhereUniqueInput
    create: XOR<paymentCreateWithoutPayment_release_associationsInput, paymentUncheckedCreateWithoutPayment_release_associationsInput>
  }

  export type payment_releasesCreateWithoutPayment_release_associationsInput = {
    payment_release_id?: string
    user_id: string
    total_net_amount: Decimal | DecimalJsLike | number | string
    status?: string | null
    external_transaction_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    payee_id?: string | null
    release_date?: Date | string | null
    batch_id?: string | null
    payment_method: payment_methodCreateNestedOneWithoutPayment_releasesInput
  }

  export type payment_releasesUncheckedCreateWithoutPayment_release_associationsInput = {
    payment_release_id?: string
    user_id: string
    total_net_amount: Decimal | DecimalJsLike | number | string
    payment_method_id: number
    status?: string | null
    external_transaction_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    payee_id?: string | null
    release_date?: Date | string | null
    batch_id?: string | null
  }

  export type payment_releasesCreateOrConnectWithoutPayment_release_associationsInput = {
    where: payment_releasesWhereUniqueInput
    create: XOR<payment_releasesCreateWithoutPayment_release_associationsInput, payment_releasesUncheckedCreateWithoutPayment_release_associationsInput>
  }

  export type paymentUpsertWithoutPayment_release_associationsInput = {
    update: XOR<paymentUpdateWithoutPayment_release_associationsInput, paymentUncheckedUpdateWithoutPayment_release_associationsInput>
    create: XOR<paymentCreateWithoutPayment_release_associationsInput, paymentUncheckedCreateWithoutPayment_release_associationsInput>
    where?: paymentWhereInput
  }

  export type paymentUpdateToOneWithWhereWithoutPayment_release_associationsInput = {
    where?: paymentWhereInput
    data: XOR<paymentUpdateWithoutPayment_release_associationsInput, paymentUncheckedUpdateWithoutPayment_release_associationsInput>
  }

  export type paymentUpdateWithoutPayment_release_associationsInput = {
    payment_id?: StringFieldUpdateOperationsInput | string
    net_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gross_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    installment_number?: NullableIntFieldUpdateOperationsInput | number | null
    date_paid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    billing_account?: StringFieldUpdateOperationsInput | string
    challenge_markup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    challenge_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_method?: payment_methodUpdateOneWithoutPaymentNestedInput
    winnings?: winningsUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type paymentUncheckedUpdateWithoutPayment_release_associationsInput = {
    payment_id?: StringFieldUpdateOperationsInput | string
    winnings_id?: StringFieldUpdateOperationsInput | string
    net_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gross_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    installment_number?: NullableIntFieldUpdateOperationsInput | number | null
    date_paid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_method_id?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    billing_account?: StringFieldUpdateOperationsInput | string
    challenge_markup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    challenge_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type payment_releasesUpsertWithoutPayment_release_associationsInput = {
    update: XOR<payment_releasesUpdateWithoutPayment_release_associationsInput, payment_releasesUncheckedUpdateWithoutPayment_release_associationsInput>
    create: XOR<payment_releasesCreateWithoutPayment_release_associationsInput, payment_releasesUncheckedCreateWithoutPayment_release_associationsInput>
    where?: payment_releasesWhereInput
  }

  export type payment_releasesUpdateToOneWithWhereWithoutPayment_release_associationsInput = {
    where?: payment_releasesWhereInput
    data: XOR<payment_releasesUpdateWithoutPayment_release_associationsInput, payment_releasesUncheckedUpdateWithoutPayment_release_associationsInput>
  }

  export type payment_releasesUpdateWithoutPayment_release_associationsInput = {
    payment_release_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    total_net_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    external_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payee_id?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: payment_methodUpdateOneRequiredWithoutPayment_releasesNestedInput
  }

  export type payment_releasesUncheckedUpdateWithoutPayment_release_associationsInput = {
    payment_release_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    total_net_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    external_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payee_id?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batch_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type payment_release_associationsCreateWithoutPayment_releasesInput = {
    payment: paymentCreateNestedOneWithoutPayment_release_associationsInput
  }

  export type payment_release_associationsUncheckedCreateWithoutPayment_releasesInput = {
    payment_id: string
  }

  export type payment_release_associationsCreateOrConnectWithoutPayment_releasesInput = {
    where: payment_release_associationsWhereUniqueInput
    create: XOR<payment_release_associationsCreateWithoutPayment_releasesInput, payment_release_associationsUncheckedCreateWithoutPayment_releasesInput>
  }

  export type payment_release_associationsCreateManyPayment_releasesInputEnvelope = {
    data: payment_release_associationsCreateManyPayment_releasesInput | payment_release_associationsCreateManyPayment_releasesInput[]
    skipDuplicates?: boolean
  }

  export type payment_methodCreateWithoutPayment_releasesInput = {
    payment_method_type: string
    name: string
    description?: string | null
    payment?: paymentCreateNestedManyWithoutPayment_methodInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutPayment_methodInput
  }

  export type payment_methodUncheckedCreateWithoutPayment_releasesInput = {
    payment_method_id?: number
    payment_method_type: string
    name: string
    description?: string | null
    payment?: paymentUncheckedCreateNestedManyWithoutPayment_methodInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutPayment_methodInput
  }

  export type payment_methodCreateOrConnectWithoutPayment_releasesInput = {
    where: payment_methodWhereUniqueInput
    create: XOR<payment_methodCreateWithoutPayment_releasesInput, payment_methodUncheckedCreateWithoutPayment_releasesInput>
  }

  export type payment_release_associationsUpsertWithWhereUniqueWithoutPayment_releasesInput = {
    where: payment_release_associationsWhereUniqueInput
    update: XOR<payment_release_associationsUpdateWithoutPayment_releasesInput, payment_release_associationsUncheckedUpdateWithoutPayment_releasesInput>
    create: XOR<payment_release_associationsCreateWithoutPayment_releasesInput, payment_release_associationsUncheckedCreateWithoutPayment_releasesInput>
  }

  export type payment_release_associationsUpdateWithWhereUniqueWithoutPayment_releasesInput = {
    where: payment_release_associationsWhereUniqueInput
    data: XOR<payment_release_associationsUpdateWithoutPayment_releasesInput, payment_release_associationsUncheckedUpdateWithoutPayment_releasesInput>
  }

  export type payment_release_associationsUpdateManyWithWhereWithoutPayment_releasesInput = {
    where: payment_release_associationsScalarWhereInput
    data: XOR<payment_release_associationsUpdateManyMutationInput, payment_release_associationsUncheckedUpdateManyWithoutPayment_releasesInput>
  }

  export type payment_methodUpsertWithoutPayment_releasesInput = {
    update: XOR<payment_methodUpdateWithoutPayment_releasesInput, payment_methodUncheckedUpdateWithoutPayment_releasesInput>
    create: XOR<payment_methodCreateWithoutPayment_releasesInput, payment_methodUncheckedCreateWithoutPayment_releasesInput>
    where?: payment_methodWhereInput
  }

  export type payment_methodUpdateToOneWithWhereWithoutPayment_releasesInput = {
    where?: payment_methodWhereInput
    data: XOR<payment_methodUpdateWithoutPayment_releasesInput, payment_methodUncheckedUpdateWithoutPayment_releasesInput>
  }

  export type payment_methodUpdateWithoutPayment_releasesInput = {
    payment_method_type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: paymentUpdateManyWithoutPayment_methodNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutPayment_methodNestedInput
  }

  export type payment_methodUncheckedUpdateWithoutPayment_releasesInput = {
    payment_method_id?: IntFieldUpdateOperationsInput | number
    payment_method_type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: paymentUncheckedUpdateManyWithoutPayment_methodNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutPayment_methodNestedInput
  }

  export type trolley_recipientCreateWithoutUser_payment_methodsInput = {
    user_id: string
    trolley_id: string
    trolley_recipient_payment_methods?: trolley_recipient_payment_methodCreateNestedManyWithoutTrolley_recipientInput
  }

  export type trolley_recipientUncheckedCreateWithoutUser_payment_methodsInput = {
    id?: number
    user_id: string
    trolley_id: string
    trolley_recipient_payment_methods?: trolley_recipient_payment_methodUncheckedCreateNestedManyWithoutTrolley_recipientInput
  }

  export type trolley_recipientCreateOrConnectWithoutUser_payment_methodsInput = {
    where: trolley_recipientWhereUniqueInput
    create: XOR<trolley_recipientCreateWithoutUser_payment_methodsInput, trolley_recipientUncheckedCreateWithoutUser_payment_methodsInput>
  }

  export type trolley_recipientCreateManyUser_payment_methodsInputEnvelope = {
    data: trolley_recipientCreateManyUser_payment_methodsInput | trolley_recipientCreateManyUser_payment_methodsInput[]
    skipDuplicates?: boolean
  }

  export type payment_methodCreateWithoutUser_payment_methodsInput = {
    payment_method_type: string
    name: string
    description?: string | null
    payment?: paymentCreateNestedManyWithoutPayment_methodInput
    payment_releases?: payment_releasesCreateNestedManyWithoutPayment_methodInput
  }

  export type payment_methodUncheckedCreateWithoutUser_payment_methodsInput = {
    payment_method_id?: number
    payment_method_type: string
    name: string
    description?: string | null
    payment?: paymentUncheckedCreateNestedManyWithoutPayment_methodInput
    payment_releases?: payment_releasesUncheckedCreateNestedManyWithoutPayment_methodInput
  }

  export type payment_methodCreateOrConnectWithoutUser_payment_methodsInput = {
    where: payment_methodWhereUniqueInput
    create: XOR<payment_methodCreateWithoutUser_payment_methodsInput, payment_methodUncheckedCreateWithoutUser_payment_methodsInput>
  }

  export type trolley_recipientUpsertWithWhereUniqueWithoutUser_payment_methodsInput = {
    where: trolley_recipientWhereUniqueInput
    update: XOR<trolley_recipientUpdateWithoutUser_payment_methodsInput, trolley_recipientUncheckedUpdateWithoutUser_payment_methodsInput>
    create: XOR<trolley_recipientCreateWithoutUser_payment_methodsInput, trolley_recipientUncheckedCreateWithoutUser_payment_methodsInput>
  }

  export type trolley_recipientUpdateWithWhereUniqueWithoutUser_payment_methodsInput = {
    where: trolley_recipientWhereUniqueInput
    data: XOR<trolley_recipientUpdateWithoutUser_payment_methodsInput, trolley_recipientUncheckedUpdateWithoutUser_payment_methodsInput>
  }

  export type trolley_recipientUpdateManyWithWhereWithoutUser_payment_methodsInput = {
    where: trolley_recipientScalarWhereInput
    data: XOR<trolley_recipientUpdateManyMutationInput, trolley_recipientUncheckedUpdateManyWithoutUser_payment_methodsInput>
  }

  export type trolley_recipientScalarWhereInput = {
    AND?: trolley_recipientScalarWhereInput | trolley_recipientScalarWhereInput[]
    OR?: trolley_recipientScalarWhereInput[]
    NOT?: trolley_recipientScalarWhereInput | trolley_recipientScalarWhereInput[]
    id?: IntFilter<"trolley_recipient"> | number
    user_payment_method_id?: UuidFilter<"trolley_recipient"> | string
    user_id?: StringFilter<"trolley_recipient"> | string
    trolley_id?: StringFilter<"trolley_recipient"> | string
  }

  export type payment_methodUpsertWithoutUser_payment_methodsInput = {
    update: XOR<payment_methodUpdateWithoutUser_payment_methodsInput, payment_methodUncheckedUpdateWithoutUser_payment_methodsInput>
    create: XOR<payment_methodCreateWithoutUser_payment_methodsInput, payment_methodUncheckedCreateWithoutUser_payment_methodsInput>
    where?: payment_methodWhereInput
  }

  export type payment_methodUpdateToOneWithWhereWithoutUser_payment_methodsInput = {
    where?: payment_methodWhereInput
    data: XOR<payment_methodUpdateWithoutUser_payment_methodsInput, payment_methodUncheckedUpdateWithoutUser_payment_methodsInput>
  }

  export type payment_methodUpdateWithoutUser_payment_methodsInput = {
    payment_method_type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: paymentUpdateManyWithoutPayment_methodNestedInput
    payment_releases?: payment_releasesUpdateManyWithoutPayment_methodNestedInput
  }

  export type payment_methodUncheckedUpdateWithoutUser_payment_methodsInput = {
    payment_method_id?: IntFieldUpdateOperationsInput | number
    payment_method_type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: paymentUncheckedUpdateManyWithoutPayment_methodNestedInput
    payment_releases?: payment_releasesUncheckedUpdateManyWithoutPayment_methodNestedInput
  }

  export type auditCreateWithoutWinningsInput = {
    id?: string
    user_id: string
    action: string
    note?: string | null
    created_at?: Date | string
  }

  export type auditUncheckedCreateWithoutWinningsInput = {
    id?: string
    user_id: string
    action: string
    note?: string | null
    created_at?: Date | string
  }

  export type auditCreateOrConnectWithoutWinningsInput = {
    where: auditWhereUniqueInput
    create: XOR<auditCreateWithoutWinningsInput, auditUncheckedCreateWithoutWinningsInput>
  }

  export type auditCreateManyWinningsInputEnvelope = {
    data: auditCreateManyWinningsInput | auditCreateManyWinningsInput[]
    skipDuplicates?: boolean
  }

  export type paymentCreateWithoutWinningsInput = {
    payment_id?: string
    net_amount?: Decimal | DecimalJsLike | number | string | null
    gross_amount?: Decimal | DecimalJsLike | number | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    installment_number?: number | null
    date_paid?: Date | string | null
    currency?: string | null
    created_by: string
    updated_by?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    version?: number | null
    release_date?: Date | string | null
    payment_status?: $Enums.payment_status | null
    billing_account: string
    challenge_markup?: Decimal | DecimalJsLike | number | string | null
    challenge_fee?: Decimal | DecimalJsLike | number | string | null
    payment_method?: payment_methodCreateNestedOneWithoutPaymentInput
    payment_release_associations?: payment_release_associationsCreateNestedManyWithoutPaymentInput
  }

  export type paymentUncheckedCreateWithoutWinningsInput = {
    payment_id?: string
    net_amount?: Decimal | DecimalJsLike | number | string | null
    gross_amount?: Decimal | DecimalJsLike | number | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    installment_number?: number | null
    date_paid?: Date | string | null
    payment_method_id?: number | null
    currency?: string | null
    created_by: string
    updated_by?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    version?: number | null
    release_date?: Date | string | null
    payment_status?: $Enums.payment_status | null
    billing_account: string
    challenge_markup?: Decimal | DecimalJsLike | number | string | null
    challenge_fee?: Decimal | DecimalJsLike | number | string | null
    payment_release_associations?: payment_release_associationsUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type paymentCreateOrConnectWithoutWinningsInput = {
    where: paymentWhereUniqueInput
    create: XOR<paymentCreateWithoutWinningsInput, paymentUncheckedCreateWithoutWinningsInput>
  }

  export type paymentCreateManyWinningsInputEnvelope = {
    data: paymentCreateManyWinningsInput | paymentCreateManyWinningsInput[]
    skipDuplicates?: boolean
  }

  export type originCreateWithoutWinningsInput = {
    origin_name: string
  }

  export type originUncheckedCreateWithoutWinningsInput = {
    origin_id?: number
    origin_name: string
  }

  export type originCreateOrConnectWithoutWinningsInput = {
    where: originWhereUniqueInput
    create: XOR<originCreateWithoutWinningsInput, originUncheckedCreateWithoutWinningsInput>
  }

  export type auditUpsertWithWhereUniqueWithoutWinningsInput = {
    where: auditWhereUniqueInput
    update: XOR<auditUpdateWithoutWinningsInput, auditUncheckedUpdateWithoutWinningsInput>
    create: XOR<auditCreateWithoutWinningsInput, auditUncheckedCreateWithoutWinningsInput>
  }

  export type auditUpdateWithWhereUniqueWithoutWinningsInput = {
    where: auditWhereUniqueInput
    data: XOR<auditUpdateWithoutWinningsInput, auditUncheckedUpdateWithoutWinningsInput>
  }

  export type auditUpdateManyWithWhereWithoutWinningsInput = {
    where: auditScalarWhereInput
    data: XOR<auditUpdateManyMutationInput, auditUncheckedUpdateManyWithoutWinningsInput>
  }

  export type auditScalarWhereInput = {
    AND?: auditScalarWhereInput | auditScalarWhereInput[]
    OR?: auditScalarWhereInput[]
    NOT?: auditScalarWhereInput | auditScalarWhereInput[]
    id?: UuidFilter<"audit"> | string
    winnings_id?: UuidFilter<"audit"> | string
    user_id?: StringFilter<"audit"> | string
    action?: StringFilter<"audit"> | string
    note?: StringNullableFilter<"audit"> | string | null
    created_at?: DateTimeFilter<"audit"> | Date | string
  }

  export type paymentUpsertWithWhereUniqueWithoutWinningsInput = {
    where: paymentWhereUniqueInput
    update: XOR<paymentUpdateWithoutWinningsInput, paymentUncheckedUpdateWithoutWinningsInput>
    create: XOR<paymentCreateWithoutWinningsInput, paymentUncheckedCreateWithoutWinningsInput>
  }

  export type paymentUpdateWithWhereUniqueWithoutWinningsInput = {
    where: paymentWhereUniqueInput
    data: XOR<paymentUpdateWithoutWinningsInput, paymentUncheckedUpdateWithoutWinningsInput>
  }

  export type paymentUpdateManyWithWhereWithoutWinningsInput = {
    where: paymentScalarWhereInput
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyWithoutWinningsInput>
  }

  export type originUpsertWithoutWinningsInput = {
    update: XOR<originUpdateWithoutWinningsInput, originUncheckedUpdateWithoutWinningsInput>
    create: XOR<originCreateWithoutWinningsInput, originUncheckedCreateWithoutWinningsInput>
    where?: originWhereInput
  }

  export type originUpdateToOneWithWhereWithoutWinningsInput = {
    where?: originWhereInput
    data: XOR<originUpdateWithoutWinningsInput, originUncheckedUpdateWithoutWinningsInput>
  }

  export type originUpdateWithoutWinningsInput = {
    origin_name?: StringFieldUpdateOperationsInput | string
  }

  export type originUncheckedUpdateWithoutWinningsInput = {
    origin_id?: IntFieldUpdateOperationsInput | number
    origin_name?: StringFieldUpdateOperationsInput | string
  }

  export type trolley_recipient_payment_methodCreateWithoutTrolley_recipientInput = {
    id?: string
    recipient_account_id: string
  }

  export type trolley_recipient_payment_methodUncheckedCreateWithoutTrolley_recipientInput = {
    id?: string
    recipient_account_id: string
  }

  export type trolley_recipient_payment_methodCreateOrConnectWithoutTrolley_recipientInput = {
    where: trolley_recipient_payment_methodWhereUniqueInput
    create: XOR<trolley_recipient_payment_methodCreateWithoutTrolley_recipientInput, trolley_recipient_payment_methodUncheckedCreateWithoutTrolley_recipientInput>
  }

  export type trolley_recipient_payment_methodCreateManyTrolley_recipientInputEnvelope = {
    data: trolley_recipient_payment_methodCreateManyTrolley_recipientInput | trolley_recipient_payment_methodCreateManyTrolley_recipientInput[]
    skipDuplicates?: boolean
  }

  export type user_payment_methodsCreateWithoutTrolley_payment_methodInput = {
    id?: string
    user_id: string
    status?: $Enums.payment_method_status | null
    payment_method: payment_methodCreateNestedOneWithoutUser_payment_methodsInput
  }

  export type user_payment_methodsUncheckedCreateWithoutTrolley_payment_methodInput = {
    id?: string
    user_id: string
    payment_method_id: number
    status?: $Enums.payment_method_status | null
  }

  export type user_payment_methodsCreateOrConnectWithoutTrolley_payment_methodInput = {
    where: user_payment_methodsWhereUniqueInput
    create: XOR<user_payment_methodsCreateWithoutTrolley_payment_methodInput, user_payment_methodsUncheckedCreateWithoutTrolley_payment_methodInput>
  }

  export type trolley_recipient_payment_methodUpsertWithWhereUniqueWithoutTrolley_recipientInput = {
    where: trolley_recipient_payment_methodWhereUniqueInput
    update: XOR<trolley_recipient_payment_methodUpdateWithoutTrolley_recipientInput, trolley_recipient_payment_methodUncheckedUpdateWithoutTrolley_recipientInput>
    create: XOR<trolley_recipient_payment_methodCreateWithoutTrolley_recipientInput, trolley_recipient_payment_methodUncheckedCreateWithoutTrolley_recipientInput>
  }

  export type trolley_recipient_payment_methodUpdateWithWhereUniqueWithoutTrolley_recipientInput = {
    where: trolley_recipient_payment_methodWhereUniqueInput
    data: XOR<trolley_recipient_payment_methodUpdateWithoutTrolley_recipientInput, trolley_recipient_payment_methodUncheckedUpdateWithoutTrolley_recipientInput>
  }

  export type trolley_recipient_payment_methodUpdateManyWithWhereWithoutTrolley_recipientInput = {
    where: trolley_recipient_payment_methodScalarWhereInput
    data: XOR<trolley_recipient_payment_methodUpdateManyMutationInput, trolley_recipient_payment_methodUncheckedUpdateManyWithoutTrolley_recipientInput>
  }

  export type trolley_recipient_payment_methodScalarWhereInput = {
    AND?: trolley_recipient_payment_methodScalarWhereInput | trolley_recipient_payment_methodScalarWhereInput[]
    OR?: trolley_recipient_payment_methodScalarWhereInput[]
    NOT?: trolley_recipient_payment_methodScalarWhereInput | trolley_recipient_payment_methodScalarWhereInput[]
    id?: UuidFilter<"trolley_recipient_payment_method"> | string
    trolley_recipient_id?: IntFilter<"trolley_recipient_payment_method"> | number
    recipient_account_id?: StringFilter<"trolley_recipient_payment_method"> | string
  }

  export type user_payment_methodsUpsertWithoutTrolley_payment_methodInput = {
    update: XOR<user_payment_methodsUpdateWithoutTrolley_payment_methodInput, user_payment_methodsUncheckedUpdateWithoutTrolley_payment_methodInput>
    create: XOR<user_payment_methodsCreateWithoutTrolley_payment_methodInput, user_payment_methodsUncheckedCreateWithoutTrolley_payment_methodInput>
    where?: user_payment_methodsWhereInput
  }

  export type user_payment_methodsUpdateToOneWithWhereWithoutTrolley_payment_methodInput = {
    where?: user_payment_methodsWhereInput
    data: XOR<user_payment_methodsUpdateWithoutTrolley_payment_methodInput, user_payment_methodsUncheckedUpdateWithoutTrolley_payment_methodInput>
  }

  export type user_payment_methodsUpdateWithoutTrolley_payment_methodInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumpayment_method_statusFieldUpdateOperationsInput | $Enums.payment_method_status | null
    payment_method?: payment_methodUpdateOneRequiredWithoutUser_payment_methodsNestedInput
  }

  export type user_payment_methodsUncheckedUpdateWithoutTrolley_payment_methodInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    payment_method_id?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumpayment_method_statusFieldUpdateOperationsInput | $Enums.payment_method_status | null
  }

  export type trolley_recipientCreateWithoutTrolley_recipient_payment_methodsInput = {
    user_id: string
    trolley_id: string
    user_payment_methods: user_payment_methodsCreateNestedOneWithoutTrolley_payment_methodInput
  }

  export type trolley_recipientUncheckedCreateWithoutTrolley_recipient_payment_methodsInput = {
    id?: number
    user_payment_method_id: string
    user_id: string
    trolley_id: string
  }

  export type trolley_recipientCreateOrConnectWithoutTrolley_recipient_payment_methodsInput = {
    where: trolley_recipientWhereUniqueInput
    create: XOR<trolley_recipientCreateWithoutTrolley_recipient_payment_methodsInput, trolley_recipientUncheckedCreateWithoutTrolley_recipient_payment_methodsInput>
  }

  export type trolley_recipientUpsertWithoutTrolley_recipient_payment_methodsInput = {
    update: XOR<trolley_recipientUpdateWithoutTrolley_recipient_payment_methodsInput, trolley_recipientUncheckedUpdateWithoutTrolley_recipient_payment_methodsInput>
    create: XOR<trolley_recipientCreateWithoutTrolley_recipient_payment_methodsInput, trolley_recipientUncheckedCreateWithoutTrolley_recipient_payment_methodsInput>
    where?: trolley_recipientWhereInput
  }

  export type trolley_recipientUpdateToOneWithWhereWithoutTrolley_recipient_payment_methodsInput = {
    where?: trolley_recipientWhereInput
    data: XOR<trolley_recipientUpdateWithoutTrolley_recipient_payment_methodsInput, trolley_recipientUncheckedUpdateWithoutTrolley_recipient_payment_methodsInput>
  }

  export type trolley_recipientUpdateWithoutTrolley_recipient_payment_methodsInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    trolley_id?: StringFieldUpdateOperationsInput | string
    user_payment_methods?: user_payment_methodsUpdateOneRequiredWithoutTrolley_payment_methodNestedInput
  }

  export type trolley_recipientUncheckedUpdateWithoutTrolley_recipient_payment_methodsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_payment_method_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    trolley_id?: StringFieldUpdateOperationsInput | string
  }

  export type winningsCreateManyOriginInput = {
    winning_id?: string
    winner_id: string
    type: $Enums.winnings_type
    category?: $Enums.winnings_category | null
    title?: string | null
    description?: string | null
    external_id?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    created_by: string
    updated_by?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type winningsUpdateWithoutOriginInput = {
    winning_id?: StringFieldUpdateOperationsInput | string
    winner_id?: StringFieldUpdateOperationsInput | string
    type?: Enumwinnings_typeFieldUpdateOperationsInput | $Enums.winnings_type
    category?: NullableEnumwinnings_categoryFieldUpdateOperationsInput | $Enums.winnings_category | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audit?: auditUpdateManyWithoutWinningsNestedInput
    payment?: paymentUpdateManyWithoutWinningsNestedInput
  }

  export type winningsUncheckedUpdateWithoutOriginInput = {
    winning_id?: StringFieldUpdateOperationsInput | string
    winner_id?: StringFieldUpdateOperationsInput | string
    type?: Enumwinnings_typeFieldUpdateOperationsInput | $Enums.winnings_type
    category?: NullableEnumwinnings_categoryFieldUpdateOperationsInput | $Enums.winnings_category | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audit?: auditUncheckedUpdateManyWithoutWinningsNestedInput
    payment?: paymentUncheckedUpdateManyWithoutWinningsNestedInput
  }

  export type winningsUncheckedUpdateManyWithoutOriginInput = {
    winning_id?: StringFieldUpdateOperationsInput | string
    winner_id?: StringFieldUpdateOperationsInput | string
    type?: Enumwinnings_typeFieldUpdateOperationsInput | $Enums.winnings_type
    category?: NullableEnumwinnings_categoryFieldUpdateOperationsInput | $Enums.winnings_category | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type payment_release_associationsCreateManyPaymentInput = {
    payment_release_id: string
  }

  export type payment_release_associationsUpdateWithoutPaymentInput = {
    payment_releases?: payment_releasesUpdateOneRequiredWithoutPayment_release_associationsNestedInput
  }

  export type payment_release_associationsUncheckedUpdateWithoutPaymentInput = {
    payment_release_id?: StringFieldUpdateOperationsInput | string
  }

  export type payment_release_associationsUncheckedUpdateManyWithoutPaymentInput = {
    payment_release_id?: StringFieldUpdateOperationsInput | string
  }

  export type paymentCreateManyPayment_methodInput = {
    payment_id?: string
    winnings_id: string
    net_amount?: Decimal | DecimalJsLike | number | string | null
    gross_amount?: Decimal | DecimalJsLike | number | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    installment_number?: number | null
    date_paid?: Date | string | null
    currency?: string | null
    created_by: string
    updated_by?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    version?: number | null
    release_date?: Date | string | null
    payment_status?: $Enums.payment_status | null
    billing_account: string
    challenge_markup?: Decimal | DecimalJsLike | number | string | null
    challenge_fee?: Decimal | DecimalJsLike | number | string | null
  }

  export type payment_releasesCreateManyPayment_methodInput = {
    payment_release_id?: string
    user_id: string
    total_net_amount: Decimal | DecimalJsLike | number | string
    status?: string | null
    external_transaction_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    payee_id?: string | null
    release_date?: Date | string | null
    batch_id?: string | null
  }

  export type user_payment_methodsCreateManyPayment_methodInput = {
    id?: string
    user_id: string
    status?: $Enums.payment_method_status | null
  }

  export type paymentUpdateWithoutPayment_methodInput = {
    payment_id?: StringFieldUpdateOperationsInput | string
    net_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gross_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    installment_number?: NullableIntFieldUpdateOperationsInput | number | null
    date_paid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    billing_account?: StringFieldUpdateOperationsInput | string
    challenge_markup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    challenge_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winnings?: winningsUpdateOneRequiredWithoutPaymentNestedInput
    payment_release_associations?: payment_release_associationsUpdateManyWithoutPaymentNestedInput
  }

  export type paymentUncheckedUpdateWithoutPayment_methodInput = {
    payment_id?: StringFieldUpdateOperationsInput | string
    winnings_id?: StringFieldUpdateOperationsInput | string
    net_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gross_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    installment_number?: NullableIntFieldUpdateOperationsInput | number | null
    date_paid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    billing_account?: StringFieldUpdateOperationsInput | string
    challenge_markup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    challenge_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_release_associations?: payment_release_associationsUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type paymentUncheckedUpdateManyWithoutPayment_methodInput = {
    payment_id?: StringFieldUpdateOperationsInput | string
    winnings_id?: StringFieldUpdateOperationsInput | string
    net_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gross_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    installment_number?: NullableIntFieldUpdateOperationsInput | number | null
    date_paid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    billing_account?: StringFieldUpdateOperationsInput | string
    challenge_markup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    challenge_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type payment_releasesUpdateWithoutPayment_methodInput = {
    payment_release_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    total_net_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    external_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payee_id?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_release_associations?: payment_release_associationsUpdateManyWithoutPayment_releasesNestedInput
  }

  export type payment_releasesUncheckedUpdateWithoutPayment_methodInput = {
    payment_release_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    total_net_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    external_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payee_id?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_release_associations?: payment_release_associationsUncheckedUpdateManyWithoutPayment_releasesNestedInput
  }

  export type payment_releasesUncheckedUpdateManyWithoutPayment_methodInput = {
    payment_release_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    total_net_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    external_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payee_id?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batch_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_payment_methodsUpdateWithoutPayment_methodInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumpayment_method_statusFieldUpdateOperationsInput | $Enums.payment_method_status | null
    trolley_payment_method?: trolley_recipientUpdateManyWithoutUser_payment_methodsNestedInput
  }

  export type user_payment_methodsUncheckedUpdateWithoutPayment_methodInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumpayment_method_statusFieldUpdateOperationsInput | $Enums.payment_method_status | null
    trolley_payment_method?: trolley_recipientUncheckedUpdateManyWithoutUser_payment_methodsNestedInput
  }

  export type user_payment_methodsUncheckedUpdateManyWithoutPayment_methodInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumpayment_method_statusFieldUpdateOperationsInput | $Enums.payment_method_status | null
  }

  export type payment_release_associationsCreateManyPayment_releasesInput = {
    payment_id: string
  }

  export type payment_release_associationsUpdateWithoutPayment_releasesInput = {
    payment?: paymentUpdateOneRequiredWithoutPayment_release_associationsNestedInput
  }

  export type payment_release_associationsUncheckedUpdateWithoutPayment_releasesInput = {
    payment_id?: StringFieldUpdateOperationsInput | string
  }

  export type payment_release_associationsUncheckedUpdateManyWithoutPayment_releasesInput = {
    payment_id?: StringFieldUpdateOperationsInput | string
  }

  export type trolley_recipientCreateManyUser_payment_methodsInput = {
    id?: number
    user_id: string
    trolley_id: string
  }

  export type trolley_recipientUpdateWithoutUser_payment_methodsInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    trolley_id?: StringFieldUpdateOperationsInput | string
    trolley_recipient_payment_methods?: trolley_recipient_payment_methodUpdateManyWithoutTrolley_recipientNestedInput
  }

  export type trolley_recipientUncheckedUpdateWithoutUser_payment_methodsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    trolley_id?: StringFieldUpdateOperationsInput | string
    trolley_recipient_payment_methods?: trolley_recipient_payment_methodUncheckedUpdateManyWithoutTrolley_recipientNestedInput
  }

  export type trolley_recipientUncheckedUpdateManyWithoutUser_payment_methodsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    trolley_id?: StringFieldUpdateOperationsInput | string
  }

  export type auditCreateManyWinningsInput = {
    id?: string
    user_id: string
    action: string
    note?: string | null
    created_at?: Date | string
  }

  export type paymentCreateManyWinningsInput = {
    payment_id?: string
    net_amount?: Decimal | DecimalJsLike | number | string | null
    gross_amount?: Decimal | DecimalJsLike | number | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    installment_number?: number | null
    date_paid?: Date | string | null
    payment_method_id?: number | null
    currency?: string | null
    created_by: string
    updated_by?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    version?: number | null
    release_date?: Date | string | null
    payment_status?: $Enums.payment_status | null
    billing_account: string
    challenge_markup?: Decimal | DecimalJsLike | number | string | null
    challenge_fee?: Decimal | DecimalJsLike | number | string | null
  }

  export type auditUpdateWithoutWinningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auditUncheckedUpdateWithoutWinningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auditUncheckedUpdateManyWithoutWinningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentUpdateWithoutWinningsInput = {
    payment_id?: StringFieldUpdateOperationsInput | string
    net_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gross_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    installment_number?: NullableIntFieldUpdateOperationsInput | number | null
    date_paid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    billing_account?: StringFieldUpdateOperationsInput | string
    challenge_markup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    challenge_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_method?: payment_methodUpdateOneWithoutPaymentNestedInput
    payment_release_associations?: payment_release_associationsUpdateManyWithoutPaymentNestedInput
  }

  export type paymentUncheckedUpdateWithoutWinningsInput = {
    payment_id?: StringFieldUpdateOperationsInput | string
    net_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gross_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    installment_number?: NullableIntFieldUpdateOperationsInput | number | null
    date_paid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_method_id?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    billing_account?: StringFieldUpdateOperationsInput | string
    challenge_markup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    challenge_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_release_associations?: payment_release_associationsUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type paymentUncheckedUpdateManyWithoutWinningsInput = {
    payment_id?: StringFieldUpdateOperationsInput | string
    net_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gross_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    installment_number?: NullableIntFieldUpdateOperationsInput | number | null
    date_paid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_method_id?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    billing_account?: StringFieldUpdateOperationsInput | string
    challenge_markup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    challenge_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type trolley_recipient_payment_methodCreateManyTrolley_recipientInput = {
    id?: string
    recipient_account_id: string
  }

  export type trolley_recipient_payment_methodUpdateWithoutTrolley_recipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient_account_id?: StringFieldUpdateOperationsInput | string
  }

  export type trolley_recipient_payment_methodUncheckedUpdateWithoutTrolley_recipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient_account_id?: StringFieldUpdateOperationsInput | string
  }

  export type trolley_recipient_payment_methodUncheckedUpdateManyWithoutTrolley_recipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient_account_id?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}